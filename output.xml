<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE dblp SYSTEM "dblp.dtd">
<dblp>
<article mdate="2011-01-11" key="journals/acta/Saxena96">
<author>Sanjeev Saxena</author>
<title>Parallel Integer Sorting and Simulation Amongst CRCW Models.</title>
<pages>607-619</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#Saxena96</url>
<abstract>In this paper a general technique for reducing processors in simulation without any increase in time is described. This results in an O(√logn) time algorithm for simulating one step of PRIORITY on TOLERANT with processor-time product of O(n log logn); the same as that for simulating PRIORITY on ARBITRARY. This is used to obtain anO(logn/log logn + √logn (log logm − log logn)) time algorithm for sortingn integers from the set {0,...,m − 1},m ≧n, with a processor-time product ofO(n log logm log logn) on a TOLERANT CRCW PRAM. New upper and lower bounds for ordered chaining problem on an allocated COMMON CRCW model are also obtained. The algorithm for ordered chaining takesO(logn/log logn) time on an allocated PRAM of sizen. It is shown that this result is best possible (upto a constant multiplicative factor) by obtaining a lower bound of Ω(r logn/(logr + log logn)) for finding the first (leftmost one) live processor on an allocated-COMMON PRAM of sizen ofr-slow virtual processors (one processor simulatesr processors of allocated PRAM). As a result, for ordered chaining problem, “processor-time product” has to be at least Ω(n logn/log logn) for any poly-logarithmic time algorithm.Algorithm for ordered-chaining problem results in anO(logN/log logN) time algorithm for (stable) sorting ofn integers from the set {0,...,m − 1} withn-processors on a COMMON CRCW PRAM; hereN = max(n, m). In particular if,m =n O(1), then sorting takes Θ(logn/log logn) time on both TOLERANT and COMMON CRCW PRAMs. Processor-time product for TOLERANT isO(n(log logn)2). Algorithm for COMMON usesn processors.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036466</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Simon83">
<author>Hans-Ulrich Simon</author>
<title>Pattern Matching in Trees and Nets.</title>
<pages>227-248</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Simon83</url>
<abstract>Rational patterns are used to specify recognizable tree languages. It is shown that, given a rational patternp and a treet, one can decide inO(¦p¦·¦t¦) steps whether there is some match ofp int. Problems of this kind generalized to forests or nets are shown to be NP-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01257084</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GoodmanS83">
<author>Nathan Goodman</author>
<author>Oded Shmueli</author>
<title>NP-complete Problems Simplified on Tree Schemas.</title>
<pages>171-178</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#GoodmanS83</url>
<abstract>A schema is a collection of finite subsets of a set. One can partition the class of all schemas into tree schemas and cyclic schemas. This partitioning has been extensively studied in relational database theory. In this paper we examine the impact of tree schemas on some NP-complete problems. We show that tree schema instances can be efficiently solved (i.e., polynomially) for certain NP-complete problems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289414</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Blum82">
<author>Norbert Blum</author>
<title>On the Power of Chain Rules in Context Free Grammars.</title>
<pages>425-433</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Blum82</url>
<abstract>L n , has a cfg of size O(n)Any chain rule free cfg for L n has size Ω(n log log n).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264161</ee>
</article>
<article mdate="2013-11-28" key="journals/acta/Schonhage77"> 
<author>Arnold Sch&ouml;nhage</author>
<title>Schnelle Multiplikation von Polynomen &uuml;ber K&ouml;rpern der Charakteristik 2.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>395-398</pages>
<url>db/journals/acta/acta7.html#Schonhage77</url>
<abstract>Polynomial multiplication of degree N can be accomplished in time O (N · log N) provided the scalar field contains suitable roots of unity. Otherwise at least O (N · log N · log log N) is obtained by a modified version of the Schönhage-Strassen multiplication which employs computations modulo 1 + xn (where N = 2n), if the field contains 2−1, or modulo 1 + xn + x2N, if 3−1 exists. The latter method covering all fields of characteristic 2 is presented here in detail.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289470</ee>
</article>

<article mdate="2011-02-16" key="journals/acta/Honkala11">
<author>Juha Honkala</author>
<title>A characterization of rational D0L power series.</title>
<pages>19-24</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We study D0L power series over an arbitrary field. We characterize those D0L power series which are also rational series. As a consequence we show that rationality is decidable for D0L power series over many fields.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0128-1</ee>
<url>db/journals/acta/acta48.html#Honkala11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HuangL87">
<author>Chua-Huang Huang</author>
<author>Christian Lengauer</author>
<title>The Derivation of Systolic Implementations of Programs.</title>
<pages>595-632</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta24.html#HuangL87</url>
<abstract>We present a mathematically rigorous and, at the same time, convenient method for systolic design and derive systolic designs for three matrix computation problems. Each design is synthesized from a simple program and a proposed layout of processors. The synthesis derives a systolic parallel execution, channel connections for the proposed processor layout, and an arrangement of data streams such that the systolic execution can begin. Our choices of designs are governed by formal theorems. The synthesis method is implementable and is particularly effective if implemented with graphics capability. Our implementation on the Symbolics 3600 displays the resulting designs and simulated executions graphically on the screen. The method's centerpiece, a transformation of sequential program computations into systolic parallel ones, has been mechanically proved correct.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00282618</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/FinkelC87">
<author>Alain Finkel</author>
<author>Annie Choquet</author>
<title>Fifo Nets Without Order Deadlock.</title>
<pages>15-36</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta25.html#FinkelC87</url>
<abstract>We introduce a generalisation of free choice nets to fifo. These fifo nets are free from deadlocks caused by the order of messages in fifo queues. We describe some tools for their analysis, using the fact that they are weakly monotonous, and that there is a narrow relation between their languages and those of the associated coloured nets. Therefore, quasi-liveness, finite termination and liveness are decidable properties.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF00268843</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Biskup78">
<author>Joachim Biskup</author>
<title>On the Complementation Rule for Multivalued Dependencies in Database Relations.</title>
<pages>297-305</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Biskup78</url>
<abstract>We study the interrelation between various versions of the complementation rule and other inference rules for multivalued dependencies in database relations. In particular we settle two open questions of [1] concerning the derivability of inference rules for Boolean operations on the right side of multivalued dependencies. Furthermore we prove that there is a trade-off between the complementation rule and the augmentation rule.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264322</ee>
</article>
<article mdate="2015-07-14" key="journals/acta/BozapalidisFR12">
<author>Symeon Bozapalidis</author>
<author>Zolt&aacute;n F&uuml;l&ouml;p 0001</author>
<author>George Rahonis</author>
<title>Equational weighted tree transformations.</title>
<pages>29-52</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We consider systems of equations of weighted tree transformations with finite support over continuous and commutative semirings. We define a weighted relation to be equational, if it is a component of the least solution of such a system of equations in a pair of algebras. In particular, we focus on equational weighted tree transformations which are equational relations obtained by considering the least solutions of such systems in pairs of term algebras. We characterize equational weighted tree transformations in terms of weighted tree transformations defined by different weighted bimorphisms. To demonstrate the robustness of equational weighted tree transformations, we give an equational definition of the class of linear and nondeleting weighted top-down tree transformations and of the class of linear and nondeleting weighted extended top-down tree transformations. Finally, we prove that a weighted relation is equational if and only if it is, roughly speaking, the morphic image of a weighted equational tree transformation.</abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0148-5</ee>
<url>db/journals/acta/acta49.html#BozapalidisFR12</url>
</article>
<article mdate="2006-11-22" key="journals/acta/KhomenkoKKV06">
<author>Victor Khomenko</author>
<author>Alex Kondratyev</author>
<author>Maciej Koutny</author>
<author>Walter Vogler</author>
<title>Merged processes: a new condensed representation of Petri net behaviour.</title>
<pages>307-330</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Model checking based on Petri net unfoldings is an approach widely applied to cope with the state space explosion problem. In this paper, we propose a new condensed representation of a Petri net’s behaviour called merged processes, which copes well not only with concurrency, but also with other sources of state space explosion, viz sequences of choices and non-safeness. Moreover, this representation is sufficiently similar to the traditional unfoldings, so that a large body of results developed for the latter can be re-used. Experimental results indicate that the proposed representation of a Petri net’s behaviour alleviates the state space explosion problem to a significant degree and is suitable for model checking.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0023-y</ee>
<url>db/journals/acta/acta43.html#KhomenkoKKV06</url>
</article>
<article mdate="2013-05-10" key="journals/acta/Hesselink13">
<author>Wim H. Hesselink</author>
<title>Verifying a simplification of mutual exclusion by Lycklama-Hadzilacos.</title>
<pages>199-228</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>A simplification of the mutual exclusion algorithm of Lycklama and Hadzilacos (ACM Trans Program Lang Syst 13:558–576, 1991) is presented. It uses only four nonatomic shared bits per thread to guarantee mutual exclusion with the first-come-first-served property. The algorithm is verified by assertional methods, aided by the proof assistant PVS. A variation with five bits per thread is also given. This variation may give better performance when the number of threads is large. The use of the proof assistant made it easy to transfer the proof of the main algorithm to the variation.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0178-2</ee>
<url>db/journals/acta/acta50.html#Hesselink13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ronse83">
<author>Christian Ronse</author>
<title>A Three-Stage Construction for Multiconnection Networks.</title>
<pages>197-206</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Ronse83</url>
<abstract>A multiconnection network of size N is a switching network with N inputs and N outputs which realizes multiconnections, i.e., connections between the N inputs and N outputs in such a way that every output is connected to exactly one input, but an input can be connected to an arbitrary number of outputs. That network is complete if it can realize all N N multiconnections. This structure generalizes the permutation network. We consider here the design of multiconnection networks by a three-stage Clos network using complete substitution networks as its building cells and we show that the resulting multiconnection network is complete if and only if the cells in the middle stage have size 2. Moreover, we describe the control algorithm for such a network. This leads to the design of cellular multiconnection networks of arbitrary size with a relatively simple control algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289416</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CritchlowP91">
<author>Carol Critchlow</author>
<author>Prakash Panangaden</author>
<title>The Expressive Power of Delay Operators in SCCS.</title>
<pages>447-452</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#CritchlowP91</url>
<abstract>We investigate the relative expressive power of finite delay operators in SCCS. These were introduced by Milner and by Hennessy to study fairness properties of processes in the context of SCCS. We show that the context sensitive delay operator introduced by Hennessy is more expressive than the finite delay operator introduced by Milner. This result is closely related to recent results by Pananagden and Stark on the expressive power of fair merge in asynchronous dataflow (Kahn) networks. It indicates that the expressiveness results obtained there are not sensitive to the precise computational model since SCCS, unlike Kahn networks, is synchronous and permits expansion of recursively defined processes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178582</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Milner96">
<author>Robin Milner</author>
<title>Calculi for Interaction.</title>
<pages>707-737</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta33.html#Milner96</url>
<abstract>Action structures have previously been proposed as an algebra for both the syntax and the semantics of interactive computation. Here, a class of concrete action structures calledaction calculi is identified, which can serve as a non-linear syntax for a wide variety of models of interactive behaviour. Each action in an action calculus is represented as an assembly ofmolecules; the syntactic binding ofnames is the means by which molecules are bound together. A graphical form,action graphs, is used to aid presentation. One action calculus differs from another only in its generators, calledcontrols.Action calculi generalise a previously defined action structure PIC for the π- calculus. Several extensions to PIC are given as action calculi, giving essentially the same power as the π-calculus. An action calculus is also given for the typed λ-calculus, and for Petri nets parametrized on their places and transitions.An equational characterization of action calculi is given: each action calculusA is the quotient of a term algebra by certain equations. The terms are generated by a set of operators, including those basic to all action structures as well as the controls specific toA; the equations are the basic axioms of action structures together with four additional axiom schemata.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036472</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Darlington78">
<author>John Darlington</author>
<title>A Synthesis of Several Sorting Algorithms.</title>
<pages>1-30</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Darlington78</url>
<abstract>We synthesise versions of six well known sorting algorithms from a common specification using program transformation techniques. On the way to the sorting algorithms we synthesise three algorithms for generating permutations thus building up a family tree for the sorts exposing certain relationships between them.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264597</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CalzarossaIS86">
<author>Maria Calzarossa</author>
<author>M. Italiani</author>
<author>Giuseppe Serazzi</author>
<title>A Workload Model Representative of Static and Dynamic Characteristics.</title>
<pages>255-266</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#CalzarossaIS86</url>
<abstract>A technique to implement a workload model that must be representative of both static and dynamic characteristics of a workload is presented. The main goal of this work is the construction of a representative and compact artificial workload model. The approach taken is first to assign the set of workload components to classes having homogeneous static (i.e., load-independent) characteristics using clustering and then to model the dynamic sequence of components execution with a suitable stochastic process. The representativeness of such a workload model may be verified applying the physically or the function-oriented criteria for the static aspects and the performance-oriented criterion for the dynamic aspects considered. The results of an experimental application of this technique to model the workload of a university environment are presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289113</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Vajnovszki02">
<author>Vincent Vajnovszki</author>
<title>Gray visiting Motzkins.</title>
<pages>793-811</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>11/12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038011/20380793.htm</ee>
<url>db/journals/acta/acta38.html#Vajnovszki02</url>
</article>
<article mdate="2014-11-03" key="journals/acta/VoglerS014">
<author>Walter Vogler</author>
<author>Christian Stahl</author>
<author>Richard M&uuml;ller 0001</author>
<title>Trace- and failure-based semantics for responsiveness.</title>
<pages>499-552</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>We study open systems modeled as Petri nets with an interface for asynchronous (i.e., buffered) communication with other open systems. As a minimal requirement for successful communication, we investigate responsiveness, which guarantees that an open system and its environment always have the possibility to communicate. We investigate responsiveness with and without final states and also their respective bounded variants, where the number of pending messages never exceeds a previously known bound. Responsiveness accordance describes when one open system can be safely replaced by another open system. We present a trace-based characterization for each accordance variant. As none of the relations turns out to be compositional (i.e., it is no precongruence), we characterize the coarsest compositional relation (i.e., the coarsest precongruence) that is contained in each relation, using a variation of should testing. For the two unbounded variants, the precongruences are not decidable, but for the two bounded variants we show decidability.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0205-y</ee>
<url>db/journals/acta/acta51.html#VoglerS014</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Devroye87">
<author>Luc Devroye</author>
<title>Branching Processes in the Analysis of the Heights of Trees.</title>
<pages>277-298</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta24.html#Devroye87</url>
<abstract>It is shown how the theory of branching processes can be applied in the analysis of the expected height of random trees. In particular, we will study the height of random binary search trees, random k—d trees, quadtrees and union-find trees under various models of randomization. For example, for the random binary search tree constructed from a random permutation of 1,..., n, it is shown that H n/(c log(n)) tends to 1 in probability and in the mean as n→∞, where H n is the height of the tree, and c =4.31107... is a solution of the equation \(\left( {\frac{{2e}}{c}} \right) = 1\). In addition, we show that \(H_n - c log (n) = {\text{O}}(\sqrt {log(n)loglog(n)} )\) in probability.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265991</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HuT72"> 
<author>T. C. Hu</author>
<author>K. C. Tan</author>
<title>Least Upper Bound on the Cost of Optimum Binary Search Trees.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>307-310</pages>
<url>db/journals/acta/acta1.html#HuT72</url>
<abstract>This paper gives the least upper bound on the weighted path length of an optimum lexicographic (alphabetic) binary search tree as a function of n, given the total weight of the n terminal nodes and the n—1 internal nodes to be one.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289510</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Franta76">
<author>William R. Franta</author>
<title>The Mathematical Analysis of the Computer System Modeled as a Two Stage Cyclic Queue.</title>
<pages>187-209</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Franta76</url>
<abstract>The use of network queueing models to aid in the analysis and design of multiprogrammed computer system is well established. Their use provides qualitative insights as well as quantitative measures. These latter measures may be used either directly to assess system performance, or indirectly to provide a theoretical backstop for the validation of more elaborate simulation modes. Further, we note that the mathematical analysis of these models is of itself interesting and worthy of consideration.In this paper we concentrate on the simplest possible network model, that is, that model which consists of two nodes, through which jobs cyclically and repeatedly pass in their bid for service from the node servers. As we shall hopefully demonstrate a wide variety of situations can be represented by variations of this simple model. In this endeavor we shall include a consideration of several variants which, at least to date, defy exact mathematical analysis. In these latter cases we are therefore much interested in the availability of good quality approximate solutions, and several are discussed.As our title and preceding remarks suggest it is the mathematical analysis of these models on which we concentrate, pointing out for each, of course, what its analysis contributes to the totality of information.In the closing section we review our effort and point out the relationship of our results to more general network models.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268500</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kindler95"> 
<author>Ekkart Kindler</author>
<title>Invariants, Composition, and Substitution.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>4</number>
<year>1995</year> 
<pages>299-312</pages>
<url>db/journals/acta/acta32.html#Kindler95</url>
<abstract>In the literature the notion of asystem invariant has been formalized in two different ways, differing in the treatment of unreachable transitions. We call the more general notion, which ignores unreachable transitions,invariant sets of a system, the more restricted notion, which considers unreachable transitions,inductive sets of a system.It turns out that even if we are only interested in invariant sets of a system, inductive sets play an important rôle for proving invariant sets of system in a compositional way. This paper shows the interplay of both kinds of invariants; particularly, we show that inductive sets arefully abstract with respect to invariant sets.One essential difference between invariant and inductive sets is that thesubstitution rule is only valid for invariant sets, and thecomposition rule is only valid for inductive sets. Sometimes it seems desirable to have a notion of invariants for which both rules are valid. We show that every notion of an invariant enjoying both rules is very restrictive.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178381</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Kouvatsos86">
<author>Demetres D. Kouvatsos</author>
<title>Maximum Entropy and the <i> G/G/1/N </i> Queue.</title>
<pages>545-565</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#Kouvatsos86</url>
<abstract>A new “hybrid” analytic framework, based on the principle of maximum entropy, is used to derive a closed form expression for the queue length distribution of a G/G/1 finite capacity queue. It is shown that “Birth-Death” homogeneous recursions for a single resource queue are special cases of maximum entropy “one-step” transitions which can be applied either in an operational or stochastic context. Furthermore, an “equivalence” relationship is used to analyse two-stage cyclic queueing networks with general service times, and favourable comparisons are made with global balance and approximate results. Numerical examples provide useful information on how critically system behaviour is affected by the distributional form of interarrival and service patterns. Comments on the implication of the work to the performance analysis and aggregation of computer systems are included.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288469</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GorlatchL00">
<author>Sergei Gorlatch</author>
<author>Christian Lengauer</author>
<title>Abstraction and Performance in the Design of Parallel Programs: An Overview of the SAT Approach.</title>
<pages>761-803</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360761.htm</ee>
<url>db/journals/acta/acta36.html#GorlatchL00</url>
</article>
<article mdate="2009-06-22" key="journals/acta/Meyer09">
<author>Roland Meyer</author>
<title>A theory of structural stationarity in the <i>pi</i> -Calculus.</title>
<pages>87-137</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Automata-theoretic representations have proven useful in the automatic and exact analysis of computing systems. We propose a new semantical mapping of π-Calculus processes into place/transition Petri nets. Our translation exploits the connections created by restricted names and can yield finite nets even for processes with unbounded name and unbounded process creation. The property of structural stationarity characterises the processes mapped to finite nets. We provide exact conditions for structural stationarity using novel characteristic functions. As application of the theory, we identify a rich syntactic class of structurally stationary processes, called finite handler processes. Our Petri net translation facilitates the automatic verification of a case study modelled in this class.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0091-x</ee>
<url>db/journals/acta/acta46.html#Meyer09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Reisch81">
<author>Stefan Reisch</author>
<title>Hex ist PSPACE-vollst&auml;ndig.</title>
<pages>167-191</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Reisch81</url>
<abstract>There are a number of board games such as Checkers [2], Go [5], and Gobang [8], which are known to be PSPACE-hard. This means that the problem to determine the player having a winning strategy in a given situation on an n×n board of one of these games is as hard to solve as everything computable in polynomial space. PSPACE-completeness has been previously proven for some combinatorial games played on graphs or by logical formulas [1, 9].In this paper we will show that the same holds for the game of Hex. The crucial point of the proof is to establish PSPACE-hardness for a generalization of Hex played on planar graphs. This will be done by showing that the problem, whether a given quantified Boolean formula in conjunctive normal form is true, is polynomial time-reducible to the decision problem for generalized Hex. In order to do this we will use methods, which were also used to prove PSPACE-completeness of planar Geography in [5]. Therefore our proof is quite different from the proof provided by Even and Tarjan [1], who showed PSPACE-completeness of generalized Hex played on arbitrary graphs. Since it is easy to see that the decision problem for Hex is in PS PACE, the decision problem for Hex is PSPACE-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288964</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Csuhaj-VarjuM00">
<author>Erzs&eacute;bet Csuhaj-Varj&uacute;</author>
<author>Victor Mitrana</author>
<title>Evolutionary Systems: A Language Generating Device Inspired by Evolving Communities of Cells.</title>
<pages>913-926</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036011/00360913.htm</ee>
<url>db/journals/acta/acta36.html#Csuhaj-VarjuM00</url>
</article>
<article mdate="2008-05-21" key="journals/acta/Janicki08">
<author>Ryszard Janicki</author>
<title>Relational structures model of concurrency.</title>
<pages>279-320</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>The paper deals with the foundations of concurrency theory. We show how structurally complex concurrent behaviours can be modelled by relational structures \({(X, \diamondsuit, \sqsubset)}\) , where X is a set (of event occurrences), and \({\diamondsuit}\) (interpreted as commutativity) and \({\sqsubset}\) (interpreted as weak causality) are binary relations on X. The paper is a continuation of the approach initiated in Gaifman and Pratt (Proceedings of LICS’87, pp 72–85, 1987), Lamport (J ACM 33:313–326, 1986), Abraham et al. (Semantics for concurrency, workshops in computing. Springer, Heidelberg, pp 311–323, 1990) and Janicki and Koutny (Lect Notes Comput Sci 506:59–74, 1991), substantially developed in Janicki and Koutny (Theoretical Computer Science 112:5–52, 1993) and Janicki and Koutny (Acta Informatica 34:367–388, 1997), and recently generalized in Guo and Janicki (Lect Notes Comput Sci 2422:178–191, 2002) and Janicki (Lect Notes Comput Sci 3407:84–98, 2005). For the first time the full model for the most general case is given.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0071-6</ee>
<url>db/journals/acta/acta45.html#Janicki08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Russell77"> 
<author>Bruce Russell</author>
<title>On an Equivalence between Continuation and Stack Semantics.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>113-123</pages>
<url>db/journals/acta/acta8.html#Russell77</url>
<abstract>A class of continuation models and a class of stack models for defining the semantics of programming languages are specified. A transformation is given that maps any continuation model into an equivalent stack model, and the equivalence is proved. The transformation is illustrated for an example language which includes gotos and recursive procedures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289244</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtR74"> 
<author>Andrzej Ehrenfeucht</author>
<author>Grzegorz Rozenberg</author>
<title>Nonterminals Versus Homomorphisms in Defining Languages for Some Classes of Rewriting Systems.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>265-283</pages>
<url>db/journals/acta/acta3.html#EhrenfeuchtR74</url>
<abstract>taking out of all strings generated by G only those which are over a distinguished subalphabet of G, ortranslating the set of all strings generated by G by a fixed homomorphism.The “trade-offs” between these two mechanisms for defining languages are discussed for both “parallel” rewriting systems from the developmental systems hierarchy and “sequential” rewriting systems from the Chomsky hierarchy.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288638</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Kemp80">
<author>Rainer Kemp</author>
<title>A Note on the Density of Inherently Ambiguous Context-free Languages.</title>
<pages>295-298</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Kemp80</url>
<abstract>In this paper we give the first example of an inherently ambiguous context-free language with a non-algebraic density.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264258</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HanI89">
<author>Yijie Han</author>
<author>Yoshihide Igarashi</author>
<title>Time Lower Bounds for Parallel Sorting on a Mesh-Conected Processor Array.</title>
<pages>643-655</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta26.html#HanI89</url>
<abstract>We prove that (1+√6/2)n ≈ 2.22n is a time lower bound independent of indexing schemes for sorting n2 items on an n × n mesh-connected processor array. We distinguish between indexing schemes by showing that there exists an indexing scheme which is provably worse than the snake-like row-major indexing for sorting. We also derive lower bounds for various indexing schemes. All these results are obtained by using the chain argument which we provide in this paper.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288975</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AkyildizB89">
<author>Ian F. Akyildiz</author>
<author>Horst von Brand</author>
<title>Computational Algorithms for Networks of Queues with Rejection Blocking.</title>
<pages>559-576</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta26.html#AkyildizB89</url>
<abstract>Open, closed and mixed queueing networks with reversible routing, multiple job classes and rejection blocking are investigated. In rejection blocking networks blocking event occurs when upon completion of its service of a particular station's server, a job attempts to proceed to its next station. If, at that moment, its destination station is full, the job is rejected. The job goes back to the server of the source station and immediately receives a new service. This is repeated until the next station releases a job and a place becomes available. In the model jobs may change their class membership and general service time distributions depending on the job class are allowed. Two station types are considered: Either the scheduling discipline is symmetric, in which case the service time distributions are allowed to be general and dependent on the job class or the service time distributions at a station are all identical exponential distributions, in which case more general scheduling disciplines are allowed. An exact product form solution for equilibrium state probabilities is presented. Using the exact product form solution of the equilibrium state distribution, algorithms for computation of performance measures, such as mean number of jobs and throughputs, are derived. The complexity of the algorithms is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263580</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChenM95"> 
<author>X. J. Chen</author>
<author>Carlo Montangero</author>
<title>Compositional Refinements in Multiple Blackboard Systems.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>5</number>
<year>1995</year> 
<pages>415-458</pages>
<url>db/journals/acta/acta32.html#ChenM95</url>
<abstract>In this paper we introduce CONESP, a concurrent system built according to the SMoLCS methodology to provide an abstract model of the coordination language Extended Shared Prolog (ESP), which is based on the integration of the blackboard paradigm with Logic Programming. CONESP is a hierarchy of blackboard systems, each consisting of a passive blackboard tree and a collection of active components including parallel agents and dynamic (sub)systems. An implementation relationshop between two hierarchies is defined, which is shown to be compositional. Some techniques have also been developed for the direct proof, i.e. the basic step in the inductive proof that one system implements another.ESP is being used in the Oikos environment for software process modelling. The results of this paper are the basis for the formal verification of the correctness of the software process models built by stepwise-refinements in Oikos.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213078</ee>
</article>

<article mdate="2015-02-04" key="journals/acta/GlabbeekGO15">
<author>Rob J. van Glabbeek</author>
<author>Ursula Goltz</author>
<author>Ernst-R&uuml;diger Olderog</author>
<title>Special issue on "Combining Compositionality and Concurrency": part 1.</title>
<pages>3-4</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0213-y</ee>
<url>db/journals/acta/acta52.html#GlabbeekGO15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Santone02">
<author>Antonella Santone</author>
<title>Automatic verification of concurrent systems using a formula-based compositional approach.</title>
<pages>531-564</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038008/20380531.htm</ee>
<url>db/journals/acta/acta38.html#Santone02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hehner78">
<author>Eric C. R. Hehner</author>
<title>On Removing the Machine from the Language.</title>
<pages>229-243</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Hehner78</url>
<abstract>Many of the problems in programming languages today are a result of the model of computation offered by our machines. Structured programming combats these problems by restricting flow of control and storage references to a relatively safe set of control and data structures. Some current research attempts to aid programming reliability by enforcing such restrictions in the programming language. This paper proposes a simpler view of some basic language elements (variable, assignment, parameter), not based on our machines, that is safe without restriction. Structuring is then defined independently of what is being structured. A single, simple structure, applied to both values and assignments, yields equivalents for the “safe set” of data and control structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264318</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChungES85">
<author>Moon-Jung Chung</author>
<author>Michael Evangelist</author>
<author>Ivan Hal Sudborough</author>
<title>Complete Problems for Space Bounded Subclasses of NP.</title>
<pages>379-395</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#ChungES85</url>
<abstract>Several problems are shown to be log space complete, when restricted to bandwidth f(n), for the subclass of NP defined by nondeterministic polynomial time bounded Turing machines with a simultaneous f(n) space restriction, denoted by NTISP(poly, f(n)). These problems are NOT-ALL-EQUAL 3SAT, MONOCHROMATIC TRIANGLE, CUBIC SUBGRAPH, DOMINATING SET, ONE-IN-THREE 3SAT and MONOTONE 3SAT. The problems DOMATIC NUMBER, PARTITION INTO FORESTS and DISJOINT CONNECTING PATHS restricted to bandwidth f(n) are shown to be log space hard for NTISP(poly, f(n)). Their membership in the class NTISP(poly, f(n)) is currently open. As one application of these results, we note that the first six of the problems mentioned are examples of NSPACE(log n) complete problems when restricted to bandwidth log n.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288774</ee>
</article>
<article mdate="2014-05-19" key="journals/acta/BulychevDLL14">
<author>Peter E. Bulychev</author>
<author>Alexandre David</author>
<author>Kim G. Larsen</author>
<author>Guangyuan Li</author>
<title>Efficient controller synthesis for a fragment of MTL<sub>0,&#8734;</sub>.</title>
<pages>165-192</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>In this paper we offer an efficient controller synthesis algorithm for assume-guarantee specifications of the form \(\varphi _1 \wedge \varphi _2 \wedge \cdots \wedge \varphi _n \rightarrow \psi _1 \wedge \psi _2 \wedge \cdots \wedge \psi _m\). Here, \(\{\varphi _i,\psi _j\}\) are all safety-MTL\(_{0, \infty }\) properties, where the sub-formulas \(\{\varphi _i\}\) are supposed to specify assumptions of the environment and the sub-formulas \(\{\psi _j\}\) are specifying requirements to be guaranteed by the controller. Our synthesis method exploits the engine of Uppaal-Tiga and the novel translation of safety- and co-safety-MTL\(_{0, \infty }\) properties into under-approximating, deterministic timed automata. Our approach avoids determinization of Büchi automata, which is the main obstacle for the practical applicability of controller synthesis for linear-time specifications. The experiments demonstrate that the chosen specification formalism is expressive enough to specify complex behaviors. The proposed approach is sound but not complete. However, it successfully produced solutions for all the experiments. Additionally we compared our tool with Acacia+ and Unbeast, state-of-the-art LTL synthesis tools; and our tool demonstrated better timing results, when we applied both tools to the analogous specifications.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0189-z</ee>
<url>db/journals/acta/acta51.html#BulychevDLL14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BuddA82">
<author>Timothy A. Budd</author>
<author>Dana Angluin</author>
<title>Two Notions of Correctness and Their Relation to Testing.</title>
<pages>31-45</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#BuddA82</url>
<abstract>We consider two interpretations for what it means for test data to demonstrate correctness. For each interpretation, we examine under what conditions data sufficient to demonstrate correctness exists, and whether it can be automatically detected and/or generated. We establish the relation between these questions and the problem of deciding equivalence of two programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625279</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Markowsky81">
<author>George Markowsky</author>
<title>Best Huffman Trees.</title>
<pages>363-370</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Markowsky81</url>
<abstract>Given a sequence of positive weights, W=w 1≧...≧w n >0, there is a Huffman tree, T↑ (“T-up”) which minimizes the following functions: max{d(wi)}; Σd(wi); Σf(d(wi)) w i(here d(w i) represents the distance of a leaf of weight w i to the root and f is a function defined for nonnegative integers having the property that g(x) = f(x + 1) − f(x) is monotone increasing) over the set of all trees for W having minimal expected length. Minimizing the first two functions was first done by Schwartz [5]. In the case of codes where W is a sequence of probabilities, this implies that the codes based on T↑ have all their absolute central moments minimal. In particular, they are the least variance codes which were also described by Kou [3]. Furthermore, there exists a Huffman tree T↓, (“T-down”) which maximizes the functions considered above.However, if g(x) is monotone decreasing, T↑ and T↓, respectively maximize and minimize Σf(d(wi) w i) over the set of all trees for W having minimal expected length. In addition, we derive a number of interesting results about the distribution of labels within Huffman trees. By suitable modifications of the usual Huffman tree construction, (see [1]) T↑ and T↓ can also be constructed in time O(n log n).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289311</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Stadel81">
<author>Manfred P. Stadel</author>
<title>Behandlung verschiedener INTEGER-Darstellungen durch optimierende Compiler.</title>
<pages>45-56</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Stadel81</url>
<abstract>This paper describes a method for supporting different internal representations of INTEGER values by compilers for modern high level programming languages. Such programming languages usually do not offer different INTEGER types. They rather provide facilities to declare subranges of INTEGER. A compiler for such a language should process this information to choose the optimal internal representation for INTEGER values. However for arithmetic expressions the different machine operations must be chosen carefully to protect the running program from illegal arithmetic overflow.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289589</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Watt77"> 
<author>David A. Watt</author>
<title>The Parsing Problem for Affix Grammars.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>1-20</pages>
<url>db/journals/acta/acta8.html#Watt77</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276181</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/AmerinsBW93">
<author>Paul S. Amerins</author>
<author>Ricardo A. Baeza-Yates</author>
<author>Derick Wood</author>
<title>On Efficient Entreeings.</title>
<pages>203-213</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#AmerinsBW93</url>
<abstract>A data encoding is a formal model of how a logical data structure is mapped into or represented in a physical storage structure. Both structures are complete trees in this paper, and we encode the logical or guest tree in the leaves of the physical or host tree giving a restricted class of encodings called entreeings. The cost of an entreeing is the total amount that the edges of the guest tree are stretched or dilated when they are replaced by shortest paths in the host tree. We are particularly interested in the asymptotic average cost of families of similar entreeings.We refute a conjecture of Rosenberg et al. that a particular family of entreeings of binary guests into binary hosts is optimal.We provide an efficient family of entreeings fork-ary guests intok-ary hosts, fork≧2.We provide an efficient family of entreeings ofk-ary guests into binary hosts, fork≧3.We provide a new simple lower-bound technique that can be applied to the entreeings in part 2 to prove that they are very close to optimal. Moreover, it can be adapted for the entreeings of part 3, in which case we are able to show near optimality whenk is sufficiently large.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179370</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Mayr81">
<author>Ernst W. Mayr</author>
<title>Persistence of Vector Replacement Systems is Decidable.</title>
<pages>309-318</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Mayr81</url>
<abstract>In a persistent vector replacement system (VRS) or Petri net, an enabled transition can become disabled only by firing itself. Here, an algorithm is presented which allows to decide whether an arbitrary VRS is persistent or not, and if so, to construct a semilinear representation of the set of states reachable in the system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289268</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikD97">
<author>Karel Culik II</author>
<author>Simant Dube</author>
<title>Implementing Daubechies Wavelet Transform with Weighted Finite Automata.</title>
<pages>347-366</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta34.html#CulikD97</url>
<abstract>We show that the compactly supported wavelet functions \(W_2, W_4, W_6, \ldots\) discovered by Daubechies [6] can be computed by weighted finite automata (WFA) introduced by Culik and Karhumäki [2]. Furthermore, for 1-D case, a fixed WFA with \(2^n + n(N-2)\) states can implement any linear combination of dilations and translations of a basic wavelet \(W_N\) at resolution \(2^n\). The coefficients of the wavelet transform specify the initial weights in the corresponding states of the WFA. An algorithm to simplify this WFA is presented and can be employed to compress data. It works especially well for smooth and fractal-like data.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050089</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CremersH78a">
<author>Armin B. Cremers</author>
<author>Thomas N. Hibbard</author>
<title>Functional Behavior in Data Spaces.</title>
<pages>293-307</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#CremersH78a</url>
<abstract>In order to verify that a nondeterministic sequential program is partially correct it is sufficient to establish the conjunction of two constituent properties: “weak” partial correctness and functional, that is reproducible, behavior. It is possible to continue this divide-and-conquer strategy for the concept of functional behavior. If the nondeterministic sequential program is derived from a set of interacting parallel processes then the functional behavior of the former can be expressed in terms of two weaker complementary properties of the latter: weak functional behavior and input/output liveness. The only remaining issue is input/output dependability: the absence of input/output livelock. The theoretical framework of data spaces is used to derive closure theorems for these constituent properties. For instance, it is shown that a system of weakly functional processes is again weakly functional.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289044</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Mitchell88">
<author>William P. R. Mitchell</author>
<title>Inductive Completion with Retracts.</title>
<pages>497-514</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta25.html#Mitchell88</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00279951</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CousotC87">
<author>Patrick Cousot</author>
<author>Radhia Cousot</author>
<title>Sometime = Always + Recursion = Always on the Equivalence of the Intermittent and Invariant Assertions Methods for Proving Inevitability Properties of Programs.</title>
<pages>1-31</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#CousotC87</url>
<abstract>We propose and compare two induction principles called “always” and “sometime” for proving inevitability properties of programs. They are respective formalizations and generalizations of Floyd invariant assertions and Burstall intermittent assertions methods for proving total correctness of sequential programs whose methodological advantages or disadvantages have been discussed in a number of previous papers. Both principles are formalized in the abstract setting of arbitrary nondeterministic transition systems and illustrated by appropriate examples. The “sometime” method is interpreted as a recursive application of the “always” method. Hence “always” can be considered as a special case of “sometime”. These proof methods are strongly equivalent in the sense that a proof by one induction principle can be rewritten into a proof by the other one. The first two theorems of the paper show that an invariant for the “always” method can be translated into an invariant for the “sometime” method even if every recursive application of the later is required to be of finite length. The third and main theorem of the paper shows how to translate an invariant for the “sometime” method into an invariant for the “always” method. It is emphasized that this translation technique follows the idea of transforming recursive programs into iterative ones. Of course, a general translation technique does not imply that the original “sometime” invariant and the resulting “always” invariant are equally understandable. This is illustrated by an example.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290704</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MitraniH77"> 
<author>Isi Mitrani</author>
<author>J. H. Hine</author>
<title>Complete Parameterized Families of Job Scheduling Strategies.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>61-73</pages>
<url>db/journals/acta/acta8.html#MitraniH77</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276184</ee>
</article>

<article mdate="2008-08-08" key="journals/acta/MorrisT08">
<author>Joseph M. Morris</author>
<author>Malcolm Tyrrell</author>
<title>Modelling higher-order dual nondeterminacy.</title>
<pages>441-465</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We investigate models for programming and specifying in which higher-order functions and nondeterminacy (both demonic and angelic) coexist. The models are built using predicate transformers, binary multirelations, state transformers, and free lattices over a poset. We show there exist suitable models in each approach, and that they are isomorphic. The models support an algebra of nondeterminacy which we use to prove that the classical list fusion law holds even in the presence of nondeterminacy.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0076-1</ee>
<url>db/journals/acta/acta45.html#MorrisT08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nehmer75"> 
<author>J&uuml;rgen Nehmer</author>
<title>Dispatcher Primitives for the Construction of Operating System Kernels.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>237-255</pages>
<url>db/journals/acta/acta5.html#Nehmer75</url>
<abstract>The main subject of this paper is the definition of a general set of dispatcher primitives which have been proved to be a suitable basis for the structured design of operating system kernels. The use of the primitives in the construction of kernel programs is demonstrated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264560</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Savitch73"> 
<author>Walter J. Savitch</author>
<title>A Note on Multihead Automata and Context-Sensitive Languages</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>249-252</pages>
<url>db/journals/acta/acta2.html#Savitch73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Meinke94">
<author>Karl Meinke</author>
<title>A Recursive Second Order Initial Algebra Specification of Primitive Recursion.</title>
<pages>329-340</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta31.html#Meinke94</url>
<abstract>Theoretical results on the scope and limits of first order algebraic specifications can be used to show that certain natural algebras have no recursively enumerable equational specification under first order initial algebra semantics. A well known example is the algebraPℛ of primitive recursive functions over the natural numbers. In this paper we show thatPℛ has a recursive equational specification under second order initial algebra semantics. It follows that higher order initial algebra specifications are strictly more powerful than first order initial algebra specifications.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178510</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EngelfrietHL94">
<author>Joost Engelfriet</author>
<author>Linda Heyker</author>
<author>George Leih</author>
<title>Context-Free Graph Languages of Bounded Degree are Generated by Apex Graph Grammars.</title>
<pages>341-378</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta31.html#EngelfrietHL94</url>
<abstract>The apex graph grammars generate precisely the context-free graph languages of bounded degree, independently of whether one considers hyperedge replacement systems or (boundary or confluent) NLC or edNCE graph grammars. The main feature of apex graph grammars is that nodes cannot be “passed” from nonterminal to nonterminal. The proof is based on a normal form result for arbitrary hyperedge replacement systems that forbids “passing chains”. This generalizes Greibach Normal Form.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178511</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChowdhuryS87">
<author>Shyamal K. Chowdhury</author>
<author>Pradip K. Srimani</author>
<title>Worst Case Performance of Weighted Buddy Systems.</title>
<pages>555-564</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#ChowdhuryS87</url>
<abstract>In this paper we have studied the worst case performance of the weighted buddy system of memory management. Specifically we have derived lower bounds of two system parameters NETREQ and NETALLOC for a weighted buddy system in case of unrestricted request sequence and stated a few preliminary results for those parameters in case of allocation only request sequence. We have also given bounds for the same system parameters for exact-fit memory management algorithms to compare the results with those for buddy systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263294</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MontanariR95"> 
<author>Ugo Montanari</author>
<author>Francesca Rossi</author>
<title>Contextual Nets.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>6</number>
<year>1995</year> 
<pages>545-596</pages>
<url>db/journals/acta/acta32.html#MontanariR95</url>
<abstract>We propose a new kind of nets, called contextual nets, where events may have both preconditions and postconditions, as in the classical case, and also positive or negative context conditions. Positive context conditions are to be interpreted as elements which are needed for the event to occur, but which are not affected by the occurring of the event. Instead, negative context conditions are elements which must not be present for the event to take place.The importance of an explicit representation of positive context elements is twofold. Firstly, it allows a faithful representation of systems where the notion of “reading without consuming” is commonly used, like database systems, concurrent constraint programming, or any computation framework based on shared memory. Secondly, it allows to specify directly and naturally a level of concurrency greater than in classical nets. In fact, two events with different preconditions but with the same positive context may occur both in any order and also simultaneously. It is important to note that no other formalism for specifying distributed systems has such feature, not even Petri nets, where the “read” operation does not exists and it is instead modelled through a “rewrite” operation (i.e., a loop), which however does not allow the simultaneous execution of two tasks which read the same resource. Of course a context situation may be simulated in classical nets by creating as many copies of the context as are the users, but this would lead to a very unrealistic (and also more costly) description of the real situation. Negative context conditions are instead very natural to use in systems or languages where negation is present.In this paper we provide contextual nets with two process-based semantics which both are able to represent all and only the computations of a net and express the correct level of true-concurrency. Moreover, we show that contact situations, as well as negative context conditions, do not add any additional power, and we investigate the relationship between contextual nets and classical nets in terms of their processes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178907</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LauerTS79">
<author>Peter E. Lauer</author>
<author>Piero R. Torrigiani</author>
<author>M. W. Shields</author>
<title>COSY - A System Specification Language Based on Paths and Processes.</title>
<pages>109-158</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#LauerTS79</url>
<abstract>A new notation for specifying systems of concurrent processes sharing distributed systems of resources is introduced and the utility of the notation is demonstrated by defining novel, highly concurrent and distributed algorithms performing important operating system functions. The notation permits a clear and logical development of the algorithms from an analysis of its component notions; such as various buffer types, as well as non-priority and priority resource management strategies; without any reference to implementation detail. This property of the notation facilitates both the validation of the algorithms as well as their novel, highly concurrent and distributed implementation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00266047</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/Berghammer08">
<author>Rudolf Berghammer</author>
<title>Applying relation algebra and Rel View to solve problems on orders and lattices.</title>
<pages>211-236</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Relation algebra is well suited for dealing with many problems on ordered sets. Introducing lattices via order relations, this suggests to apply it and tools for its mechanization for lattice-theoretical problems, too. We combine relation algebra and the BDD-based specific purpose Computer Algebra system RelView to solve some algorithmic problems on orders and lattices and to visualize their solutions.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0072-5</ee>
<url>db/journals/acta/acta45.html#Berghammer08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Pager77">
<author>David Pager</author>
<title>Eliminating Unit Productions from LR Parsers.</title>
<pages>31-59</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Pager77</url>
<abstract>In this paper we show how one can improve upon an algorithm by Aho and Ullman [3] for eliminating unit productions from an LR(k) parser so that the elimination concerned can be made in all cases, instead of only in the special case required by [3] where no two unit productions have the same left-hand side. In most practical grammars this special case does not in fact arise. Since the elimination of unit productions both reduces the size of the parser and increases its speed, it is of value to have a general method for achieving this objective.The algorithm provided eliminates from the parser all nonterminals that occur as left-hand sides of unit productions. This substantially contributes to the reduction in size obtained, and also provides a solution to an open problem by Aho and Ullman [3]. An application of the Algorithm to the parser construction method of Pager [19] is considered, and a method is provided for the use of default reductions and the elimination of final states in conjunction with the elimination of unit reductions. The sizes of the parsers obtained using the parser's algorithm are compared with those of Anderson, Eve, and Horning [4].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263764</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LippsMOW88">
<author>Peter Lipps</author>
<author>Ulrich M&ouml;ncke</author>
<author>Matthias Olk</author>
<author>Reinhard Wilhelm</author>
<title>Attribute (Re)evaluation in OPTRAN.</title>
<pages>213-239</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#LippsMOW88</url>
<abstract>A transformation of a tree decorated according to some attribute grammar may leave the tree containing attribute inconsistencies. An attribute reevaluation algorithm computes new attribute values for affected attribute instances. It has to guarantee, that never an inconsistent attribute value is accessed. Reps' algorithm performs this task in time, O(¦affected region¦). It is data driven as changed values trigger recomputations of attribute instances dependent on them. After each transformation, a complete update of the effected instances is performed. Reps' algorithm is compared with the data driven reevaluation scheme used in OPTRAN. It uses the same strategic information in the initial attribute evaluation and the reevaluation process. Furthermore, we present a demand driven scheme for attribute reevaluation. It does not have the linear time complexity for each update after one transformation but, depending on the situation, often compares favourably with the data driven scheme for series of transformations. In addition, the linear time complexity of the data driven reevaluation algorithm needs fast convergence using an equality test between old and new attribute values. It is thus necessary, to keep the attribute values at (almost) all instances. The demand driven reevaluator does not need all the old attribute values. It can flexibly trade time for space. We also describe the handling of space consuming attributes, e.g. tables, lists and trees, in the reevaluation algorithm. An integrated version of data driven and demand driven reevaluation using these features has been implemented in the OPTRAN system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299633</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RajasekaranS92">
<author>Sanguthevar Rajasekaran</author>
<author>Sandeep Sen</author>
<title>On Parallel Integer Sorting.</title>
<pages>1-15</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta29.html#RajasekaranS92</url>
<abstract>We present an optimal algorithm for sortingn integers in the range [1,n c ] (for any constantc) for the EREW PRAM model where the word length isn ε , for any ε>0. Using this algorithm, the best known upper bound for integer sorting on the (O(logn) word length) EREW PRAM model is improved. In addition, a novel parallel range reduction algorithm which results in a near optimal randomized integer sorting algorthm is presented. For the case when the keys are uniformly distributed integers in an arbitrary range, we give an algorithm whose expected running time is optimal.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178563</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HullS94">
<author>Richard Hull</author>
<author>Jianwen Su</author>
<title>Domain Independence and the Relational Calculus.</title>
<pages>513-524</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#HullS94</url>
<abstract>Several alternative semantics (or interpretations) of the relational (domain) calculus are studied here. It is shown that they all have the same expressive power, i.e., the selection of any of the semantics neither gains nor loses expressive power.Since the domain is potentially infinite, the answer to a relational calculus query is sometimes infinite (and hence not a relation). The following approaches which guarantee the finiteness of answers to queries are studied here:output-restricted unlimited interpretation, domain independent queries, output-restricted finite andcountable invention, andlimited interpretation. Of particular interest is the output-restricted unlimited interpretation—although the output is restricted to the active domain of the input and query, the quantified variables range over the infinite underlying domain. While this is close to the intuitive interpretation given to calculus formulas, the naive approach to evaluating queries under this semantics calls for the impossible task of examining infinitely many values. We describe here a constructiion which, given a queryQ under the output-restricted unlimited interpretation, yields a domain independent queryQ′, with length no more than exponential in the length ofQ, such thatQ andQ′ (under their respective semantics) express the same function.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213204</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeeF96">
<author>John K. Lee</author>
<author>Alan Fekete</author>
<title>Multi-Granularity Locking for Nested Transactions: A Proof Using a Possibilities Mapping.</title>
<pages>131-152</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta33.html#LeeF96</url>
<abstract>The choice of granularity for locking items in a database involves performance trade-offs. In order to provide a choice between different locking granularities within a single system, the two-phase locking algorithm needs to be modified to include intention locks. This paper extends the well-known multigranularity locking algorithm of Gray et al. to deal with nested transactions, and verifies the correctness of the extended algorithm, using a possibilities mapping to abstract commutativity-based locking.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050038</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Laurinolli78">
<author>Teuvo Laurinolli</author>
<title>Bounded Quantification and Relations Recognizable by Finite Automata.</title>
<pages>67-78</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Laurinolli78</url>
<abstract>The concept of inverse well-known for homomorphisms and gsm-mappings is extended to any language operation. The class IRP of language operations whose inverse preserves regularity is considered. As an application a necessary and sufficient condition is established for the class of relations recognizable by finite automata to be closed under different versions of bounded quantification.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260924</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/LeavensP00">
<author>Gary T. Leavens</author>
<author>Don Pigozzi</author>
<title>A Complete Algebraic Characterization of Behavioral Subtyping.</title>
<pages>617-663</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036008/00360617.htm</ee>
<url>db/journals/acta/acta36.html#LeavensP00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LiangC97">
<author>Y. Daniel Liang</author>
<author>Maw-Shang Chang</author>
<title>Minimum Feedback Vertex Sets in Cocomparability Graphs and Convex Bipartite Graphs.</title>
<pages>337-346</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta34.html#LiangC97</url>
<abstract>Polynomial-time algorithms for the feedback vertex set problem in cocomparability graphs and convex bipartite graphs are presented.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050088</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BernotBK94">
<author>Gilles Bernot</author>
<author>Michel Bidoit</author>
<author>Teodor Knapik</author>
<title>Behavioural Approaches to Algebraic Specifications: A Comparative Study.</title>
<pages>651-671</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta31.html#BernotBK94</url>
<abstract>This paper focuses on observability issues in the framework of loose algebraic specifications. The main purpose of observability is to extend the model class of some given algebraic specification in order to consider not only the algebras that satisfy the axioms of the specification in order to consider not only the algebras that satisfy the axioms of the specification, but as well other ones, provided that the differences between the properties satisfied by these algebras and the properties required by the specification (i.e., the axioms) are not “observable”. We compare various behavioural approaches developed so far. We point out their respective advantages and limitations. Expressive power is our main criterion for the discussion.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177550</ee>
</article>
<article mdate="2012-04-26" key="journals/acta/BergstraM12">
<author>Jan A. Bergstra</author>
<author>C. A. Middelburg</author>
<title>Instruction sequence processing operators.</title>
<pages>139-172</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Instruction sequence is a key concept in practice, but it has as yet not come prominently into the picture in theoretical circles. This paper concerns instruction sequences, the behaviours produced by them under execution, the interaction between these behaviours and components of the execution environment, and two issues relating to computability theory. Positioning Turing’s result regarding the undecidability of the halting problem as a result about programs rather than machines, and taking instruction sequences as programs, we analyse the autosolvability requirement that a program of a certain kind must solve the halting problem for all programs of that kind. We present novel results concerning this autosolvability requirement. The analysis is streamlined by using the notion of a functional unit, which is an abstract state-based model of a machine. In the case where the behaviours exhibited by a component of an execution environment can be viewed as the behaviours of a machine in its different states, the behaviours concerned are completely determined by a functional unit. The above-mentioned analysis involves functional units whose possible states represent the possible contents of the tapes of Turing machines with a particular tape alphabet. We also investigate functional units whose possible states are the natural numbers. This investigation yields a novel computability result, viz. the existence of a universal computable functional unit for natural numbers.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0154-2</ee>
<url>db/journals/acta/acta49.html#BergstraM12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Drabent95"> 
<author>Wlodzimierz Drabent</author>
<title>What is Failure? An Approach to Constructive Negation.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>1</number>
<year>1995</year> 
<pages>27-29</pages>
<url>db/journals/acta/acta32.html#Drabent95</url>
<abstract>A standard approach to negation in logic programming is negation as failure. Its major drawback is that it cannot produce answer substitutions to negated queries. Approaches to overcoming this limitation are termed constructive negation. This work proposes an approach based on construction offailed trees for some instances of a negated query. For this purpose a generalization of the standard notion of a failed tree is needed. We show that a straightforward generalization leads to unsoundness and present a correct one.The method is applicable to arbitrary normal programs. If finitely failed trees are concerned then its semantics is given by Clark completion in 3-valued logic (and our approach is a proper extension of SLDNF-resolution). If infinite failed trees are allowed then we obtain a method for the well-founded semantics. In both cases soundness and completeness are proved.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185404</ee>
</article>

<article mdate="2010-01-04" key="journals/acta/KhomenkoSVW09">
<author>Victor Khomenko</author>
<author>Mark Sch&auml;fer</author>
<author>Walter Vogler</author>
<author>Ralf Wollowski</author>
<title>STG decomposition strategies in combination with unfolding.</title>
<pages>433-474</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>For synthesising efficient asynchronous circuits one has to deal with the state space explosion problem. In order to alleviate this problem one can decompose the STG into smaller components. This paper deals with the decomposition method of Vogler and Wollowski and introduces several strategies for its efficient implementations. Furthermore, this approach is combined with another method to alleviate state space explosion, which is based on Petri net unfoldings. The developed algorithms are compared by means of benchmark examples, and the experimental results show significant improvement in terms of memory usage and runtime compared with other existing methods.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0102-y</ee>
<url>db/journals/acta/acta46.html#KhomenkoSVW09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FinkelB74"> 
<author>Raphael A. Finkel</author>
<author>Jon Louis Bentley</author>
<title>Quad Trees: A Data Structure for Retrieval on Composite Keys.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>1-9</pages>
<url>db/journals/acta/acta4.html#FinkelB74</url>
<abstract>The quad tree is a data structure appropriate for storing information to be retrieved on composite keys. We discuss the specific case of two-dimensional retrieval, although the structure is easily generalised to arbitrary dimensions. Algorithms are given both for staightforward insertion and for a type of balanced insertion into quad trees. Empirical analyses show that the average time for insertion is logarithmic with the tree size. An algorithm for retrieval within regions is presented along with data from empirical studies which imply that searching is reasonably efficient. We define an optimized tree and present an algorithm to accomplish optimization in n log n time. Searching is guaranteed to be fast in optimized trees. Remaining problems include those of deletion from quad trees and merging of quad trees, which seem to be inherently difficult operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288933</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Schmitt83">
<author>Alfred Schmitt</author>
<title>On the Number of Relational Operators Necessary to Compute Certain Functions of Real Variables.</title>
<pages>297-304</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Schmitt83</url>
<abstract>The famous result of N. Friedman that any sorting algorithm uses at least O(n log n) relational operations in the worst case, even if the real number operations +,−,*, / can be used without any time account, is extended and generalized. Our main theorem can be used to calculate lower bounds for computations of functions if the operations <,+,−,*,/ are allowed and only the relational operators are counted. Friedman's sorting result and several other lower bounds are covered by the theorem. One of the results is of special interest for future directions of research, since it is possible to compute the max function of n arguments in a restricted domain with O(log n) relational operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265560</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LabetoulleP76"> 
<author>Jacques Labetoulle</author>
<author>Guy Pujolle</author>
<title>A Study of Queueing Networks with Deterministic Service and Application to Computer Networks.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>183-195</pages>
<url>db/journals/acta/acta7.html#LabetoulleP76</url>
<abstract>We consider a packet-switching network as a queueing system with constant service times: that means that the lengths of the packets are equal. We study such a network by isolating a particular path which we treat as tandem queueing system. Two aspects will be examined: the study of the response time of such a system, and the throughput of such a system when time-outs are used to destroy packets. The results we obtain show that when the interference between paths is neglected the response time is independent of the order of the stations. The control policy we examine proves the necessity to have a limitated memory capacity at each node of a packet-switching network. These results confirm the intuitive options taken in a network like CYCLADES.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265770</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Pritchard82">
<author>Paul Pritchard</author>
<title>Explaining the Wheel Sieve.</title>
<pages>477-485</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Pritchard82</url>
<abstract>In a previous paper, an algorithm was presented for the classical problem of finding all prime numbers up to a given limit. The algorithm was derived therein by transforming a prior algorithm in accordance with some essentially ad hoc observations on the problem.The present paper complements the former by developing a simple mathematical framework, which leads to a smoother and more insightful derivation of the new algorithm, and which may be of independent interest to the number theorist.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264164</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Moenck76">
<author>Robert T. Moenck</author>
<title>Another Polynomial Homomorphism.</title>
<pages>153-169</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Moenck76</url>
<abstract>The current proposals for applying the so called “fast” O(N loga N) algorithms to multivariate polynomials is that the univariate methods be applied recursively, much in the way more conventional algorithms are used. Since the size of the problems is rather large for which a “fastrd algorithm is more efficient than a classical one, the recursive approach compounds this size completely out of any practical range”.The degree homomorphism is proposed here as an alternative to this recursive approach. It is argued that methods based on the degree homomorphism and a “fast” algorithm may be viable alternatives to more conventional algorithms for certain multivariate problems in the setting of algebraic manipulation. Several such problems are discussed including: polynomial multiplication, powering, division (both exact and with remainder), greatest common divisors and factoring.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268498</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Heidelberger80">
<author>Philip Heidelberger</author>
<title>Variance Reduction Techniques for the Simulation of Markov Process.</title>
<pages>21-37</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Heidelberger80</url>
<abstract>Let X n, n≧0 be an irreducible, aperiodic, Markov chain with finite state space E, transition matrix P, and stationary distribution π. Let f be a real valued function on E and define r = πf. A method of reducing the variance of simulation estimates for r is presented. The method combines the techniques of numerical analysis and simulation by partially solving an appropriate system of linear equations using some matrix iterative procedure and then estimating the difference between the true and partial solutions via simulation. After k iterations of the iterative procedure, functions f ν ν = 0, ..., k are defined so that r = πf gn for each ν. Let \(\hat x_v (N) = \sum\limits_{n = 0}^N {f_v (x_n )/(N + 1)} \) and \(\hat x_\beta (N) = \sum\limits_{v = 0}^k {\beta (v)\hat x_v (N)} \) where \(\sum\limits_{v = 0}^k {\beta (v) = 1} \). Then \(\hat x_\beta (N) \to r\) a.s. as N → ∞ and β is chosen to minimize the asymptotic variance of \(\hat x_\beta (N)\). Numerical results for a simple queueing model are presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288533</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bublitz86">
<author>Siegfried Bublitz</author>
<title>Decomposition of Graphs and Monotone Formula Size of Homogeneous Functions.</title>
<pages>689-696</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#Bublitz86</url>
<abstract>We show that every graph on n nodes can be partitioned by a number of complete bipartite graphs with O(n 2/log n) nodes with no edge belonging to two of them. Since each partition corresponds directly to a monotone formula for the associated quadratic function we obtain an upper bound for the monotone formula size of quadratic functions. Our method extends to uniform hypergraphs with fixed range and thus to homogeneous functions with fixed length of prime implicants. Finally we give an example of a quadratic function where each monotone formula built from arbitrary partitions of the graph (double edges allowed) is not optimal. That means we disprove the single-level-conjecture for formulae.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264314</ee>
</article>
<article mdate="2013-06-06" key="journals/acta/NagyO13">
<author>Benedek Nagy</author>
<author>Friedrich Otto</author>
<title>Deterministic pushdown-CD-systems of stateless deterministic R(1)-automata.</title>
<pages>229-255</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Recently the one-counter trace languages and the context-free trace languages have been characterized through restricted types of cooperating distributed systems (CD-systems) of stateless deterministic restarting automata with window size one (so-called stl-det-R(1)-automata) that work in mode ‘=1’ and that use an external counter or pushdown store to determine the successor components within computations. Here we study the deterministic variants of these CD-systems, comparing the resulting language classes to the classes of languages defined by CD-systems of stl-det-R(1)-automata without such an external device and to some classical language families, among them in particular the classes of rational, one-counter, and context-free trace languages. In addition, we present a large number of (non-)closure properties for our language classes.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0175-x</ee>
<url>db/journals/acta/acta50.html#NagyO13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Paun93">
<author>Gheorghe Paun</author>
<title>On the Synchronization in Parallel Communicating Grammar Systems.</title>
<pages>351-367</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta30.html#Paun93</url>
<abstract>We investigate the power of various types of synchronization in parallel communicating grammar systems. Systems without a universal clock (a pumping lemma is given for this case) proves in general to be weaker than the synchronized systems. Further synchronizing restrictions are introduced (added to the basic synchronization by a universal clock and their effect on the generative capacity of grammar systems is examined.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209710</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schuler74"> 
<author>P. F. Schuler</author>
<title>Weakly Context-Sensitive Languages as Model for Programming Languages.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>155-170</pages>
<url>db/journals/acta/acta3.html#Schuler74</url>
<abstract>An abstract family of formal languages containing context-free languages and properly contained in (deterministic) context-sensitive languages is introduced. This family is comprehensive enough to contain e.g. Algol 60 without admitting too complex recursive constructions possible in the frame of general context-sensitive languages.This family is essentially a family of property-languages, whereby the considered properties are restricted to properties which are constructively definable from a finite number of context-free sets.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264035</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Ernst77"> 
<author>George W. Ernst</author>
<title>Rules of Inference for Procedure Calls.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>145-152</pages>
<url>db/journals/acta/acta8.html#Ernst77</url>
<abstract>actual variable parameters to occur in actual value parameters;the body of a procedure to contain global variables that do not occur in assignment positions;post-conditions and “internal” assertions of a procedure to refer to the initial values of variable parameters.None of these are allowed in Hoare's system or the system of Igarashi, London and Luckham. An attractive feature of these extensions is that they do not increase the complexity of the rules of inference.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289246</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Pfaff83">
<author>G&uuml;nther E. Pfaff</author>
<title>The Construction of Operator Interfaces Based on Logical Input Devices.</title>
<pages>151-166</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Pfaff83</url>
<abstract>Graphics standards today operate with abstract logical functions in order to provide application portability. Beside the logical interface, also the physical interface to operators is of significance for interactive systems since physical device characteristics determine the suitability of a system for given interactive applications. Based on the GKS input model, this report shows how to provide logical input devices to a dialogue component on the one hand, and, on the other hand, how to map them to the physical interface in controlled and flexible ways.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264473</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EngelfrietV88">
<author>Joost Engelfriet</author>
<author>Heiko Vogler</author>
<title>High Level Tree Transducers and Iterated Pushdown Tree Transducers.</title>
<pages>131-192</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#EngelfrietV88</url>
<abstract>n-level tree transducers (n≧0) combine the features ofn-level tree grammars and of top-down tree transducers in the sense that the derivations of the tree grammars are syntax-directed by input trees. For runningn, the sequence ofn-level tree transducers starts with top-down tree transducers (n=0) and macro tree transducers (n=1). In this paper the class of tree-to-tree translations computed byn-level tree transducers is characterized byn-iterated pushdown tree transducers. Such a transducer can be considered as a regular tree grammar of which the derivations are syntax-directed byn-iterated pushdowns of trees; ann-iterated pushdown of trees is a pushdown of pushdowns of ... of pushdowns (n times) of trees. In particular, we investigate the total deterministic case, which is relevant for syntax-directed semantics of programming languages.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915449</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Reisch80">
<author>Stefan Reisch</author>
<title>Gobang ist PSPACE-vollst&auml;ndig.</title>
<pages>59-66</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Reisch80</url>
<abstract>For many games, the decision problem of whether a player in a given situation has a winning strategy has been shown to be PSPACE-complete. Following the PSPACE-completeness results of Even and Tarjan [1] for generalized Hex on graphs and of Schaefer [6] for a variety of combinatorial games, the decision problems were shown to be PSPACE-hard for generalizations of Go and Checkers. In this paper a corresponding theorem is proved for the board-game Gobang, a variant of Go. Since the decision problem for Gobang states-of-play itself lies in PSPACE, it can be shown that Gobang is in fact PSPACE-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288536</ee>
</article>
<article mdate="2010-10-24" key="journals/acta/FanHSC10">
<author>Chen-Ming Fan</author>
<author>Cheng-Chih Huang</author>
<author>Huei-Jan Shyr</author>
<author>Kuo-Hsiang Chen</author>
<title>A note on autodense related languages.</title>
<pages>209-219</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>In this paper, some algebraic properties of autodense languages and pure autodense languages are studied. We also investigate the algebraic properties concerning anti-autodense languages. The family of anti-autodense languages contains infix codes, comma-free codes, and some subfamilies of new codes which are anti-autodense prefix codes, anti-autodense suffix codes and anti-autodense codes. The relationships among these subfamilies of new codes are investigated. The characterization of L n , n ≥ 2, which are anti-autodense is studied.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0116-5</ee>
<url>db/journals/acta/acta47.html#FanHSC10</url>
</article>
<article mdate="2006-11-22" key="journals/acta/PanA06">
<author>Linqiang Pan</author>
<author>Artiom Alhazov</author>
<title>Solving HPP and SAT by P Systems with Active Membranes and Separation Rules.</title>
<pages>131-145</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>The P systems (or membrane systems) are a class of distributed parallel computing devices of a biochemical type, where membrane division is the frequently investigated way for obtaining an exponential working space in a linear time, and on this basis solving hard problems, typically NP-complete problems, in polynomial (often, linear) time. In this paper, using another way to obtain exponential working space – membrane separation, it was shown that Satisfiability Problem and Hamiltonian Path Problem can be deterministically solved in linear or polynomial time by a uniform family of P systems with separation rules, where separation rules are not changing labels, but polarizations are used. Some related open problems are mentioned.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0018-8</ee>
<url>db/journals/acta/acta43.html#PanA06</url>
</article>
<article mdate="2015-05-21" key="journals/acta/KumarM96">
<author>Akhil Kumar 0001</author>
<author>Kavindra Malik</author>
<title>Optimizing the Costs of Hierarchical Quorum Consensus.</title>
<pages>255-275</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta33.html#KumarM96</url>
<abstract>We study the problem of how to minimize the cost of maintaining consistency among at least N copies of an object in an enviroment where the mix of read and write operations can vary. Quorum consensus requires that read and write operations must assemble appropriate quorums before an operation can succeed. The cost of an operation is proportional to the size of a quorum, and the objective is obviously to minimize the cost while still maintaining consistency. It is known that the quorum size can be reduced by organizing a number of copies into logical structures such as grids and hierarchies. In this paper, we show (a) how methods based on grids and hierarchies can be treated in a common framework, and (b) how these hierarchies can be optimized so as to minimize the cost of consensus. Of course, the optimal solution depends upon the mix of read and write operations that is present. Consequently, given N copies of an object and a ratio of write operations F, our algorithms determine the optimal values for the number of levels in the hierarchy and the read/write quorum sizes at each level. The algorithms, which run in O(N 1.63) and O(N 2) time, were tested, and the results are reported and discussed.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050043</ee>
</article>
<article mdate="2008-01-15" key="journals/acta/HaddadP07">
<author>Serge Haddad</author>
<author>Denis Poitrenaud</author>
<title>Recursive Petri nets.</title>
<pages>463-508</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>In order to design and analyse complex systems, modelers need formal models with two contradictory requirements: a high expressivity and the decidability of behavioural property checking. Here we present and develop the theory of such a model, the recursive Petri nets. First, we show that the mechanisms supported by recursive Petri nets enable to model patterns of discrete event systems related to the dynamic structure of processes. Furthermore, we prove that these patterns cannot be modelled by ordinary Petri nets. Then we study the decidability of some problems: reachability, finiteness and bisimulation. At last, we develop the concept of linear invariants for this kind of nets and we design efficient computations specifically tailored to take advantage of their structure.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0055-y</ee>
<url>db/journals/acta/acta44.html#HaddadP07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/GaverH76"> 
<author>Donald P. Gaver</author>
<author>George Humfeld</author>
<title>Multitype Multiprogramming Models.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>111-121</pages>
<url>db/journals/acta/acta7.html#GaverH76</url>
<abstract>We have presented models for multitype job traffic in a simple cyclic queueing model of a multiprogramming computer system (termed MM models), and have shown how such models may yield numerical results by use of a variation of the Gauss-Seidel iteration algorithm. Lastly, we have indicated the manner in which a simple Gordon and Newell Markov model be fitted to MM data, and have shown that satisfactory predictions of some system characteristics may be obtained thereby.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265765</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Levy74"> 
<author>J.-P. L&eacute;vy</author>
<title>Automatic Correction of Syntax-Errors in Programming Languages.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>271-292</pages>
<url>db/journals/acta/acta4.html#Levy74</url>
<abstract>A formal model for automatic error-correction is presented. It considers clusters of errors, using a local context to determine the corrections. The process can be embedded in left-to-right recognizers. The recognizer is used for standard syntax checking. When an error is detected, an error correction mechanism is activated which, by a limited backward then forward move, determines the possible corrections. An important aspect of this process is that it does not slow down the parsing of correct programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288730</ee>
</article>

<article mdate="2006-11-22" key="journals/acta/KonstantinidisSY07">
<author>Stavros Konstantinidis</author>
<author>Nicolae Santean</author>
<author>Sheng Yu</author>
<title>Representation and uniformization of algebraic transductions.</title>
<pages>395-417</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>This paper explores different means of representation for algebraic transductions, i.e., word relations realized by pushdown transducers. The relevance of this work lies more in its point of view rather than any particular result. We are aiming at giving specific techniques for obtaining, or perhaps explaining, decompositions of algebraic (and incidentally, rational) relations, relying solely on their “machine” definition rather than some complex algebraic apparatus. From this point of view, we are hoping to have demystified the heavy formalism employed in the present literature. Some of the novelties of our work are: the use of “stack languages” and “embeddings,” which eliminate the need of arbitrary context-free languages in our characterizations, the study of uniformizations for algebraic transductions and the use of the so-called stack transductions for exposing the anatomy of pushdown transducers.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0027-7</ee>
<url>db/journals/acta/acta43.html#KonstantinidisSY07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BestDKP91">
<author>Eike Best</author>
<author>Raymond R. Devillers</author>
<author>Astrid Kiehn</author>
<author>Lucia Pomello</author>
<title>Concurrent Bisimulations in Petri Nets.</title>
<pages>231-264</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta28.html#BestDKP91</url>
<abstract>After various attempts, an equivalence relation is defined for labelled Petri nets, on the base of the concurrency semantics of net theory. This relation, called Fully Concurrent bisimulation and abbreviated FC-bisimulation, preserves the level of concurrency of visible operations and, under some conditions, allows to enforce injective labelling on them. Refinements of a visible operation are also defined and we show that, under some conditions, they preserve FC-bisimulation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178506</ee>
</article>
<article mdate="2005-12-14" key="journals/acta/Buttner05">
<author>Markus B&uuml;ttner</author>
<title>Enhanced prefetching and caching strategies for single- and multi-disk systems.</title>
<pages>21-42</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We study integrated offline caching and prefetching algorithms both in the single- and the multi-disk case. For the problem of minimizing the execution time of a given request sequence, we present simple algorithms. In the single-disk case we present a combinatorial algorithm with an approximation ratio of 3/2. An optimal solution can be computed using a linear program but this requires a very large number of variables. Our new result improves on all previous combinatorial approximation algorithms. For the multi-disk case we give combinatorial 2-approximation algorithms. Additionally, we consider this problem in the resource augmentation model where the approximation algorithms may use more cache lines than the optimal solution they are compared to. Here, we give strategies using one additional cache line per disk that outperform the optimum solution without additional cache in the single-disk case and achieve (1+o(1))-approximations in the multi-disk case. In contrast to some of the previous approaches, all the algorithms we present are combinatorial and easy to implement.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0170-6</ee>
<url>db/journals/acta/acta42.html#Buttner05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtHR88">
<author>Andrzej Ehrenfeucht</author>
<author>Hendrik Jan Hoogeboom</author>
<author>Grzegorz Rozenberg</author>
<title>Recording the Use of Memory in Right-Boundary Grammars and Push-Down Automata.</title>
<pages>203-231</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta25.html#EhrenfeuchtHR88</url>
<abstract>Within the framework of coordinated pair systems a push-down automaton A is formalized as an ordered pair (G 1, G 2) of grammars, where G 1 is a right-linear grammar modelling the finite state control of A and the reading of the input of A, and G 2 is a right-boundary grammar modelling the push-down store of A. In this paper we present a systematic investigation into the use of memory of right-boundary grammars. Various methods of recording the use of memory are introduced. The results presented concern regularity properties of each of the methods and the interrelationships of the records obtained by different methods. Finally the translation of these results to the level of push-down automata (coordinated pair systems) is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263585</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/BestD15a">
<author>Eike Best</author>
<author>Raymond R. Devillers</author>
<title>State space axioms for T-systems.</title>
<pages>133-152</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>T-systems are generalisations of marked graph Petri nets. This paper describes synthesis algorithms that allow bounded or unbounded T-systems to be derived from finite or infinite labelled transition systems satisfying a set of necessary properties. These properties can thus be interpreted as axioms characterising T-system state spaces.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0219-0</ee>
<url>db/journals/acta/acta52.html#BestD15a</url>
</article>
<article mdate="2010-01-04" key="journals/acta/EngelfrietLM09">
<author>Joost Engelfriet</author>
<author>Eric Lilin</author>
<author>Andreas Maletti</author>
<title>Extended multi bottom-up tree transducers.</title>
<pages>561-590</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>Extended multi bottom–up tree transducers are defined and investigated. They are an extension of multi bottom–up tree transducers by arbitrary, not just shallow, left-hand sides of rules; this includes rules that do not consume input. It is shown that such transducers, even linear ones, can compute all transformations that are computed by linear extended top–down tree transducers, which are a theoretical model for syntax-based machine translation. Moreover, the classical composition results for bottom–up tree transducers are generalized to extended multi bottom–up tree transducers. Finally, characterizations in terms of extended top–down tree transducers and tree bimorphisms are presented.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0105-8</ee>
<url>db/journals/acta/acta46.html#EngelfrietLM09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Blikle81">
<author>Andrzej Blikle</author>
<title>The Clean Termination of Iterative Programs.</title>
<pages>199-217</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Blikle81</url>
<abstract>The paper is devoted to a program-correctness concept which captures partial correctness, termination (nonlooping) and clean termination (nonabortion). The underlying proof method offers a one-stage proof of all the three properties. This method is proved consistent and algebraically complete. It is first discussed for the general case of arbitrary possibly nondeterministic iterative programs. Next, this case is restricted to arbitrary deterministic iterative programs and finally to structured programs. The presented approach is compared with partial correctness, total correctness and weakest precondition methods. The concluding example shows the verification of an arithmetical program in machine-bounded arithmetics. As a side effect of the verification procedure one finds input boundary conditions which guarantee clean termination.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261259</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kroger80">
<author>Fred Kr&ouml;ger</author>
<title>Infinite Proof Rules for Loops.</title>
<pages>371-389</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Kroger80</url>
<abstract>Classical proof rules for loop constructions, formalizing the method of inductive assertions are based on the fundamental concept of loop invariants. A certain incompleteness of such rules indicates some inherent gap between partial correctness of loop programs and its provability by strongly formal proof rules. Introducing the concept of infinite proof rules (i.e. rules with infinitely many premises) for loops, this paper is devoted to get some insight into this gap. Such rules provide proof-theoretical completeness and — relevant for practice — a general framework in which the invariant method is contained as a special case essentially corresponding to some “direct” mathematical induction over the infinitely many premises, but which opens also the view for other proof methods. As an example, a method of generalized invariants is described within this formal setting. As illustrated by examples, for certain programs generalized invariants may be “simpler” than classical invariants.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286493</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/EsikB98">
<author>Zolt&aacute;n &Eacute;sik</author>
<author>Michael Bertol</author>
<title>Nonfinite Axiomatizability of the Equational Theory of Shuffle.</title>
<pages>505-539</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta35.html#EsikB98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035006/80350505.htm</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/SteeP01">
<author>Rob van Stee</author>
<author>Johannes A. La Poutr&eacute;</author>
<title>Running a job on a collection of partly available machines, with on-line restarts.</title>
<pages>727-742</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037010/10370727.htm</ee>
<url>db/journals/acta/acta37.html#SteeP01</url>
</article>
<article mdate="2015-01-08" key="journals/acta/MorganG89">
<author>Carroll Morgan</author>
<author>Paul H. B. Gardiner</author>
<title>Data Refinement by Calculation.</title>
<pages>481-503</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta27.html#MorganG89</url>
<abstract>Data refinement is the systematic substitution of one data type for another in a program. Usually, the new data type is more efficient than the old, but possibly more complex; the purpose of the data refinement in that case is to make progress in program construction from more abstract to more concrete formulations. A recent trend in program construction is to calculate programs from their specifications; that contrasts with proving that a given program satisfies some specification. We investigate to what extent the trend can be applied to data refinement.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00277386</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Singh93">
<author>Ambuj K. Singh</author>
<title>Program Refinement in Fair Transition Systems.</title>
<pages>503-535</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta30.html#Singh93</url>
<abstract>Refinement of programs is investigated in the context of fair transition systems. Two kinds of refinements, property preserving and fixed-point preserving, are defined. Conditions are developed under which common program transformations such as data refinement are property preserving and fixed-point preserving. These conditions and relevant program refinements are illustrated through a number of examples.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209623</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CaspiH86">
<author>Paul Caspi</author>
<author>Nicolas Halbwachs</author>
<title>A Functional Model for Describing and Reasoning About Time Behaviour of Computing Systems.</title>
<pages>595-627</pages>
<year>1986</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta22.html#CaspiH86</url>
<abstract>We present a mathematical model of parallel and real time systems behaviour, suitable for problem specification, and for implementation description, analysis and proof. On one hand, this model allows a pure behavioural description mode, and on the other hand it takes into account a metric notion of time. A system is considered as a history transformer, and the history of a variable consists of the sequence of values assigned to it, together with the sequence of times when these assignments take place. A set of tools is proposed, in order to describe such histories, and to perform proofs about them. This model is illustrated by the specification, the description and the proof of a distributed bus arbiter.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263648</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BestFHKP98">
<author>Eike Best</author>
<author>Wojciech Fraczak</author>
<author>Richard P. Hopkins</author>
<author>Hanna Klaudel</author>
<author>Elisabeth Pelz</author>
<title>M-Nets: An Algebra of High-Level Petri Nets, with an Application to the Semantics of Concurrent Programming Languages.</title>
<pages>813-857</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035010/80350813.htm</ee>
<url>db/journals/acta/acta35.html#BestFHKP98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Yang95"> 
<author>Wuu Yang</author>
<title>On the Look-Ahead Problem in Lexical Analysis.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>5</number>
<year>1995</year> 
<pages>459-476</pages>
<url>db/journals/acta/acta32.html#Yang95</url>
<abstract>Modern programming languages use regular expressions to define valid tokens. Traditional lexical analyzers based on minimum deterministic finite automata for regular expressions cannot handle the look-ahead problem. The scanner writer needs to explicitly identify the look-ahead states and code the buffering and re-scanning operations by hand. We identify the class of finite look-ahead finite automata, which is general enough to include all finite automata of practical lexical analyzers. Finite look-ahead finite automata are then transformed into suffix finite automata. A new lexical analyzer makes use of the suffix finite automata to identify tokens. The new lexical analyzer solves the look-ahead problem in a table-driven approach and it can detect lexical errors at an earlier time than traditional lexical analyzers. The extra cost of the new lexical analyzers is the larger state transition table and three additional 1-dimensional tables. Incremental lexical analysis is also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213079</ee>
</article>

<article mdate="2009-09-28" key="journals/acta/KlonowskaLL09">
<author>Kamilla Klonowska</author>
<author>Lars Lundberg</author>
<author>H&aring;kan Lennerstad</author>
<title>The maximum gain of increasing the number of preemptions in multiprocessor scheduling.</title>
<pages>285-295</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>We consider the optimal makespan C(P, m, i) of an arbitrary set P of independent jobs scheduled with i preemptions on a multiprocessor with m identical processors. We compare the ratio for such makespans for i and j preemptions, respectively, where i < j. This ratio depends on P, but we are interested in the P that maximizes this ratio, i.e. we calculate a formula for the worst case ratio G(m, i, j) defined as \({G(m,i,j)=\max \frac{C(P,m,i)}{C(P,m,j)},}\) where the maximum is taken over all sets P of independent jobs.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0096-5</ee>
<url>db/journals/acta/acta46.html#KlonowskaLL09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Rosenberg78">
<author>Arnold L. Rosenberg</author>
<title>Data Encodings and Their Costs.</title>
<pages>273-292</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Rosenberg78</url>
<abstract>This paper is devoted to developing and studying a precise notion of the “encoding” of a “logical data structure” in a “physical storage structure,” that is motivated by considerations of computational efficiency. The development builds upon the notion of an encoding of one graph in another. The cost of such an encoding is then defined so as to reflect the structural compatibility of the two graphs, the (externally specified) costs of “implementing” the host graph, and the (externally specified) set of intended “usage patterns” of the guest graph. The stability of the constructed framework is demonstrated in terms of a number of results; the faithfulness of the formalism is argued in terms of a number of examples from the literature; and the tractability of the model is hinted at by several results and by further references to the literature.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288886</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Galil76">
<author>Zvi Galil</author>
<title>Hierarchies of Complete Problems.</title>
<pages>77-88</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Galil76</url>
<abstract>An attempt is made to present a framework for the diverse complete problems that have been found. A new concept—a Hierarchy of Complete Problems is defined. Several hierarchies in various domains such as graph theory, automata theory, theorem proving and games are established.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263744</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Claus71"> 
<author>Volker Claus</author>
<title>Ein Vollst&auml;ndigkeitssatz f&uuml;r Programme und Schaltkreise.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>64-78</pages>
<url>db/journals/acta/acta1.html#Claus71</url>
<abstract>Formal transformations of programs or switching circuits can be described by a system of relations within the concept of free X-categories. In this theory the programs or switching circuits are the morphisms of the free X-category. A finite relation system is given which is correct and complete (in an analogous sense to the notions of the predicate calculus) and which describes the transformations of programs or switching circuits. At first this system can be applied only to loopfree switching circuits or programs, but loops may easily be presented in a free X-category. All these subjects will thoroughly be discussed in this paper.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264292</ee>
</article>

<article mdate="2013-07-19" key="journals/acta/Kobayashi05">
<author>Naoki Kobayashi 0001</author>
<title>Type-based information flow analysis for the pi-calculus.</title>
<pages>291-347</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>We propose a new type system for information flow analysis for the π-calculus. As demonstrated by recent studies, information about whether each communication succeeds is important for precise information flow analysis for concurrent programs. By collecting such information using ideas of our previous type systems for deadlock/livelock-freedom, our type system can perform more precise analysis for certain communication/synchronization patterns (like synchronization using locks) than previous type systems. Our type system treats a wide range of communication/synchronization primitives in a uniform manner, which enabled development of a clear proof of type soundness and a sound and complete type inference algorithm.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0179-x</ee>
<url>db/journals/acta/acta42.html#Kobayashi05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Berstel74"> 
<author>Jean Berstel</author>
<title>Sur une Conjecture de S. Greibach.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>293-295</pages>
<url>db/journals/acta/acta3.html#Berstel74</url>
<abstract>A counter-example is given to the following conjecture of S. Greibach [4]: “There is no infinite class of mutually incomparable context-free full AFL's”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288640</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/BartschB78">
<author>B. Bartsch</author>
<author>Gunter Bolch</author>
<title>A Conservation Law for G/G/m Queueing Systems.</title>
<pages>105-109</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#BartschB78</url>
<abstract>Conservation laws are useful in the investigation of physical systems. There exists a special conservation law for priority queueing systems: a preferential treatment given to one class of jobs is afforded at the expense of other jobs. This fundamental relationship has been proved previously for G/G/1 queueing systems. In the present paper the conservation law is extended to G/G/m queueing systems and a useful application of this extension is given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260928</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Galil80">
<author>Zvi Galil</author>
<title>Applications of Efficient Mergeable Heaps for Optimization Problems on Trees.</title>
<pages>53-58</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Galil80</url>
<abstract>It is shown how to use efficient mergeable heaps to improve the running time of two algorithms that solve optimization problems on trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288535</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/EngelfrietV97">
<author>Joost Engelfriet</author>
<author>Jan Joris Vereijken</author>
<title>Context-Free Graph Grammars and Concatenation of Graphs.</title>
<pages>773-803</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<url>db/journals/acta/acta34.html#EngelfrietV97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034010/70340773.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hikita79">
<author>Teruo Hikita</author>
<title>On a Class of Recursive Procedures and Equivalent Iterative Ones.</title>
<pages>305-320</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Hikita79</url>
<abstract>H. Partsch and P. Pepper gave translations for a special class of recursive procedures into equivalent iterative ones, motivated by the well-known recursive solution for the ‘Towers of Hanoi’ problem. By generalizing their translations towards two directions, we investigate a class of recursive algorithms and obtain their translations, thus giving a unified view for these algorithms. Some of the included algorithms are mutually recursive procedures for plotting ‘space-filling curves’ such as the Hilbert curves, and a recursive procedure by C.T. Fike which produces all the permutations of n symbols. These algorithms are characterized by the property that the values of a parameter given to recursive procedure calls in a procedure are ‘uniform’ in a certain sense.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268318</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BreitbartR74"> 
<author>Yuri Breitbart</author>
<author>Allen Reiter</author>
<title>Algorithms for Fast Evaluation of Boolean Expressions.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1975</year> 
<pages>107-116</pages>
<url>db/journals/acta/acta4.html#BreitbartR74</url>
<abstract>For Boolean functions whose variables appear in secondary storage, algorithms which minimize the expected cost of evaluation are considered. An easyto-implement algorithm which gives nearly optimal results is proposed for the case of monotonic functions without a priori probabilities. Optimality proofs are given for a simple special cases.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288743</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Hansen72"> 
<author>Per Brinch Hansen</author>
<title>A Comparison of Two Synchronizing Concepts.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>190-199</pages>
<url>db/journals/acta/acta1.html#Hansen72</url>
<abstract>In this paper the use of semaphores and critical regions to synchronize concurrent processes is compared to a more recent proposal for so-called conditional critical regions. The latter concept permits the programmer to express directly that a process must be delayed until a certain condition holds before entering a critical region. The paper describes a well-structured notation for these. synchronizing concepts and uses both of them to solve a typical resource allocation problem. The two solutions are compared by outlining proofs of their correctness. A fairly long argument is needed to justify the solution which uses semaphores. In contrast, the solution based on conditional critical regions is so obvious that a proof is hardly needed. The paper concludes by explaining why programs using semaphores in general will be much more obscure than programs using conditional critical regions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288684</ee>
</article>


<article mdate="2008-06-12" key="journals/acta/Schmidt00">
<author>Karsten Schmidt 0004</author>
<title>How to Calculate Symmetries of Petri Nets.</title>
<pages>545-590</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036007/00360545.htm</ee>
<url>db/journals/acta/acta36.html#Schmidt00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/NielsenRSS74a"> 
<author>Mogens Nielsen</author>
<author>Grzegorz Rozenberg</author>
<author>Arto Salomaa</author>
<author>Sven Skyum</author>
<title>Nonterminals, Homomorphisms and Codings in Different Variations of OL-Systems.  I. Deterministic Systems.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>87-106</pages>
<url>db/journals/acta/acta4.html#NielsenRSS74a</url>
<abstract>The use of nonterminals versus the use of homomorphisms of different kinds in the basic types of deterministic OL-systems is studied. A rather surprising result is that in some cases the use of nonterminals produces a comparatively low generative capacity, whereas in some other cases the use of nonterminals gives a very high generative capacity. General results are obtained concerning the use of erasing productions versus the use of erasing homomorphisms. The paper contains a systematic classification of the effect of nonterminals, codings, weak codings, nonerasing homomorphisms and homomorphisms for all basic types of deterministic OL-languages, including table languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288938</ee>
</article>

<article mdate="2006-05-10" key="journals/acta/BozapalidisK06">
<author>Symeon Bozapalidis</author>
<author>Antonios Kalampakas</author>
<title>Recognizability of graph and pattern languages.</title>
<pages>553-581</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>Graph language recognizability is defined and investigated by virtue of the syntactic magmoid, analogously with the syntactic monoid of a word language. In this setup, the syntax complexity of a given recognizable graph language can be determined, giving rise to a syntactic classification inside the class of recognizable graph languages.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0006-z</ee>
<url>db/journals/acta/acta42.html#BozapalidisK06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DeselR96">
<author>J&ouml;rg Desel</author>
<author>Wolfgang Reisig</author>
<title>The Synthesis Problem of Petri Nets.</title>
<pages>297-315</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta33.html#DeselR96</url>
<abstract>The synthesis problem of concurrent systems is the problem of synthesizing a concurrent system model from sequential observations. The paper studies the synthesis problem for elementary Petri nets and transition systems. A characterization of the class of transition systems which correspond to elementary Petri nets is proven. It is shown how to generate all elementary Petri nets corresponding to a given transition system. If there is any such elementary Petri net, it is proven that there always exists a small one which has only polynomially many elements in the size of the transition system.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050046</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Merzenich79">
<author>Wolfgang Merzenich</author>
<title>A Binary Operation on Trees and an Initial Algebra Characterization for Finite Tree Types.</title>
<pages>149-168</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Merzenich79</url>
<abstract>A binary operation on the class of trees is defined that generates a set B of finite trees form a trivial tree (one node) and B contains for every finite tree G exactly one element isomorphic to G. The binary operation defines an algebraic structure on B, and as a consequence the finite tree types are characterized as an initial algebra in the same way as the natural numbers are characterized as an initial algebra by the Peano-Lawvere axiom [2]. Simple and primitive recursion are defined and some applications of the initial algebra characterization are given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264022</ee>
</article>
<article mdate="2014-03-10" key="journals/acta/MandraliR14">
<author>Eleni Mandrali</author>
<author>George Rahonis</author>
<title>On weighted first-order logics with discounting.</title>
<pages>61-106</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We introduce a linear temporal logic and a first-order logic in the weighted setup of the max-plus semiring with discounting parameters in \([0,1)\). Furthermore, we define \(\omega \hbox {-}d\)-star-free series and counter-free weighted Büchi automata. We show that the classes of series definable in fragments of the weighted linear temporal logic and first-order logic, the class of \(\omega \hbox {-}d\)-star-free series, and a subclass of \(\omega \hbox {-}d\)-counter-free series coincide. This extends a fundamental result, for first-order logic theory, to series over the max-plus semiring with discounting.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0193-3</ee>
<url>db/journals/acta/acta51.html#MandraliR14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/JanssensR81">
<author>Dirk Janssens</author>
<author>Grzegorz Rozenberg</author>
<title>A Characterization of Context-free String Languages by Directed Node-label Controlled Graph Grammars.</title>
<pages>63-85</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#JanssensR81</url>
<abstract>Directed node-label controlled graph grammars (DNLC grammars) are sequential graph rewriting systems. In a direct derivation step of a DNLC grammar a single node is rewritten. Both the rewriting of a node and the embedding of a “daughter graph” in a “host graph” are controlled by the labels of nodes only. We study the use of those grammars to define string languages. In particular we provide a characterization of the class of context-free string languages in terms of DNLC grammars.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289591</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/McIverM01">
<author>Annabelle McIver</author>
<author>Carroll Morgan</author>
<title>Demonic, angelic and unbounded probabilistic choices in sequential programs.</title>
<pages>329-354</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>4/5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037004/10370329.htm</ee>
<url>db/journals/acta/acta37.html#McIverM01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Arun-KumarH92">
<author>S. Arun-Kumar</author>
<author>Matthew Hennessy</author>
<title>An Efficiency Preorder for Processes.</title>
<pages>737-760</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta29.html#Arun-KumarH92</url>
<abstract>A simple efficiency preorder for CCS processes is introduced in whichp≲q means thatq is at least as fast asp, or more generally,p uses at least as much resources asq. It is shown to be preserved by all CCS contexts except summation and it is used to analyse a non-trivial example: two different implementations of a bounded buffer. Finally we give a sound and complete proof system for finite processes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191894</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/IntrigilaV00">
<author>Benedetto Intrigila</author>
<author>Stefano Varricchio</author>
<title>On the Generalization of Higman and Kruskal's Theorems to Regular Languages and Rational Trees.</title>
<pages>817-835</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<url>db/journals/acta/acta36.html#IntrigilaV00</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360817.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Baeza-Yates89">
<author>Ricardo A. Baeza-Yates</author>
<title>Modeling Splits in File Structures.</title>
<pages>349-362</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#Baeza-Yates89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276022</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FachiniMNP92">
<author>Emanuela Fachini</author>
<author>Angelo Monti</author>
<author>Margherita Napoli</author>
<author>Domenico Parente</author>
<title>Languages Accepted by Systolic Y-Tree Automata: Structural Characterizations.</title>
<pages>761-778</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta29.html#FachiniMNP92</url>
<abstract>In this paper closure properties and decision problems for families of languages accepted by deterministic and nondeterministic systolic binary Y-tree automata are studied. Non closure results under basic language operations are stated by means of new nonacceptability criteria for these classes of automata. Necessary and sufficient conditions are given in terms of the shape of the underlying Y-tree, for the closure under λ-free regular substitution, concatenation, inverse homomorfism and for the closure under right concatenation with and quotient by finite sets. Moreover in the nondeterministic case necessary and sufficient conditions are given again in terms of the shape of the underlying Y-tree for the closure under right concatenation with regular sets and for the decidability of the problems of emptiness, finiteness, equivalence and co-emptiness. A sufficient condition is given for the decidability of the stability problem, in the deterministic case, while some undecidability results are proved in the nondeterministic case.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191895</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/PennaITZ03">
<author>Giuseppe Della Penna</author>
<author>Benedetto Intrigila</author>
<author>Enrico Tronci</author>
<author>Marisa Venturini Zilli</author>
<title>Synchronized regular expressions.</title>
<pages>31-70</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/3039001/30390031.htm</ee>
<url>db/journals/acta/acta39.html#PennaITZ03</url>
</article>
<article mdate="2010-01-04" key="journals/acta/JanousekM09">
<author>Jan Janousek</author>
<author>Borivoj Melichar</author>
<title>On regular tree languages and deterministic pushdown automata.</title>
<pages>533-547</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>The theory of formal string languages and of formal tree languages are both important parts of the theory of formal languages. Regular tree languages are recognized by finite tree automata. Trees in their postfix notation can be seen as strings. This paper presents a simple transformation from any given (bottom-up) finite tree automaton recognizing a regular tree language to a deterministic pushdown automaton accepting the same tree language in postfix notation. The resulting deterministic pushdown automaton can be implemented easily by an existing parser generator because it is constructed for an LR(0) grammar, and its size directly corresponds to the size of the deterministic finite tree automaton. The class of regular tree languages in postfix notation is a proper subclass of deterministic context-free string languages. Moreover, the class of tree languages which are in their postfix notation deterministic context-free string languages is a proper superclass of the class of regular tree languages.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0104-9</ee>
<url>db/journals/acta/acta46.html#JanousekM09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HennessyL95"> 
<author>Matthew Hennessy</author>
<author>Xinxin Liu</author>
<title>A Modal Logic for Message Passing Processes.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>4</number>
<year>1995</year> 
<pages>375-393</pages>
<url>db/journals/acta/acta32.html#HennessyL95</url>
<abstract>A first-order modal logic is given for describing properties of processes which may send and receive values or messages along communication ports. We give two methods for proving that a process enjoys such a property. The first is the construction, for each processP and formulaF, of acharacteristic formula P satF such thatP enjoys the propertyF if and only if the formulaP satF is logically equivalent to tt. The second is a sound and complete proof system whose judgements take the formB ⊢P: F, meaning: under the assumptionB the processP enjoys the propertyF.The notion ofsymbolic operational semantics plays a crucial role in the design of both the characteristic formulae and the proof system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178384</ee>
</article>

<article mdate="2015-01-08" key="journals/acta/OvermarsSBK89">
<author>Mark H. Overmars</author>
<author>Michiel H. M. Smid</author>
<author>Mark de Berg</author>
<author>Marc J. van Kreveld</author>
<title>Maintaining Range Trees in Secondary Memory. Part I: Partitions.</title>
<pages>423-452</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta27.html#OvermarsSBK89</url>
<abstract>Range trees are used for solving the orthogonal range searching problem, a problem that has applications in e.g. databases and computer graphics. We study the problem of storing range trees in secondary memory. To this end, we partition range trees into parts that are stored in consecutive blocks in secondary memory. This paper gives a number of partition schemes that limit the part-sizes and the number of disk accesses necessary to perform updates and queries. We show e.g., that for each fixed positive integer k, there is a partition of a two-dimensional range tree into parts of size O(n 1/k ), such that each update requires at most k(2k+1) disk accesses, and each query requires at most 8k 2+2k+2t disk accesses, where t is the number of answers to the range query.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289018</ee>
</article>
<article mdate="2012-11-12" key="journals/acta/Brand12">
<author>Michael Brand</author>
<title>Does indirect addressing matter? - A note.</title>
<pages>485-491</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>In the study of random access machines (RAMs) and the complexities associated with their algorithms, the availability of indirect addressing often creates an analysis obstacle. We show that for RAMs equipped with a sufficiently rich set of basic operations, indirect addressing does not increase computational power, and can be simulated either in linear time or on-line in real time. These results pertain to the uniform cost model and, particularly, assume a unit cost variable shift.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0171-1</ee>
<url>db/journals/acta/acta49.html#Brand12</url>
</article>
<article mdate="2003-11-25" key="journals/acta/BackW99">
<author>Ralph-Johan Back</author>
<author>Joakim von Wright</author>
<title>Reasoning Algebraically about Loops.</title>
<pages>295-334</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036004/90360295.htm</ee>
<url>db/journals/acta/acta36.html#BackW99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Brandwajn74"> 
<author>Alexandre Brandwajn</author>
<title>A Model of a Time Sharing Virtual Memory System Solved Using Equivalence and Decomposition Methods.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>11-47</pages>
<url>db/journals/acta/acta4.html#Brandwajn74</url>
<abstract>A queueing network model of a time-sharing multiprogramming virtual memory system is presented including the effect of memory sharing among processes. An approximate explicit solution is obtained using equivalence and decomposition methods.The influence of system and program behaviour parameters on system performance (mean response time and CPU utilization) is illustrated in the results obtained. The efficiency of controlling the degree of multiprogramming in order to prevent thrashing is also studied using a similar model.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288934</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/BadouelD95"> 
<author>Eric Badouel</author>
<author>Philippe Darondeau</author>
<title>Trace Nets and Process Automata.</title>
<pages>647-679</pages>
<year>1995</year> 
<volume>32</volume> 
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta32.html#BadouelD95</url>
<abstract>Trace nets are a variant of one-safe Petri nets, where input and output places may be filled as well as emptied by transitions. Those extended nets are introduced for modelling concurrency in a simple format of structural operational specifications, based on permutation of proved transitions. Trace nets are connected by an adjunction to a particular class of trace automata in the sense of Stark, namely the separated trace automata. The adjunction is based on a calculus of ‘regions’ that differ significantly from the ones devised by Ehrenfeucht and Rozenberg for elementary nets, although the axioms of separation are the same.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01186645</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Guibas74"> 
<author>Leonidas J. Guibas</author>
<title>A Principle of Independence for Binary Tree Searching.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>293-298</pages>
<url>db/journals/acta/acta4.html#Guibas74</url>
<abstract>When searching unsuccessfully for a fixed element in a random binary search tree, the number of comparisons made whose result is “less” is independent from the number of comparisons whose result is “greater”. This principle can be used to compute the mean and variance of the total number of comparisons involved in both a successful and an unsuccessful search.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289612</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Guting84">
<author>Ralf Hartmut G&uuml;ting</author>
<title>Optimal Divide-and-Conquer to Compute Measure and Contour for a Set of Iso-Rectangles.</title>
<pages>271-291</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Guting84</url>
<abstract>We reconsider two geometrical problems that have been solved previously by line-sweep algorithms: the measure problem and the contour problem. Both problems involve determining some property of the union of a set of rectangles, namely the size and the contour (boundary) of the union. We devise essentially a single time-optimal divide-and-conquer algorithm to solve both problems. This can be seen as a step towards comparing the power of the line-sweep and the divide-and-conquer paradigms. The surprisingly efficient divide-and-conquer algorithm is obtained by using a new technique called “separational representation”, which extends the applicability of divide-and-conquer to orthogonal planar objects.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264251</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeungC84">
<author>Clement H. C. Leung</author>
<author>Qui Hoon Choo</author>
<title>The Paging Drum Queue: A Uniform Perspective and Further Results.</title>
<pages>485-500</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#LeungC84</url>
<abstract>A uniform perspective for the performance analysis of drums organised around the sector concept under Poisson input is presented which allows further results on their operating characteristics to be naturally derived. Closed-form expressions are provided for (i) the mean device service time, (ii) the device utilisation, (iii) the drum efficiency, (iv) the mean device busy period, and (v) the mean number of page transfers per busy period. Both the FCFS and SLTF scheduling disciplines are studied. When the number of sectors per track is large, it is shown that some of the above quantities could be approximated by extremely simple asymptotic formulae if a suitable time unit is adopted. Generalisations of some of these results which are applicable to the performance analysis of solid-state secondary memory and certain computer communications systems — the polling server and the token ring — are also presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271643</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HeilbrunnerH87">
<author>Stephan Heilbrunner</author>
<author>Steffen H&ouml;lldobler</author>
<title>The Undecidability of the Unification and Matching Problem for Canonical Theories.</title>
<pages>157-171</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#HeilbrunnerH87</url>
<abstract>The problem whether there exists a unifying substitution for two terms is considered in the class of theories which can be embedded into canonical term rewriting systems. The problem is shown to be undecidable, even if we restrict the substitutions to matching ones. This implies that the class of admissible canonical theories is a proper subset of the class of canonical theories.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264362</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wirth71"> 
<author>Niklaus Wirth</author>
<title>The Programming Language Pascal.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>35-63</pages>
<url>db/journals/acta/acta1.html#Wirth71</url>
<abstract>A programming language called Pascal is described which was developed on the basis ofAlgol 60. Compared toAlgol 60, its range of applicability is considerably increased due to a variety of data structuring facilities. In view of its intended usage both as a convenient basis to teach programming and as an efficient tool to write large programs, emphasis was placed on keeping the number of fundamental concepts reasonably small, on a simple and systematic language structure, and on efficient implementability. A one-pass compiler has been constructed for the CDC 6000 computer family; it is expressed entirely in terms of Pascal itself.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264291</ee>
</article>

<article mdate="2009-09-28" key="journals/acta/BruckerW09">
<author>Achim D. Brucker</author>
<author>Burkhart Wolff</author>
<title>Semantics, calculi, and analysis for object-oriented specifications.</title>
<pages>255-284</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>We present a formal semantics for an object-oriented specification language. The formal semantics is presented as a conservative shallow embedding in Isabelle/hol and the language is oriented towards ocl formulae in the context of uml class diagrams. On this basis, we formally derive several equational and tableaux calculi, which form the basis of an integrated proof environment including automatic proof support and support for the analysis of this type of specifications. We show applications of our proof environment to data refinement based on an adapted standard refinement notion. Thus, we provide an integrated formal method for refinement-based object-oriented development.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0093-8</ee>
<url>db/journals/acta/acta46.html#BruckerW09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Walter72"> 
<author>Hermann K.-G. Walter</author>
<title>Inhibitionsfelder.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>253-269</pages>
<url>db/journals/acta/acta1.html#Walter72</url>
<abstract>The neurons in the retina of mammals are linked by a system of circuit, such that they influence one another (lateral interaction). The great majority of circuits has got an inhibitory character. F. Ratliff and others have given describing equations for such a system, which by installation of thresholds essentially become non-linear. We shall discuss the characteristics resulting from the describing equations. We are especially interested in the stability characteristics. Naturally, we are mainly interested in the non-linear part of the theory. With respect to stability, we are able to show that stability conditions are the same as with linear systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288689</ee>
</article>


<article mdate="2014-11-03" key="journals/acta/KutribMW14">
<author>Martin Kutrib</author>
<author>Andreas Malcher</author>
<author>Matthias Wendlandt</author>
<title>Head and state hierarchies for unary multi-head finite automata.</title>
<pages>553-569</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>Unary deterministic one-way multi-head finite automata characterize the unary regular languages. Here they are studied with respect to the existence of head and state hierarchies. It turns out that for any fixed number of states, there is an infinite proper head hierarchy. In particular, the head hierarchy for stateless deterministic one-way multi-head finite automata is obtained using unary languages. On the other hand, it is shown that for a fixed number of heads, \(m+1\) states are more powerful than \(m\) states. Finally, the open question of whether emptiness is undecidable for stateless one-way two-head finite automata is addressed and, as a partial answer, undecidability can be shown if at least four states are provided.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0206-x</ee>
<url>db/journals/acta/acta51.html#KutribMW14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Mescheder80">
<author>Bernhard Mescheder</author>
<title>On the Number of Active-Operations Needed to Compute the Discrete Fourier Transform.</title>
<pages>383-408</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Mescheder80</url>
<abstract>Let M(N) denote the number of active multiplications/divisions needed to compute the discrete Fourier transform of N variables. Winograd showed M(N) ≦ O(N). For N a power of two we analyse his method and find M(N)≦8 N−o(N). Using additional symmetries we improve this to M(N)≦2N−o(N). We also give a very short proof for M(N)≦4N-o(N). Finally we show M(N)≧N − 2 log N.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288772</ee>
</article>
<article mdate="2005-11-14" key="journals/acta/KuceraS05">
<author>Anton&iacute;n Kucera</author>
<author>Jan Strejcek</author>
<title>The stuttering principle revisited.</title>
<pages>415-434</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>It is known that LTL formulae without the ‘next’ operator are invariant under the so-called stutter equivalence of words. In this paper we extend this principle to general LTL formulae with given nesting depths of both ‘next’ and ‘until’ operators. This allows us to prove the semantical strictness of three natural hierarchies of LTL formulae, which are parametrized either by the nesting depth of just one of the two operators, or by both of them. Further, we provide an effective characterization of languages definable by LTL formulae with a bounded nesting depth of the ‘next’ operator.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0164-4</ee>
<url>db/journals/acta/acta41.html#KuceraS05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Murtagh87">
<author>Thomas P. Murtagh</author>
<title>Redundant Proofs of Non-Interference in Levin-Gries CSP Program Proofs.</title>
<pages>145-156</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#Murtagh87</url>
<abstract>The proof system for Hoare's CSP language proposed by Levin and Gries requires that non-interference be proven for each assertion used in the proof of a process. In the worst case, the effort required to provide such proofs could be enormous. The need for these proofs has been identified as a significant weakness of the system. In this paper, we show that most of the proofs of non-interference required are unnecessary. This suggest that proving non-interference in the Levin-Gries system may be far less burdensome than had previously been assumed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264361</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BuchsbaumST95"> 
<author>Adam L. Buchsbaum</author>
<author>Rajamani Sundar</author>
<author>Robert Endre Tarjan</author>
<title>Lazy Structure Sharing for Query Optimization.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>3</number>
<year>1995</year> 
<pages>255-270</pages>
<url>db/journals/acta/acta32.html#BuchsbaumST95</url>
<abstract>We studylazy structure sharing as a tool for optimizing equivalence testing on complex data types. We investigate a number of strategies for implementing lazy structure sharing and provide upper and lower bounds on their performance (how quickly they effect ideal configurations of our data structure). In most cases when the strategies are applied to a restricted case of the problem, the bounds provide nontrivial improvements over the naïve linear-time equivalence-testing strategy that employs no optimization. Only one strategy, however, which employs path compression, seems promising for the most general case of the problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178261</ee>
</article>

<article mdate="2007-06-13" key="journals/acta/Fu07">
<author>Yuxi Fu</author>
<title>Fair ambients.</title>
<pages>535-594</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>Based on an analysis of the capability operators of the Calculus of Mobile Ambients, three fairness principles are proposed to safeguard the interactions of the ambients. The Calculus of Fair Ambient is designed to meet these fairness principles. A labeled transition semantics for the calculus is defined to support structural investigation. The bisimulation theory of the fair ambients is studied and two coincidence results are established. An expressiveness result of the calculus is formally established by proving that it contains the pi calculus as a sub-calculus.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0038-z</ee>
<url>db/journals/acta/acta43.html#Fu07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ramsperger77"> 
<author>Norbert Ramsperger</author>
<title>Concurrent Access to Data.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>325-334</pages>
<url>db/journals/acta/acta8.html#Ramsperger77</url>
<abstract>Problems caused by concurrent access to data can be solved by locking. This, however, diminishes efficiency and may cause deadlocks among the accessing processes. In this paper the structuring of data sets is deduced from assertions about accesses which may be performed simultaneously. This structuring supports the development of operations which synchronize concurrent access to these data. Thus the provisions for locking are transferred from programs to data structures where the requests for locking actually arise. The synchronization operations will exclude all undesired interferences and will maximize the number of possible simultaneous accesses in accordance with the original assertions.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271341</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Larsen02">
<author>Kim S. Larsen</author>
<title>Relaxed red-black trees with group updates.</title>
<pages>565-586</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038008/20380565.htm</ee>
<url>db/journals/acta/acta38.html#Larsen02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/NakataS86">
<author>Ikuo Nakata</author>
<author>Masataka Sassa</author>
<title>Generation of Efficient <i> LALR </i> Parsers for Regular Right Part Grammars.</title>
<pages>149-162</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#NakataS86</url>
<abstract>A method for building small fast LALR parsers for regular right part grammars is given. No grammar transformation is required. No extra state of the LALR parser for the recognition of strings generated by a right part is required. At some reduce states the parser may refer to lookback states (states in which the parser may be restarted after the reduction). An optimizing algorithm to reduce these references is also given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289495</ee>
</article>
<article mdate="2011-08-10" key="journals/acta/DoCDP11">
<author>Tien Van Do</author>
<author>Ram Chakka</author>
<author>Nam H. Do</author>
<author>L&aacute;szl&oacute; Pap</author>
<title>A Markovian queue with varying number of servers and applications to the performance comparison of HSDPA user equipment.</title>
<pages>243-269</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Inspired by the need for performability models for HSDPA user equipment, a Markovian queue with varying number of servers is conceived. The arrival and the service processes, the number of allocated or active servers of the queue are inherently, and independently (or jointly) Markov modulated. Batch arrivals, batch services, autocorrelation of inter-arrival times, and autocorrelation of batch sizes can be accommodated in the queue, by a suitable use of Markov modulation and generalized exponential distribution. The queue has a provision for negative customers too. Transformations of the balance equations into a computable form are proposed in order to obtain the steady state probabilities with the Spectral Expansion method. This queue is used to model the High Speed Downlink Packet Access (HSDPA) wireless networks. The model is an integrated one with respect to HSDPA, capable of accommodating many of the intricate aspects of HSDPA such as, channel allocation policy, loss of packets due to channel fading, bursty and correlated traffic. Good agreement is observed between the numerical results of the proposed analytical model and those of an independent simulator of real HSDPA and radio channel behaviors. The comparison of the terminal categories specified by the 3rd Generation Partnership Project (3GPP) is also presented.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0138-7</ee>
<url>db/journals/acta/acta48.html#DoCDP11</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Yen98">
<author>Hsu-Chun Yen</author>
<title>Priority Conflict-Free Petri Nets.</title>
<pages>673-688</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350673.htm</ee>
<url>db/journals/acta/acta35.html#Yen98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/VaishnaviKW80">
<author>Vijay K. Vaishnavi</author>
<author>Hans-Peter Kriegel</author>
<author>Derick Wood</author>
<title>Optimum Multiway Search Trees.</title>
<pages>119-133</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#VaishnaviKW80</url>
<abstract>The construction of optimum multiway search trees for n keys, n key weights and n+1 gap weights, is investigated. A new general optimality principle is presented, which can be “tuned” for specific applications. Moreover we consider the affects of three additional constraints, namely height, structural and node search restrictions, which lead to a number of new construction algorithms. In particular we concentrate on the construction of optimum t-ary search trees with linear and binary search within their nodes for which we obtain O(n 3 t) and O(n 3log2 t) time algorithms, respectively. Whether these algorithms are or are not optimal remains an important open problem, even in the binary case.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288540</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BlumS84">
<author>Norbert Blum</author>
<author>Martin Seysen</author>
<title>Characterization of all Optimal Networks for a Simultaneous Computation of AND and NOR.</title>
<pages>171-181</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BlumS84</url>
<abstract>We characterize the optimal networks for a simultaneous computation of AND and NOR over the base of all 16 Boolean operators. We show that the optimal networks for AND and NOR are precisely the networks that consist of a disjoint union of an optimal network for AND with an optimal network for NOR.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289238</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/VaidyanathanHV95"> 
<author>Ramachandran Vaidyanathan</author>
<author>Carlos R. P. Hartmann</author>
<author>Pramod K. Varshney</author>
<title>Parallel Integer Sorting Using Small Operations.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>1</number>
<year>1995</year> 
<pages>79-92</pages>
<url>db/journals/acta/acta32.html#VaidyanathanHV95</url>
<abstract>We consider the problem of sortingn integers in the range [0,n c -1], wherec is a constant. It has been shown by Rajasekaran and Sen [14] that this problem can be solved “optimally” inO(logn) steps on an EREW PRAM withO(n) n ∈-bit operations, for any constant ∈>O. Though the number of operations is optimal, each operation is very large. In this paper, we show thatn integers in the range [0,n c -1] can be sorted inO(logn) time withO(nlogn)O(1)-bit operations andO(n) O(logn)-bit operations. The model used is a non-standard variant of an EREW PRAMtthat permits processors to have word-sizes ofO(1)-bits and Θ(logn)-bits. Clearly, the speed of the proposed algorithm is optimal. Considering that the input to the problem consists ofO (n logn) bits, the proposed algorithm performs an optimal amount of work, measured at the bit level.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185406</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/GasoN03">
<author>J&aacute;n Gaso</author>
<author>Martin Neh&eacute;z</author>
<title>Stochastic cooperative distributed grammar systems and random graphs.</title>
<pages>119-140</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/3039002/30390119.htm</ee>
<url>db/journals/acta/acta39.html#GasoN03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DudaC87">
<author>Andrzej Duda</author>
<author>Tadeusz Czach&oacute;rski</author>
<title>Performance Evaluation of Fork and Join Synchronization Primitives.</title>
<pages>525-553</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#DudaC87</url>
<abstract>The paper presents a performance model of fork and join synchronization primitives. The primitives are used in parallel programs executed on distributed systems. Three variants of the execution of parallel programs with fork and join primitives are considered and queueing models are proposed to evaluate their performance on a finite number of processors. Synchronization delays incurred by the programs are represented by a state-dependent server with service rate depending on a particular synchronization scheme. Closed form results are presented for the two processor case and a numerical method is proposed for many processors. Fork-join queueing networks having more complex structure i.e., processors arranged in series and in parallel, are also analyzed in the same manner. The networks can model the execution of jobs with a general task precedence graph corresponding to a nested structure of the fork-join primitives. Some performance indices of the parallel execution of programs are studied. The results show that the speedup which can be obtained theoretically in a parallel system may be decreased significantly by synchronization constraints.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263293</ee>
</article>
<article mdate="2011-02-16" key="journals/acta/LiT11">
<author>Zheng-Zhu Li</author>
<author>Y. S. Tsai</author>
<title>Some properties of the disjunctive languages contained in <i>Q</i>.</title>
<pages>1-18</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The set of all primitive words Q over an alphabet X was first defined and studied by Shyr and Thierrin (Proceedings of the 1977 Inter. FCT-Conference, Poznan, Poland, Lecture Notes in Computer Science 56. pp. 171–176 (1977)). It showed that for the case |X| ≥ 2, the set along with \({Q^{(i)} = \{f^i\,|\,f \in Q\}, i\geq 2}\) are all disjunctive. Since then these disjunctive sets are often be quoted. Following Shyr and Thierrin showed that the half sets \({Q_{ev} = \{f \in Q\,|\,|f| = {\rm even}\}}\) and Q od = Q \ Q ev of Q are disjunctive, Chien proved that each of the set \({Q_{p,r}= \{u\in Q\,|\,|u|\equiv r\,(mod\,p) \},\,0\leq r < p}\) is disjunctive, where p is a prime number. In this paper, we generalize this property to that all the languages \({Q_{n,r}= \{u\in Q\,|\,|u|\equiv r\,(mod\,n) \},\, 0\leq r < n}\) are disjunctive languages, where n is any positive integer. We proved that for any n ≥ 1, k ≥ 2, (Q n,0) k are all regular languages. Some algebraic properties related to the family of languages {Q n,r | n ≥ 2, 0 ≤ r < n } are investigated.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0127-2</ee>
<url>db/journals/acta/acta48.html#LiT11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikGS82">
<author>Karel Culik II</author>
<author>Jozef Gruska</author>
<author>Arto Salomaa</author>
<title>Systolic Automata for VLSI on Balanced Trees.</title>
<pages>335-344</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#CulikGS82</url>
<abstract>Systolic tree automata with a binary (or, more generally, balanced) underlying tree are investigated. The main emphasis is on input conditions, decidability, and characterization of acceptable languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289573</ee>
</article>
<article mdate="2004-06-28" key="journals/acta/EngelfrietG04">
<author>Joost Engelfriet</author>
<author>Tjalling Gelsema</author>
<title>A new natural structural congruence in the pi-calculus with replication.</title>
<pages>385-430</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>In the \(\pi\)-calculus with replication, a new structural congruence called “middle” congruence is investigated: a notion of structural equivalence of processes in which replication of a process is viewed as a potential rather than an actual infinite number of copies of the process, in the sense that copies are spawned at need rather than produced all at once. It is slightly weaker than standard congruence (which is also of the potential type) but stronger than the extended congruence investigated before by the authors (which is of the actual type). It is shown that middle congruence has the same desirable properties as extended congruence: it is decidable and it has a concrete multiset semantics. Thus, these properties do not depend on the distinction between potential and actual replication.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0141-3</ee>
<url>db/journals/acta/acta40.html#EngelfrietG04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DenningKLPS76"> 
<author>Peter J. Denning</author>
<author>Kevin C. Kahn</author>
<author>Jacques Leroudier</author>
<author>Dominique Potier</author>
<author>Rajan Suri</author>
<title>Optimal Multiprogramming.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>197-216</pages>
<url>db/journals/acta/acta7.html#DenningKLPS76</url>
<abstract>Three heuristics for controlling the multiprogramming load to maximize system work capacity are studied. Each allows the highest load possible subject to a given constraint. The knee criterion constrains the memory policy so that program resident sets average near the knees of their inter page fault lifetime curves. The L=S criterion constrains the memory policy or load so that the system inter page fault lifetime L is at least as large as page swap time S. The 50 % criterion constrains the load so that the paging device is busy approximately half the time. Numerical evaluations of queueing networks show that the knee criterion, which is the most difficult to implement, is the most robust, while the easily implemented 50 % criterion is the least robust. These evaluations also circumscribe the conditions under which the criteria are expected to work reliably. Examples from practical systems further validate the criteria. Stability problems are examined.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265771</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/FachiniMS92">
<author>Emanuela Fachini</author>
<author>Andrea Maggiolo-Schettini</author>
<author>Davide Sangiorgi</author>
<title>Classes of Systolic Y-Tree Automata and a Comparison with Systolic Trellis Automata.</title>
<pages>623-643</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#FachiniMS92</url>
<abstract>In this paper we study systolic Y-tree automata (SYTA), a class of systolic automata where the communication structure is obtained by adding new edges, and therefore new sons, called adoptive sons, to the nodes of the underlying tree according to some regularity condition. We study SYTA in the more specific case where the tree ist-ary or a tree with base. We show that for eachs≧0 the set of classes of languages accepted by SYTA whose underlying tree is a tree with base withs leaves has a maximum, calledLsSYTA. We study whenLsSYTA is reached depending on number and position of the adoptive sons. We prove that ifs andt are powers of the same base, thenLsSYTA=LtSYTA. We give also a simulation of SYTA on regular and modular systolic trellis automata, strengthening a previous result on simulation of systolic tree automata on systolic trellis automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185564</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChoffrutC84">
<author>Christian Choffrut</author>
<author>Karel Culik II</author>
<title>On Real-Time Cellular Automata and Trellis Automata.</title>
<pages>393-407</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#ChoffrutC84</url>
<abstract>It is shown that f(n)-time one-way cellular automata are equivalent to f(n)-time trellis automata, the real-time one-way cellular automata languages are closed under reversal, the 2n-time one-way cellular automata are equivalent to real-time cellular automata and the latter are strictly more powerful than the real-time one-way cellular automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264617</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/SchenkeO99">
<author>Michael Schenke</author>
<author>Ernst-R&uuml;diger Olderog</author>
<title>Transformational Design of Real-Time Systems Part I: From Requirements to Program Specifications.</title>
<pages>1-65</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036001/90360001.htm</ee>
<url>db/journals/acta/acta36.html#SchenkeO99</url>
</article>
<article mdate="2009-05-20" key="journals/acta/CorradiniGR97">
<author>Flavio Corradini</author>
<author>Roberto Gorrieri</author>
<author>Marco Roccetti</author>
<title>Performance Preorder and Competitive Equivalence.</title>
<pages>805-835</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034011/70340805.htm</ee>
<url>db/journals/acta/acta34.html#CorradiniGR97</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nijholt80">
<author>Anton Nijholt</author>
<title>A Survey of Normal Form Covers for Context Free Grammars.</title>
<pages>271-294</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Nijholt80</url>
<abstract>An overview is given of cover results for normal forms of context-free grammars. The emphasis in this paper is on the possibility of constructing ɛ-free grammars, non-left-recursive grammars and grammars in Greibach normal form. Among others it is proved that any ɛ-free context-free grammar can be right covered with a context-free grammar in Greibach normal form.All the cover results concerning the ɛ-free grammars, the non-left-recursive grammars and the grammars in Greibach normal form are listed, with respect to several types of covers, in a cover-table.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264257</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Lau89">
<author>Kung-Kiu Lau</author>
<title>A Note on Synthesis and Classification of Sorting Algorithms.</title>
<pages>73-80</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta27.html#Lau89</url>
<abstract>Sorting algorithms are traditionally classified according to their main operational characteristic. More recently, program synthesis has been used as a basis for classification. We briefly survey previous work in the synthesis and classification of sorting algorithms, and outline a more comprehensive scheme derived by synthesising many sorting algorithms in a top-down fashion on a semi-automated logic programming system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263502</ee>
</article>
<article mdate="2009-06-22" key="journals/acta/CorradiniBV09">
<author>Flavio Corradini</author>
<author>Maria Rita Di Berardini</author>
<author>Walter Vogler</author>
<title>Liveness of a mutex algorithm in a fair process algebra.</title>
<pages>209-235</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>In earlier work, we have shown that two variants of weak fairness can be expressed comparatively easily in the timed process algebra PAFAS. To demonstrate the usefulness of these results, we complement work by Walker (Form Asp Comput 1:273–292, 1989) and study the liveness property of Dekker’s mutual exclusion algorithm within our process algebraic setting. We also present some results that allow to reduce the state space of the PAFAS process representing Dekker’s algorithm, and give some insight into the representation of fair behaviour in PAFAS.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0092-9</ee>
<url>db/journals/acta/acta46.html#CorradiniBV09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Pritchard81">
<author>Paul Pritchard</author>
<title>Another Look at the "Longest Ascending Subsequence" Problem.</title>
<pages>87-91</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Pritchard81</url>
<abstract>Dijkstra has given a derivation of an efficient algorithm for a problem concerning monotonic subsequences, and extracted a proof of a related theorem from the algorithm. Here it is shown that a careful separation of concerns can lead to a beautiful conventional proof, a very different derivation of Dijkstra's algorithm, a more elegant proof from the algorithm, and the discovery of a duality property.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289592</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AsveldT82">
<author>Peter R. J. Asveld</author>
<author>J. V. Tucker</author>
<title>Complexity Theory and the Operational Structure of Algebraic Programming Systems.</title>
<pages>451-476</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#AsveldT82</url>
<abstract>An algebraic programming system is a language built from a fixed algebraic data abstraction and a selection of deterministic, and nondeterministic, assignment and control constructs. First, we give a detailed analysis of the operational structure of an algebraic data type, one which is designed to classify programming systems in terms of the complexity of their implementations. Secondly, we test our operational description by comparing the computations in deterministic and non-deterministic programming systems under certain space and time restrictions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264163</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MannaP93">
<author>Zohar Manna</author>
<author>Amir Pnueli</author>
<title>Models for Reactivity.</title>
<pages>609-678</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta30.html#MannaP93</url>
<abstract>A hierarchy of models that capture realistic aspects of reactive, real-time, and hybrid systems is introduced. On the most abstract level, the qualitative (non-quantitative) model ofreactive systems captures the temporal precedence aspect of time. A more refined model is that ofreal-time systems, which represents the metric aspect of time. The third and most detailed model is that ofhybrid systems, which allows the incorporation ofcontinuous components into a reactive system.For each of the three levels, we present a computational model, a requirement specification language based on extensions of temporal logic, system description languages based on Statecharts and a textual programming language, proof rules for proving validity of properties, and examples of such proofs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191722</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/EngelfrietG98">
<author>Joost Engelfriet</author>
<author>Tjalling Gelsema</author>
<title>Axioms for Generalized Graphs, Illustrated by a Cantor-Bernstein Proposition.</title>
<pages>1075-1096</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035012/80351075.htm</ee>
<url>db/journals/acta/acta35.html#EngelfrietG98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SobelS88">
<author>Ann E. Kelley Sobel</author>
<author>Neelam Soundararajan</author>
<title>A Proof System for Distributed Processes.</title>
<pages>305-332</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta25.html#SobelS88</url>
<abstract>A partial correctness proof system for Brinch Hansen's Distributed Processes (DP) is presented. Two important aspects of the system are: Proofs of individual processes of a DP program are completely isolated from each other; in particular, no assumptions are allowed in the proof of one process about the behavior of the other processes. Secondly a process is characterized by its externally visible behavior, i.e. the sequence of interactions between this process and the other processes of the program. An example demonstrates the use of the system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00283331</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Slutzki82">
<author>Giora Slutzki</author>
<title>Finite State Relational Programs.</title>
<pages>393-409</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Slutzki82</url>
<abstract>We introduce a new class of programs, called Finite Relational Linear Programs (FRLP), capable of modeling simple data processing applications. We analyze these programs with respect to tradeoffs between features they possess including the problems of equivalence and optimization. Algorithmic solutions are given to the two latter problems and others. Extensions are discussed in which a (part of) algorithmic solvability is lost. A unifying concept for this and previous work is presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289577</ee>
</article>
<article mdate="2015-05-28" key="journals/acta/KlinglerR81">
<author>Thomas Klingler</author>
<author>Stefan Reisch</author>
<title>A Gap Between the Actual Complexity of Permutations and Their Entropy Defined by Sto&szlig;.</title>
<pages>347-362</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#KlinglerR81</url>
<abstract>We will construct a family of permutations having an entropy of lower order than their actual rearrangement-complexity. This result is a solution of an open problem that arose in the context of a result obtained by Stoß [6], who showed that entropy yields a lower bound for complexity of permutations. Besides this we present some interesting results concerning the entropy of permutations defined by Stoß [6].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289310</ee>
</article>
<article mdate="2011-05-16" key="journals/acta/DrewesHM11">
<author>Frank Drewes</author>
<author>Johanna H&ouml;gberg</author>
<author>Andreas Maletti</author>
<title>MAT learners for tree series: an abstract data type and two realizations.</title>
<pages>165-189</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>We propose abstract observation tables, an abstract data type for learning deterministic weighted tree automata in Angluin’s minimal adequate teacher (MAT) model, and show that every correct implementation of abstract observation tables yields a correct MAT learner. Besides the “classical” observation table, we show that abstract observation tables can also be implemented by observation trees. The advantage of the latter is that they often require fewer queries to the teacher.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0135-x</ee>
<url>db/journals/acta/acta48.html#DrewesHM11</url>
</article>
<article mdate="2005-12-14" key="journals/acta/JacobsenL05">
<author>Lars Jacobsen</author>
<author>Kim S. Larsen</author>
<title>Exponentially decreasing number of operations in balanced trees.</title>
<pages>57-78</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>While many tree-like structures have been proven to support amortized constant number of operations after updates, considerably fewer structures have been proven to support the more general exponentially decreasing number of operations with respect to distance from the update. In addition, all existing proofs of exponentially decreasing operations are tailor-made for specific structures. We provide the first formalization of conditions under which amortized constant number of operations imply exponentially decreasing number of operations. Since our proof is constructive, we obtain the constants involved immediately. Moreover, we develop a number of techniques to improve these constants.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0173-3</ee>
<url>db/journals/acta/acta42.html#JacobsenL05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Russell80">
<author>Bruce Russell</author>
<title>Correctness of the Compiling Process Based on Axiomatic Semantics.</title>
<pages>1-20</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Russell80</url>
<abstract>A language that includes computed gotos and parameterized procedures is defined and its semantics are given axiomatically. A number of program transformations are described and proved correct. Taken collectively and applied repeatedly these transformations compile the full language into a low level subset.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289061</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SieckmannW80">
<author>J&ouml;rg H. Siekmann</author>
<author>Graham Wrightson</author>
<title>Paramodulated Connection Graphs.</title>
<pages>67-86</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#SieckmannW80</url>
<abstract>The connection graph proof procedure of R. Kowalski is extended to the case of equality. The extension is achieved through the introduction of special links connecting those terms that can be paramodulated upon. Completeness and consistency of the resulting proof procedure are shown.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288537</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wright94">
<author>Joakim von Wright</author>
<title>The Lattice of Data Refinement.</title>
<pages>105-135</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta31.html#Wright94</url>
<abstract>We define a general notion of data refinement that comprises the traditional notion of data refinement as a special case. Using the concepts of duals and adjoints, we define converse commands and find a symmetry between ordinary data refinement and a dual (backward) data refinement. We show how ordinary and backward data refinement are interpreted as simulation, and we derive rules for the piecewise data refinement of programs. Our results are valid for a general language, including demonic and angelic nondeterminism as well as nontermination and miracles.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01192157</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FrancezKP77"> 
<author>Nissim Francez</author>
<author>Boris Klebansky</author>
<author>Amir Pnueli</author>
<title>Backtracking in Recursive Computations.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>125-144</pages>
<url>db/journals/acta/acta8.html#FrancezKP77</url>
<abstract>A mathematical (denotational) semantics is constructed for a formalism of recursive equations with the Alternative operator. This formalism enables the combination of recursion and backtracking. The semantics is defined by applying fixpoint theory to set valued functions. We introduce the notion of strategy to produce subsets of the result. Two implementations are suggested using an auxiliary stack, that trade off recomputation time with space in the auxiliary stack. The concept of a sub-fixpoint is introduced, and the implementations are shown to be incomplete even w.r.t. sub-fixpoint values. One special strategy, the leftmost strategy, which stems from problems such as pattern matching or parsing, is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289245</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/FischerMQ80">
<author>Charles N. Fischer</author>
<author>D. R. Milton</author>
<author>S. B. Quiring</author>
<title>Efficient LL(1) Error Correction and Recovery Using Only Insertions.</title>
<pages>141-154</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#FischerMQ80</url>
<abstract>An LL(1)-based error-corrector which operates by insertion-only is studied. The corrector is able to correct and parse any input string. It is efficient (linear in space and time requirements) and chooses least-cost insertions (as defined by the user) in correcting syntax errors. Moreover, the error-corrector can be generated automatically from the grammar and a table of terminal symbol insertion costs. This method is also very well suited for use as an automatic error-recovery technique in LL(1) parsers. The class of LL(1) grammars correctable by this method contains (with minor modifications) grammars used to specify most common programming languages. Preliminary results suggest that this method can be used to advantage in LL(1)-driven compilers.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263990</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LamsweerdeS79">
<author>Axel van Lamsweerde</author>
<author>Michel Sintzoff</author>
<title>Formal Derivation of Strongly Correct Concurrent Programs.</title>
<pages>1-31</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#LamsweerdeS79</url>
<abstract>A method is described for deriving concurrent programs which are consistent with the problem specifications and free from deadlock and from starvation. The programs considered are expressed by nondeterministic repetitive selections of pairs of synchronizing conditions and subsequent actions. An iterative, convergent calculus is developed for synthesizing the invariant and synchronizing conditions which guarantee strong correctness. These conditions are constructed as limits of recurrences associated with the specifications and the actions. An alternative method for deriving starvationfree programs by use of auxiliary variables is also given. The applicability of the techniques presented is discussed through various examples; their use for verification purposes is illustrated as well.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264015</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BentleyM80">
<author>Jon Louis Bentley</author>
<author>Hermann A. Maurer</author>
<title>Efficient Worst-Case Data Structures for Range Searching.</title>
<pages>155-168</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#BentleyM80</url>
<abstract>In this paper we investigate the worst-case complexity of range searching: preprocess N points in k-space such that range queries can be answered quickly. A range query asks for all points with each coordinate in some range of values, and arises in many problems in statistics and data bases. We develop three different structures for range searching in this paper. The first structure has absolutely optimal query time (which we prove), but has very high preprocessing and storage costs. The second structure we present has logarithmic query time and O(N 1+2) preprocessing and storage costs, for any fixed ɛ>0. Finally we give a structure with linear storage, O(N ln N) preprocessing and O(N ɛ) query time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263991</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GuzmanOV95"> 
<author>Inman P. de Guzm&aacute;n</author>
<author>Manuel Ojeda-Aciego</author>
<author>Agust&iacute;n Valverde</author>
<title>A Formal Identification between Tuples and Lists with an Application to List-Arithmetic Categories.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>1</number>
<year>1995</year> 
<pages>61-78</pages>
<url>db/journals/acta/acta32.html#GuzmanOV95</url>
<abstract>We may say with confidence that in many papers about general programming languages either the distinction betweenn-tuples and lists of lengthn is avoided, or those objects are identified, but only at an intuitive level [7, 8, 13]. That type of identification, considered formally, leads to non-trivial problems, making difficult the typing of the functions used to deal with lists, i.e.hd, tl, cons...In this paper, following computational intuitions, we present a construction of a list object as a coproduct. This idea is the key concept that permits us to prove directly some of the presented results about list-arithmetic categories. This is a most useful construction because we construct recursive objects on the basis of the expected semantics of a list object.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185405</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/KamU77"> 
<author>John B. Kam</author>
<author>Jeffrey D. Ullman</author>
<title>Monotone Data Flow Analysis Frameworks.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>305-317</pages>
<url>db/journals/acta/acta7.html#KamU77</url>
<abstract>We consider a generalization of Kildall's lattice theoretic approach to data flow analysis, which we call monotone data flow analysis frameworks. Many flow analysis problems which appear in practice meet the monotonicity condition but not Kildall's condition called distributivity. We show that the maximal fixed point solution exists for every instance of every monotone framework, and that it can be obtained by Kildall's algorithm. However, whenever the framework is monotone but not distributive, there are instances in which the desired solution—the “meet over all paths solution” — differs from the maximal fixed point. Finally, we show the nonexistence of an algorithm to compute the meet over all paths solution for monotone frameworks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290339</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Thorup96">
<author>Mikkel Thorup</author>
<title>Disambiguating Grammars by Exclusion of Sub-Parse Trees.</title>
<pages>511-522</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#Thorup96</url>
<abstract>A method is presented for disambiguation of grammars, based on the idea of excluding certain forbidden sub-parse trees. Combined with recent developments in the theory of parser generation for ambiguous grammars, the method disambiguates large classes of grammars guaranteeing that the generated language is unchanged.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036460</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hennessy84">
<author>Matthew Hennessy</author>
<title>Axiomatising Finite Delay Operators.</title>
<pages>61-88</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Hennessy84</url>
<abstract>In a simple language for finite automata based on SCCS we introduce three different delay operators δ, ɛ, γ. The operators ɛ, γ are two different versions of an unbounded but finite delay operator. It is argued that the usual notion of bisimulation is inadequate and two generalisations are proposed. In both cases we give a complete axiomatisation for finite terms of the language and prove that certain forms of induction are sound. In one case we give a complete axiomatisation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289140</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Morris89">
<author>Joseph M. Morris</author>
<title>Laws of Data Refinement.</title>
<pages>287-308</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#Morris89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276019</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/Amigo06">
<author>Jos&eacute; M. Amig&oacute;</author>
<title>Representing the integers with powers of 2 and 3.</title>
<pages>293-306</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>The Collatz sequence (n 0,n 1,...) is defined by n k+1 = 3n k  + 1 or n k /2 depending on n k being odd or even, respectively. The Collatz conjecture (one of the most challenging open problems in Number Theory) states then that n k  = 1 for some k depending on n 0. This conjecture can be reformulated in a variety of ways, some of them seemingly more amenable to the methods of discrete mathematics. In this paper, we derive one such equivalent formulation involving exponential Diophantine equations. It follows that if the Collatz conjecture is true, then any number can be represented as sums of positive powers of 2 and negative powers of 3.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0021-0</ee>
<url>db/journals/acta/acta43.html#Amigo06</url>
</article>
<article mdate="2005-03-14" key="journals/acta/BrodalDM05">
<author>Gerth St&oslash;lting Brodal</author>
<author>Erik D. Demaine</author>
<author>J. Ian Munro</author>
<title>Fast allocation and deallocation with an improved buddy system.</title>
<pages>273-291</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract><ee>http://www.springerlink.com/index/10.1007/s00236-004-0159-6</ee>
<url>db/journals/acta/acta41.html#BrodalDM05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KumarR87">
<author>S. Kiran Kumar</author>
<author>C. Pandu Rangan</author>
<title>A Linear Space Algorithm for the LCS Problem.</title>
<pages>353-362</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta24.html#KumarR87</url>
<abstract>The LCS problem is to determine the longest common subsequence (LCS) of two strings. A new linear-space algorithm to solve the LCS problem is presented. The only other algorithm with linear-space complexity is by Hirschberg and has runtime complexity O(mn). Our algorithm, based on the divide and conquer technique, has runtime complexity O(n(m-p)), where p is the length of the LCS.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265993</ee>
</article>
<article mdate="2006-05-10" key="journals/acta/Majster-CederbaumWY06">
<author>Mila E. Majster-Cederbaum</author>
<author>Jinzhao Wu</author>
<author>Houguang Yue</author>
<title>Refinement of actions for real-time concurrent systems with causal ambiguity.</title>
<pages>389-418</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>Refinement of actions is a core operation in the hierarchical design methodology for concurrent systems. In this paper, we develop an approach of action refinement for concurrent systems with not only the notation of real-time but also with causal ambiguity, which often exists and appears in real application areas. The systems are modeled in terms of a timed extension of bundle event structures with causal ambiguity. Under a certain partial order semantics, the behavior of the refined system can be inferred compositionally from the behavior of the original system and from the behavior of the systems used to refine actions with explicitly represented start points. A variant of a linear-time equivalence termed pomset trace equivalence and a variant of a branching-time equivalence termed history preserving bisimulation equivalence based on the partial order semantics are both congruences under the refinement. The refinement operation behaves thus well and meets the commonly expected properties.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-005-0172-4</ee>
<url>db/journals/acta/acta42.html#Majster-CederbaumWY06</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Kim01">
<author>Changwook Kim</author>
<title>Efficient recognition algorithms for boundary and linear eNCE graph languages.</title>
<pages>619-632</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037009/10370619.htm</ee>
<url>db/journals/acta/acta37.html#Kim01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Kiehn94">
<author>Astrid Kiehn</author>
<title>Comparing Locality and Causality Based Equivalences.</title>
<pages>697-718</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#Kiehn94</url>
<abstract>For CCS [15] several noninterleaving semantics have been proposed among which causal bisimulation [9] and location equivalence [6] play a central role. To unify these two approaches this paper introduces a new transition system based onlocal andglobal causes. Bisimulation equivalence is parameterized by a functionf which evaluates the information on causes provided by the transitions. Appropriate instantiations off yield characterizations of causal bisimulations and location equivalence.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178730</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/BermanPR89">
<author>A. Michael Berman</author>
<author>Marvin C. Paull</author>
<author>Barbara G. Ryder</author>
<title>Proving Relative Lower Bounds for Incremental Algorithms.</title>
<pages>665-683</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta27.html#BermanPR89</url>
<abstract>A general method that permits simple proofs of relative lower bounds for incremental update algorithms is presented. This method is applied to classify functions by relative lower bounds. We demonstrate our technique by bounding a number of incremental algorithms drawn from various domains. The method described expands upon work by Paull, Berman, and Cheng [PCB] and generalizes a result of Even and Gazit [EG]. Our results have interesting implications with respect to the optimality of an incremental algorithm previously developed by Ryder in [R, RP2]. Perhaps most importantly, the proof method and function classification suggest which types of problems are likely to yield good incremental algorithms (i.e., of lower complexity) and which cannot be improved by an incremental approach.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00259471</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Kandzia73"> 
<author>Peter Kandzia</author>
<title>Zur Theorie der Partiell-linearen Realisierungen endlicher Automaten</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>253-282</pages>
<url>db/journals/acta/acta2.html#Kandzia73</url>
</article>


<article mdate="2003-11-25" key="journals/acta/Sanders98">
<author>Beverly A. Sanders</author>
<title>Data Refinement of Mixed Specifications.</title>
<pages>91-129</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta35.html#Sanders98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035002/80350091.htm</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Silva03">
<author>Pedro V. Silva</author>
<title>A note on pure and p-pure languages.</title>
<pages>579-595</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>A variation of first order logic with variables for exponents is developed to solve some problems in the setting of rational languages on the free monoid, implying in particular algorithms for purity and p-purity. This same problem is addressed for the case of rational free group languages, and characterizations of the rational subsets of \(\mathbb{N}\) involved are also obtained.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0107-x</ee>
<url>db/journals/acta/acta39.html#Silva03</url>
</article>
<article mdate="2013-08-30" key="journals/acta/Hesselink13a">
<author>Wim H. Hesselink</author>
<title>A distributed resource allocation algorithm for many processes.</title>
<pages>297-329</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>Resource allocation is the problem that a process may enter a critical section CS of its code only when its resource requirements are not in conflict with those of other processes in their critical sections. For each execution of CS, these requirements are given anew. In the resource requirements, levels can be distinguished, such as e.g. read access or write access. We allow unboundedly many processes that communicate by reliable asynchronous messages and have finite memory. A simple starvation-free solution is presented. Processes only wait for one another when they have conflicting resource requirements. The correctness of the solution is argued with invariants and temporal logic. It has been verified with the proof assistant PVS.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0181-7</ee>
<url>db/journals/acta/acta50.html#Hesselink13a</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ramarao89">
<author>K. V. S. Ramarao</author>
<title>Complexity of Distributed Commit Protocols.</title>
<pages>577-595</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta26.html#Ramarao89</url>
<abstract>Implementation of atomic actions in a distributed system in the presence of fail-stop failures is investigated. Worst case time and message complexities of the protocols realizing this are studied on complete graphs, rings, trees, and arbitrary graphs. Two modes of communication are considered — point-to-point and broadcast. Individual lower and upper bounds on time and messages are presented and the simultaneous achievability of the optimum message and time bounds is shown impossible in all the interesting cases.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263581</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/ElmasryF08">
<author>Amr Elmasry</author>
<author>Michael L. Fredman</author>
<title>Adaptive sorting: an information theoretic perspective.</title>
<pages>33-42</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We present two algorithms that are near optimal with respect to the number of inversions present in the input. One of the algorithms is a variation of insertion sort, and the other is a variation of merge sort. The number of comparisons performed by our algorithms, on an input sequence of length n that has I inversions, is at most \(n\,{\rm log}_{2} (\frac{I}{n} + 1) + O(n)\) . Moreover, both algorithms have implementations that run in time \(O(n\,{\rm log}_{2} (\frac{I}{n} + 1)\,+\,n)\) . All previously published algorithms require at least \(cn\,{\rm log}_{2} (\frac{I}{n} + 1)\) comparisons for some c > 1.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0061-0</ee>
<url>db/journals/acta/acta45.html#ElmasryF08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HehnerGM88">
<author>Eric C. R. Hehner</author>
<author>Lorene E. Gupta</author>
<author>Andrew J. Malton</author>
<title>Erratum: Predicative Methodology.</title>
<pages>285</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#HehnerGM88</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299637</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Topor79">
<author>Rodney W. Topor</author>
<title>The Correctness of the Schorr-Waite List Marking Algorithm.</title>
<pages>211-221</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Topor79</url>
<abstract>This paper presents a relatively simple proof of a nontrivial algorithm for marking all the nodes of a list structure. The proof separates properties of the algorithm from properties of the data on which it operates and is a significant application of the method of “intermittent assertions”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289067</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikK86">
<author>Karel Culik II</author>
<author>Juhani Karhum&auml;ki</author>
<title>Synchronizable Deterministic Pushdown Automata and the Decidability of their Equivalence.</title>
<pages>597-605</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#CulikK86</url>
<abstract>The notion of synchronized and synchronizable deterministic pushdown automata (DPDA's) is introduced. It is shown that the equivalence of two synchronized and even of synchronizable DPDA's can be tested. It is conjectured that every two equivalent DPDA's are synchronizable. It is also shown that the equivalence of two deterministic pushdown transducers whose underlying DPDA's are synchronized can be tested.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288472</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EiterM97">
<author>Thomas Eiter</author>
<author>Heikki Mannila</author>
<title>Distance Measures for Point Sets and their Computation.</title>
<pages>109-133</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta34.html#EiterM97</url>
<abstract>We consider the problem of measuring the similarity or distance between two finite sets of points in a metric space, and computing the measure. This problem has applications in, e.g., computational geometry, philosophy of science, updating or changing theories, and machine learning. We review some of the distance functions proposed in the literature, among them the minimum distance link measure, the surjection measure, and the fair surjection measure, and supply polynomial time algorithms for the computation of these measures. Furthermore, we introduce the minimum link measure, a new distance function which is more appealing than the other distance functions mentioned. We also present a polynomial time algorithm for computing this new measure. We further address the issue of defining a metric on point sets. We present the metric infimum method that constructs a metric from any distance functions on point sets. In particular, the metric infimum of the minimum link measure is a quite intuitive. The computation of this measure is shown to be in NP for a broad class of instances; it is NP-hard for a natural problem class.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050075</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RamirezTM82">
<author>Ra&uacute;l J. Ram&iacute;rez</author>
<author>Frank Wm. Tompa</author>
<author>J. Ian Munro</author>
<title>Optimum Reorganization Points for Arbitrary Database Costs.</title>
<pages>17-30</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#RamirezTM82</url>
<abstract>The performance deterioration caused by updates to databases or data structures can be overcome by reorganizing the structure from time to time. In previous work, optimal reorganization intervals were determined for linearly increasing deterioration costs and linearly growing reorganization cost. To date only heuristics have been available for non-linear costs, and no work has been published on optimal solutions.This paper extends previous results by identifying the reorganization points problem as a shortest route problem and by providing a dynamic programming algorithm to find optimal reorganization points when reorganization and deterioration costs are arbitrary. It is shown that our method usesθ(T **2) basic operations andθ(T) space, whereT represents the database lifetime. Furthermore, we note that no algorithm can solve this problem in significantly less time or space. Examples involving linear and non-linear costs are presented and discussed. Finally, the algorithm is modified to find the optimal sequence of reorganizations to be applied in situations where partial reorganizations are possible.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625278</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GelenbeLP74"> 
<author>Erol Gelenbe</author>
<author>Jacques Lenfant</author>
<author>Dominique Potier</author>
<title>Analyse d'un algorithme de gestion simultan&eacute;e M&eacute;moire centrale - Disque de pagination.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>321-345</pages>
<url>db/journals/acta/acta3.html#GelenbeLP74</url>
<abstract>Commonly used memory management strategies in a paged environment optimize separately the page-fault rate (by proper choice of a replacement algorithm) and the response time of the paging drum (by a shortest-access-time-first discipline with multiple sectors). In this paper we consider replacement strategies which attempt to maximize useful CPU utilisation and hence throughput by choosing the page to be replaced on the basis of its probability of reference as well as on the rapidity with which the page can be removed from main memory, assuming that a fixed-head disk or drum is used as a secondary memory. An analysis of the approach is given using a mathematical model. Analytical results for the gain in CPU utilisation are obtained under mono-programming and numerical examples are presented illustrating the effects of variation of program behaviour and of variants of the replacement strategy.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263587</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Pritchard91">
<author>Paul Pritchard</author>
<title>Opportunistic Algorithms for Eliminating Supersets.</title>
<pages>733-754</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta28.html#Pritchard91</url>
<abstract>The main problem tackled in this paper is that of finding each set in a given collection that has no proper subset in the collection. Starting with a solution that uses a quadratic (in the size of the collection) number of subset tests, solutions are developed that are opportunistic in the sense of running significantly faster for certain classes of input (such as when most sets are small), but without running slower on other input. They are based on an opportunistic algorithm for the fundamental problem of finding an element common to two ordered sequences. Methodological issues are emphasized throughout.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01261654</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/TipleaMA01">
<author>Ferucio Laurentiu Tiplea</author>
<author>Erkki M&auml;kinen</author>
<author>Corina Apachite</author>
<title>Synchronized extension systems.</title>
<pages>449-465</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037006/10370449.htm</ee>
<url>db/journals/acta/acta37.html#TipleaMA01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BauerEPP81">
<author>Friedrich L. Bauer</author>
<author>Andrei P. Ershov</author>
<author>Manfred Paul</author>
<author>Alan J. Perlis</author>
<title>Klaus Samelson.</title>
<pages>1-2</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#BauerEPP81</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00269806</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BabichJ78a">
<author>Wayne A. Babich</author>
<author>Mehdi Jazayeri</author>
<title>The Method of Attributes for Data Flow Analysis: Part II. Demand Analysis.</title>
<pages>265-272</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#BabichJ78a</url>
<abstract>The importance of producing data flow information on demand is discussed. The method of attributes is applied to the demand analysis of live variables.Part I of this paper described the method of attributes, which is a technique for high level data flow analysis. In that paper, the method was applied to two well-known problems: analysis of dead variables and analysis of available expressions. Both of these analyses are called exhaustive because they uncover information for all program points.In this part, we apply the method of attributes to a problem in demand data flow analysis.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264320</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SloanB96">
<author>Robert H. Sloan</author>
<author>Ugo A. Buy</author>
<title>Reduction Rules for Time Petri Nets.</title>
<pages>687-706</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#SloanB96</url>
<abstract>The goal of net reduction is to increase the effectiveness of Petri-netbased real-time program analysis. Petri-net-based analysis, like all reachabilitybased methods, suffers from the state explosion problem. Petri net reduction is one key method for combating this problem.In this paper, we extend several rules for the reduction of ordinary Petri nets to work with time Petri nets. We introduce a notion of equivalence among time Petri nets, and prove that our reduction rules yield equivalent nets. This notion of equivalence guarantees that crucial timing and concurrency properties are preserved.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036471</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GoldreichS87">
<author>Oded Goldreich</author>
<author>Liuba Shrira</author>
<title>Electing a Leader in a Ring with Link Failures.</title>
<pages>79-91</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#GoldreichS87</url>
<abstract>We investigate the message complexity of electing a leader in a ring of asynchronous processors. Our work deviates from the previous works on electing a leader in that we consider the effect of link failures. A link is said to fail if some message sent through it never reaches its destination. We distinguish the case where n is known from the case n unknown. Our main result is a O(n · log n) algorithm for electing a leader on a n-processor ring (the case n is known).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290707</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DiazST96">
<author>Josep D&iacute;az</author>
<author>Maria J. Serna</author>
<author>Jacobo Tor&aacute;n</author>
<title>Parallel Approximation Schemes for Problems on Planar Graphs.</title>
<pages>387-408</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta33.html#DiazST96</url>
<abstract>This paper describes a technique to obtain NC Approximations Schemes for the Maximum Independent Set in planar graphs and related optimization problems. The strategy consists in decomposing the graph into K-outerplanar subgraphs and solve for each K-outerplanar using tree contraction techniques.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050049</ee>
</article>
<article mdate="2013-03-07" key="journals/acta/BettiniDS13">
<author>Lorenzo Bettini</author>
<author>Ferruccio Damiani</author>
<author>Ina Schaefer</author>
<title>Compositional type checking of delta-oriented software product lines.</title>
<pages>77-122</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Delta-oriented programming is a compositional approach to flexibly implementing software product lines. A product line is represented by a code base and a product line declaration. The code base consists of a set of delta modules specifying modifications to object-oriented programs. A particular product in a delta-oriented product line is generated by applying the modifications contained in the suitable delta modules to the empty program. The product-line declaration provides the connection of the delta modules with the product features. This separation increases the reusability of delta modules. In this paper, we provide a foundation for compositional type checking of delta-oriented product lines of Java programs by presenting a minimal core calculus for delta-oriented programming. The calculus is equipped with a constraint-based type system that allows analyzing each delta module in isolation, such that the results of the analysis can be reused. By relying only on the analysis results for the delta modules and on the product line declaration, it is possible to establish whether all the products of the product line are well typed according to the fragment of the Java type system modeled by the calculus.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0173-z</ee>
<url>db/journals/acta/acta50.html#BettiniDS13</url>
</article>
<article mdate="2006-02-17" key="journals/acta/ChengD00">
<author>T. C. Edwin Cheng</author>
<author>Qing Ding</author>
<title>Single Machine Scheduling with Deadlines and Increasing Rates of Processing Times.</title>
<pages>673-692</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360673.htm</ee>
<url>db/journals/acta/acta36.html#ChengD00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BaccelliF82">
<author>Fran&ccedil;ois Baccelli</author>
<author>Thierry Fleury</author>
<title>On Parsing Arithmetic Expressions in a Multiprocessing Environment.</title>
<pages>287-310</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#BaccelliF82</url>
<abstract>Some decomposition of the parsing of the sentences of context-free grammars into sequences of independant sub-tasks is proposed. An example of grammar is presented, for which this decomposition provides an efficient parser for a multiprocessing environment. The average speed-up resulting from the parallelization of the parser of an arithmetic infix grammar is evaluated by means of probabilistic models and real world measurements.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264355</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Devroye84">
<author>Luc Devroye</author>
<title>A Probabilistic Analysis of the Height of Tries and of the Complexity of Triesort.</title>
<pages>229-237</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Devroye84</url>
<abstract>We consider binary tries formed by using the binary fractional expansions of X 1, ...,X n, a sequence of independent random variables with common density f on [0,1]. For H n, the height of the trie, we show that either E(Hn)∼21og2 n or E(Hn)=∞ for all n≧2 according to whether ∫f 2(x)dx is finite or infinite. Thus, the average height is asymptotically twice the average depth (which is ∼log2 n when ∫f 2(x)dx>∞). The asymptotic distribution of H n is derived as well.If f is square integrable, then the average number of bit comparisons in triesort is nlog2 n+0(n), and the average number of nodes in the trie is 0(n).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264248</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Atanasiu92">
<author>Adrian Atanasiu</author>
<title>A Class of Coders Based on GSM.</title>
<pages>779-791</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta29.html#Atanasiu92</url>
<abstract>Using the definition of gsm and finite translators, a new class of coders is proposed. In the first part it is shown that ifM is a weakly-deterministic coder, thenM −1 is also a coder. In the second part, this class of coders is used for solving a problem of secrets transmission.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191896</ee>
</article>
<article mdate="2005-04-25" key="journals/acta/KlonowskaLLS05">
<author>Kamilla Klonowska</author>
<author>H&aring;kan Lennerstad</author>
<author>Lars Lundberg</author>
<author>Charlie Svahnberg</author>
<title>Optimal recovery schemes in fault tolerant distributed computing.</title>
<pages>341-365</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>Clusters and distributed systems offer fault tolerance and high performance through load sharing. When all n computers are up and running, we would like the load to be evenly distributed among the computers. When one or more computers break down, the load on these computers must be redistributed to other computers in the system. The redistribution is determined by the recovery scheme. The recovery scheme is governed by a sequence of integers modulo n. Each sequence guarantees minimal load on the computer that has maximal load even when the most unfavorable combinations of computers go down. We calculate the best possible such recovery schemes for any number of crashed computers by an exhaustive search, where brute force testing is avoided by a mathematical reformulation of the problem and a branch-and-bound algorithm. The search nevertheless has a high complexity. Optimal sequences, and thus a corresponding optimal bound, are presented for a maximum of twenty one computers in the distributed system or cluster.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0161-7</ee>
<url>db/journals/acta/acta41.html#KlonowskaLLS05</url>
</article>
<article mdate="2014-12-22" key="journals/acta/HinrichsNS92">
<author>Klaus H. Hinrichs</author>
<author>J&uuml;rg Nievergelt</author>
<author>Peter Schorn</author>
<title>An All-Round Sweep Algorithm for 2-Dimensional Nearest-Neighbor Problems.</title>
<pages>383-394</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta29.html#HinrichsNS92</url>
<abstract>We present a simple, efficient, robust plane-sweep algorithm that solves 2-dimensional nearest-neighbor problems in asymptotically optimal timeO(n logn). A “foolproof” implementation guarantees an exact result at the cost of using triple-precision integer arithmetic at some key steps.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178779</ee>
</article>
<article mdate="2015-06-08" key="journals/acta/LuttgenVF15">
<author>Gerald L&uuml;ttgen</author>
<author>Walter Vogler</author>
<author>Sascha Fendrich</author>
<title>Richer interface automata with optimistic and pessimistic compatibility.</title>
<pages>305-336</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>Modal transition systems are a popular semantic underpinning of interface theories, such as Nyman et al.’s IOMTS and Bauer et al.’s MIO, which facilitate component-based reasoning for concurrent systems. Our interface theory MIA repaired a compositional flaw of IOMTS-refinement and introduced a conjunction operator. In this paper, we first modify MIA to properly deal with internal computations including internal must-transitions, which were largely ignored already in IOMTS. We then study a MIA variant that adopts MIO’s pessimistic—rather than IOMTS’ optimistic—view on component compatibility and define, for the first-time in a pessimistic, non-deterministic setting, conjunction and disjunction on interfaces. For both the optimistic and pessimistic MIA variant, we also discuss mechanisms for extending alphabets when refining interfaces, which is a desired feature for perspective-based specification. We illustrate our advancements via a small example.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0211-0</ee>
<url>db/journals/acta/acta52.html#LuttgenVF15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HakalaK97">
<author>Ismo Hakala</author>
<author>Juha Kortelainen</author>
<title>On the System of word equations x^i_1 x^i_2 ... x^i_m = y^i_1 y^i_2 ...y^i_n (i=1, 2, ...) in a Free Monoid.</title>
<pages>217-230</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta34.html#HakalaK97</url>
<abstract> It is proved that the system of word equations x i 1=y i 1 y i 2…y i n , i=1, 2,…, ⌈n/2⌉ +1, has only cyclic solutions. Some sharpenings concerning the cases n=5, 7 and n≥9 are derived as well as results concerning the general system of equations x i 1 x i 2…x i m =y i 1 y i 2…y i n , i=1, 2,… . Applications to test sets of certain bounded languages are considered.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050081</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MeersmanR78">
<author>Robert Meersman</author>
<author>Grzegorz Rozenberg</author>
<title>Two-Level Meta-Controlled Substitution Grammars.</title>
<pages>323-339</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#MeersmanR78</url>
<abstract>A language-generating mechanism, inspired on the two-level van Wijngaarden syntax for Algol 68, is considered. Its language generating properties are studied and compared to those of well-known classical systems and grammars. The new mechanism is called a 2 MSG, for “two-level metacontrolled substitution grammar.”</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265677</ee>
</article>
<article mdate="2011-11-25" key="journals/acta/ChakrabartiGWW11">
<author>Amit Chakrabarti</author>
<author>Venkatesan Guruswami</author>
<author>Andrew Wirth</author>
<author>Anthony Wirth</author>
<title>The query complexity of estimating weighted averages.</title>
<pages>417-426</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The query complexity of estimating the mean of some [0, 1] variables is understood. Inspired by some work by Carterette et al. on evaluating retrieval systems, and by Moffat and Zobel’s new proposal for such evaluation, we examine the query complexity of weighted average calculation. In general, determining an answer within accuracy \({\varepsilon}\), with high probability, requires \({\Omega(\varepsilon^{-2})}\) queries, as the mean is a special case. There is a matching upper bound for the weighted mean. If the weights are a normalized prefix of a divergent series, the same result holds. However, if the weights follow a geometric sequence, a sample of size \({\Omega(\log (1/\varepsilon))}\) suffices. Our principal contribution is the investigation of power-law sequences of weights. We show that if the ith largest weight is proportional to i −p , for p > 1, then the query complexity is in \({\Omega(\varepsilon^{2/(1-2p)})}\).</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0145-8</ee>
<url>db/journals/acta/acta48.html#ChakrabartiGWW11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Chapman84">
<author>N. P. Chapman</author>
<title><i> LALR </i> (1, 1) Parser Generation for Regular Right Part Grammars.</title>
<pages>29-45</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Chapman84</url>
<abstract>Commonly used extensions to BNF can be modelled by the formalism of regular right part grammars. A method for building LR parsers for such grammars is given, which works by first constructing an LR(0) automaton and then augmenting it with readback machines constructed to recognize the reverse of the state sequences leading to a reduction. The state sequences which will be accepted by such readback machines are also the sequences which link reductions to their lookback states (states in which the parser may be re-started after the reduction), which are needed in order to compute LALR(1) lookahead sets using the algorithm devised recently by DeRemer and Pennello.An algorithm is presented which computes these lookback states using the structure of the LR(0) automaton, and it is shown how this can easily be extended to build readback machines at the same time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289138</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SchneiderE76">
<author>Hans J&uuml;rgen Schneider</author>
<author>Hartmut Ehrig</author>
<title>Grammars on Partial Graphs.</title>
<pages>297-316</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#SchneiderE76</url>
<abstract>The concept of Chomsky-grammars is generalized to graph-grammars; the “gluing” of graphs is defined by a pushout-construction. In the present paper, we allow the left-hand and right-hand side of a production to be partial graphs, i.e. graphs in which there may be edges without a source or target node. A necessary and sufficient condition for applicability of productions is given. Furthermore, convex graph-grammars are studied.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288659</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/VegaPS98">
<author>Wenceslas Fernandez de la Vega</author>
<author>Vangelis Th. Paschos</author>
<author>Andreas Stafylopatis</author>
<title>Average-Case Complexity for the Execution of Recursive Definitions on Relational Databases.</title>
<pages>211-243</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta35.html#VegaPS98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035003/80350211.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Marriott93">
<author>Kim Marriott</author>
<title>Frameworks for Abstract Interpretation.</title>
<pages>103-129</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta30.html#Marriott93</url>
<abstract>Abstract interpretation theory provides a semantic foundation for dataflow analysis of programs by formalizing the relationship between analysis and semantics. In the original theory for abstract interpretation, due to Cousot and Cousot, this relationship was given in terms of an adjoined pair of functions. One function, called the abstraction function, mapped data to their best description, while the second function, called the concretization function, mapped descriptions to the largest data object they described. Since this time, however, a number of other “frameworks” for abstract interpretation have been developed, differing in how the descriptions are related to the actual data used in computation. For instance, one framework uses only abstraction functions, another uses only concretization functions, while yet another allows an arbitrary approximation relation. We illustrate that each of these frameworks has certain advantages and limitations. This motivates our development and study of a general framework which encompasses these other approaches. We examine this framework with regard to three questions: when does approximation lift from base functions to all expressions; when is approximation transitive; and when is there an optimal approximation and how can it be inferred? Answers to these questions are not only interesting in the context of our framework but also provide a better understanding of the other frameworks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178576</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LehmannL93">
<author>Thomas Lehmann</author>
<author>Jacques Loeckx</author>
<title>OBSCURE: A Specification Language for Abstract Data Types.</title>
<pages>303-350</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta30.html#LehmannL93</url>
<abstract>OBSCURE is a specification language for abstract data types. It differs from classical specification languages by handling models rather than theories. The goal of the paper is to present a complete and precise description ofOBSCURE.First, the different language constructs are illustrated by the help of examples. The syntax and semantics of the language are then defined formally. The consistency of these definitions is stated in two theorems. Next, a set of formulas is associated with each specification. A further theorem states that these formulas guarantee the persistency or, more precisely, the absence of logical inconsistencies. A discussion of further language concepts-such as parameterization and strong typing-follows. Finally, a methodology for the development of software with the help ofOBSCURE is sketched and some practical results are presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209709</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GareyG74"> 
<author>M. R. Garey</author>
<author>Ronald L. Graham</author>
<title>Performance Bounds on the Splitting Algorithm for Binary Testing.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>347-355</pages>
<url>db/journals/acta/acta3.html#GareyG74</url>
<abstract>In machine fault-location, medical diagnosis, species identification, and computer decisionmaking, one is often required to identify some unknown object or condition, belonging to a known set of M possibilities, by applying a sequence of binary-valued tests, which are selected from a given set of available tests. One would usually prefer such a testing procedure which minimizes or nearly minimizes the expected testing cost for identification. Existing methods for determining a minimal expected cost testing procedure, however, require a number of operations which increases exponentially with M and become infeasible for solving problems of even moderate size. Thus, in practice, one instead uses fast, heuristic methods which hopefully obtain low cost testing procedures, but which do not guarantee a minimal cost solution. Examining the important case in which all M possibilities are equally likely, we derive a number of cost-bounding results for the most common heuristic procedure, which always applies next that test yielding maximum information gain per unit cost. In particular, we show that solutions obtained using this method can have expected cost greater than an arbitrary multiple of the optimal expected cost.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263588</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Marque-Pucheu83">
<author>G. Marque-Pucheu</author>
<title>Rational Set of Trees and the Algebraic Semantics of Logic Programming.</title>
<pages>249-260</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Marque-Pucheu83</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01257085</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MaurerN80">
<author>Hermann A. Maurer</author>
<author>Maurice Nivat</author>
<title>Rational Bijection of Rational Sets.</title>
<pages>365-378</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#MaurerN80</url>
<abstract>In this paper we initiate the study of rational bijections, that is of rational transductions which are bijections of a rational (=regular) set R onto a rational set S. We present a complete and easily decidable characterization of the existence of a rational bijection between two given rational sets.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288770</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Conradi77"> 
<author>Reidar Conradi</author>
<title>Some Comments on "Concurrent Readers and Writers".</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>335-340</pages>
<url>db/journals/acta/acta8.html#Conradi77</url>
<abstract>A more compact and efficient algorithm for synchronization of concurrent readers and writers is presented, and which grants writers effective priority over readers.A synchronization primitive P *, which only decrements a semaphore value by one, is also described.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271342</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/BreitbartR74a"> 
<author>Yuri Breitbart</author>
<author>Allen Reiter</author>
<title>A Branch-and-Bound Algorithm to Obtain an Optimal Evaluation Tree for Monotonic Boolean Functions.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1975</year> 
<pages>311-319</pages>
<url>db/journals/acta/acta4.html#BreitbartR74a</url>
<abstract>For monotonic Boolean functions, a branch-and-bound algorithm is given for constructing an optimal decision tree (sequential evaluation procedure). The tree is optimal in minimizing the average number of variables which need to be examined.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289614</ee>
</article>

<article mdate="2015-01-08" key="journals/acta/GanapathiF87">
<author>Mahadevan Ganapathi</author>
<author>Charles N. Fischer</author>
<title>Integrating Code Generation and Peephole Optimization.</title>
<pages>85-109</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta25.html#GanapathiF87</url>
<abstract>Peephole optimization when integrated with automatic code generation into a uniform framework has significant advantages in the specification and implementation of efficient compiler back-ends. Attribute grammars provide a framework for expression of machine-specific code optimizations. We present a grammar-driven peephole optimization algorithm that is particularly well suited to attributed-parsing code generators. Integration via semantic attributes corrects interrelated phase-ordering problems and produces a faster and smaller compiler back-end.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF00268846</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FraenkelMP83">
<author>Aviezri S. Fraenkel</author>
<author>Moshe Mor</author>
<author>Yehoshua Perl</author>
<title>Is Text Compression by Prefixes and Suffixes Practical?</title>
<pages>371-389</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#FraenkelMP83</url>
<abstract>One approach to text compression is to replace high-frequency variable-length fragments of words by fixed-length codes pointing to a compression table containing these high-frequency fragments. It is shown that the problem of optimal fragment compression is NP-hard even if the fragments are restricted to prefixes and suffixes. This seems to be a simplest fragment compression problem which is NP-hard, since a polynomial algorithm for compressing by prefixes only (or suffixes only) has been found recently. Various compression heuristics based on using both prefixes and suffixes have been tested on large Hebrew and English texts. The best of these heuristics produce a net compression of some 37% for Hebrew and 45% for English using a prefix/suffix compression table of size 256.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264280</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rohrich80">
<author>Johannes R&ouml;hrich</author>
<title>Methods for the Automatic Construction of Error Correcting Parsers.</title>
<pages>115-139</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Rohrich80</url>
<abstract>Methods for the automatic construction of error handling parsers are presented. The resulting parsers are capable of correcting all syntax errors by insertion and/or deletion of terminal symbols to the right of the error location. Thus, the output of the parser always corresponds to a syntactically valid program. This contributes significantly to the reliability and robustness of a compiler. The speed of parsing correct parts of a program is not affected by the presence of the error handling capability. The correction algorithm is easy to implement. Apart from the parsing tables only one character per parser state is required to control the correction process. The method is applicable to a wide class of stack automata including LL(k), LR(k), SLR(k), and LALR(k) parsers. It is shown that for LL(k) grammars error correction can be obtained as a byproduct of the canonical LL(k) parser generation. A similar result can be obtained for LR(k) grammars if the parser generator is slightly modified. The method has been successfully added to an LALR(1) parser generator.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263989</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kastens80">
<author>Uwe Kastens</author>
<title>Ordered Attributed Grammars.</title>
<pages>229-256</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Kastens80</url>
<abstract>Ordered attributed grammars are defined as a large subclass of semantically well-defined attributed grammars proposed by Knuth. An attributed grammar is ordered if for each symbol a partial order over the associated attributes can be given, such that in any context of the symbol the attributes are evaluable in an order which includes that partial order. The definition does not refer to a predefined strategy for attribute evaluation, e.g. several passes from left to right. For each attributed grammar evaluable by any predefined evaluation strategy such an order exists. The ordering property can be checked by an algorithm, which depends polynomially in time on the size of the input grammar. “Visit-sequences” are computed from the attribute dependencies given by an ordered attributed grammar. They describe the control flow of an algorithm for attribute evaluation which can be part of an automatically generated compiler.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288644</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/LundbergL99">
<author>Lars Lundberg</author>
<author>H&aring;kan Lennerstad</author>
<title>Optimal Bounds on the Gain of Permitting Dynamic Allocation of Communication Channels in Distributed Computing.</title>
<pages>425-446</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036006/90360425.htm</ee>
<url>db/journals/acta/acta36.html#LundbergL99</url>
</article>
<article mdate="2006-11-22" key="journals/acta/CarayolM06">
<author>Arnaud Carayol</author>
<author>Antoine Meyer</author>
<title>Linearly bounded infinite graphs.</title>
<pages>265-292</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Linearly bounded Turing machines have been mainly studied as acceptors for context-sensitive languages. We define a natural class of infinite automata representing their observable computational behavior, called linearly bounded graphs. These automata naturally accept the same languages as the linearly bounded machines defining them. We present some of their structural properties as well as alternative characterizations in terms of rewriting systems and context-sensitive transductions. Finally, we compare these graphs to rational graphs, which are another class of automata accepting the context-sensitive languages, and prove that in the bounded-degree case, rational graphs are a strict sub-class of linearly bounded graphs.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0022-z</ee>
<url>db/journals/acta/acta43.html#CarayolM06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Tompa80">
<author>Frank Wm. Tompa</author>
<title>A Practical Example of the Specification of Abstract Data Types.</title>
<pages>205-224</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Tompa80</url>
<abstract>The algebra of quotient relations, a relationally complete set of operations for data base applications, is formally defined in terms of the algebraic specification technique. The process of constructing an algebraic specification for a data type is described in order that future formal definitions are more easily derived. Several improvements to current algebraic presentation techniques are also introduced.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288642</ee>
</article>
<article mdate="2009-05-20" key="journals/acta/BoassonN73"> 
<author>Luc Boasson</author>
<author>Maurice Nivat</author>
<title>Sur diverses familles de langages ferm&eacute;es par transductions rationelle</title>
<pages>180-188</pages>
<year>1973</year> 
<volume>2</volume> 
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta2.html#BoassonN73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/IbarraK74"> 
<author>Oscar H. Ibarra</author>
<author>Chul E. Kim</author>
<title>On 3-Head Versus 2-Head Finite Automata.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>193-200</pages>
<url>db/journals/acta/acta4.html#IbarraK74</url>
<abstract>A direct proof is given that shows that (one-way) 3-head deterministic finite automata are computationally more powerful than 2-head finite automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288748</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LeavensW95"> 
<author>Gary T. Leavens</author>
<author>William E. Weihl</author>
<title>Specification and Verification of Object-Oriented Programs Using Supertype Abstraction.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>8</number>
<year>1995</year> 
<pages>705-778</pages>
<url>db/journals/acta/acta32.html#LeavensW95</url>
<abstract>We present a formal specification language and a formal verification logic for a simple object-oriented programming language. The language is applicative and statically typed, and supports subtyping and message-passing. The verification logic relies on a behavioral notion of subtyping that captures the intuition that a subtype behaves like its supertypes. We give a formal definition for legal subtype relations, based on the specified behavior of objects, and show that this definition is sufficient to ensure the soundness of the verification logic. The verification logic reflects the way programmers reason informally about object-oriented programs, in that it allows them to use static type information, which avoids the need to consider all possible run-time subtypes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178658</ee>
</article>


<article mdate="2014-03-10" key="journals/acta/Ranzato14">
<author>Francesco Ranzato</author>
<title>An efficient simulation algorithm on Kripke structures.</title>
<pages>107-125</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>A number of algorithms for computing the simulation preorder (and equivalence) on Kripke structures are available. Let \(\varSigma \) denote the state space, \({\rightarrow }\) the transition relation and \(P_{\mathrm {sim}}\) the partition of \(\varSigma \) induced by simulation equivalence. While some algorithms are designed to reach the best space bounds, whose dominating additive term is \(|P_{\mathrm {sim}}|^2\), other algorithms are devised to attain the best time complexity \(O(|P_{\mathrm {sim}}||{\rightarrow }|)\). We present a novel simulation algorithm which is both space and time efficient: it runs in \(O(|P_ {\mathrm {sim}}|^2 \log |P_{\mathrm {sim}}| + |\varSigma |\log |\varSigma |)\) space and \(O(|P_{\mathrm {sim}}||{\rightarrow }|\log |\varSigma |)\) time. Our simulation algorithm thus reaches the best space bounds while closely approaching the best time complexity.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0195-9</ee>
<url>db/journals/acta/acta51.html#Ranzato14</url>
</article>
<article mdate="2007-09-11" key="journals/acta/HalavaH07">
<author>Vesa Halava</author>
<author>Mika Hirvensalo</author>
<title>Improved matrix pair undecidability results.</title>
<pages>191-205</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>We improve the undecidability bounds for problems involving two integer matrices by showing that Scalar Reachability, Zero in the Right Upper Corner, Vector Reachability, and Zero in the Left Upper Corner are undecidable for dimensions of 9, 10, 11, and 13, respectively. Problems Scalar Reachability, Zero in the Right Upper Corner, and Vector Reachability were previously known undecidable for dimensions 18, 18, and 16, respectively.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0047-y</ee>
<url>db/journals/acta/acta44.html#HalavaH07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Rollik80">
<author>Hans-Anton Rollik</author>
<title>Automaten in planaren Graphen.</title>
<pages>287-298</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Rollik80</url>
<abstract>For any finite set of automata there is a planar graph which the automata together cannot search.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288647</ee>
</article>
<article mdate="2012-09-23" key="journals/acta/KouvatsosA88">
<author>Demetres D. Kouvatsos</author>
<author>John Almond</author>
<title>Maximum Entropy Two-Station Cyclic Queues with Multiple General Servers.</title>
<pages>241-267</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#KouvatsosA88</url>
<abstract>The efficient implementation and extension of various approximate methods for general queueing networks require the study of two-station cyclic queues. In this paper maximum entropy formalism is used to analyse two-station cyclic queues with multiple general servers and a fixed number of jobs. New robust “one step” recursions for the queue length distribution are derived and asymptotic connections to infinite capacity queues are established. Links with Birth-Death and global balance solutions are determined and extensions to load dependent servers with Bernoulli feedback are presented. Numerical examples provide useful information on how critically system behaviour is affected by the distributional form of service times and simple bounds for typical performance measures such as throughout and mean queue length are defined. Moreover, the utility of the work as a “building block” for the approximate analysis of a general central server model is demonstrated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299634</ee>
<note>Errata: Acta Inf. 26, 501 and 787</note>
</article>
<article mdate="2005-01-25" key="journals/acta/GrigorievW04">
<author>Alexander Grigoriev</author>
<author>Gerhard J. Woeginger</author>
<title>Project scheduling with irregular costs: complexity, approximability, and algorithms.</title>
<pages>83-97</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>We address a generalization of the classical discrete time-cost tradeoff problem where the costs are irregular and depend on the starting and the completion times of the activities. We present a complete picture of the computational complexity and the approximability of this problem for several natural classes of precedence constraints. We prove that the problem is NP-hard and hard to approximate, even in case the precedence constraints form an interval order. For precedence constraints with bounded height, there is a complexity jump from height one to height two: For height one, the problem is polynomially solvable, whereas for height two, it is NP-hard and APX-hard. Finally, the problem is shown to be polynomially solvable if the precedence constraints have bounded width or are series parallel.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0150-2</ee>
<url>db/journals/acta/acta41.html#GrigorievW04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SannellaT88">
<author>Donald Sannella</author>
<author>Andrzej Tarlecki</author>
<title>Toward Formal Development of Programs from Algebraic Specifications: Implementations Revisited.</title>
<pages>233-281</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta25.html#SannellaT88</url>
<abstract>The program development process is viewed as a sequence of implementation steps leading from a specification to a program. Based on an elementary notion of refinement, two notions of implementation are studied: constructor implementations which involve a construction “on top of” the implementing specification, and abstractor implementations which additionally provide for abstraction from some details of the implemented specification. These subsume most formal notions of implementation in the literature. Both kinds of implementations satisfy a vertical composition and a (modified) horizontal composition property. All the definitions and results are shown to generalise to the framework of an arbitrary institution, and a way of changing institutions during the implementation process is introduced. All this is illustrated by means of simple concrete examples.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00283329</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/BordihnH06">
<author>Henning Bordihn</author>
<author>Markus Holzer</author>
<title>Programmed grammars and their relation to the LBA problem.</title>
<pages>223-242</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>We consider generating and accepting programmed grammars with bounded degree of non-regulation, that is, the maximum number of elements in success or in failure fields of the underlying grammar. In particular, it is shown that this measure can be restricted to two without loss of descriptional capacity, regardless of whether arbitrary derivations or left-most derivations are considered. Moreover, in some cases, precise characterizations of the linear bounded automaton problem in terms of programmed grammars are obtained. Thus, the results presented in this paper shed new light on some longstanding open problem in the theory of computational complexity.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0017-9</ee>
<url>db/journals/acta/acta43.html#BordihnH06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Zislis74"> 
<author>Paul M. Zislis</author>
<title>Semantic Decomposition of Computer Programs: An Aid to Program Testing.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>243-269</pages>
<url>db/journals/acta/acta4.html#Zislis74</url>
<abstract>Semantic decomposition results in a hierarchy of partitions which are small enough to be easily understood, and large enough to be meaningful to a program tester. Each partition results in the elimination of at least one local variable from consideration during error analysis, which further simplifies the testing process. Semantic decomposition reduces the complexity of the testing process, enhances the understandability of the program for the tester, and thus abstracts a program to a higher level. The decomposition yields a plan for hierarchical testing which, if followed conscientiously, should result in faster and more thorough testing for large or poorly structured programs. By reorganizing poorly structured programs into the modules indicated by semantic decomposition, an improved source level representation of the programs may be obtained.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288729</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LevinG81">
<author>Gary Levin</author>
<author>David Gries</author>
<title>A Proof Technique for Communicating Sequential Processes.</title>
<pages>281-302</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#LevinG81</url>
<abstract>Proof rules are presented for an extension of Hoare's Communicating Sequential Processes. The rules deal with total correctness; all programs terminate in the absence of deadlock. The commands send and receive are treated symmetrically, simplifying the rules and allowing send to appear in guards. Also given are sufficient conditions for showing that a program is deadlock-free. An extended example illustrates the use of the technique.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289266</ee>
</article>
<article mdate="2013-08-30" key="journals/acta/HalavaH13">
<author>Vesa Halava</author>
<author>Tero Harju</author>
<title>New proof for the undecidability of the circular PCP.</title>
<pages>331-341</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>We give simpler proof for the undecidability of the circular Post Correspondence Problem that was originally proved undecidable by Ruohonen (Acta Informatica 19:357–367, 1983). The key feature of our proof is the undecidability of the word problem of special semi-Thue systems where derivations are deterministic and reversible for words containing a single occurrence of a letter from a given set.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0183-5</ee>
<url>db/journals/acta/acta50.html#HalavaH13</url>
</article>
<article mdate="2003-11-25" key="journals/acta/RamonB01">
<author>Jan Ramon</author>
<author>Maurice Bruynooghe</author>
<title>A polynomial time computable metric between point sets.</title>
<pages>765-780</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037010/10370765.htm</ee>
<url>db/journals/acta/acta37.html#RamonB01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LatteuxLR85">
<author>Michel Latteux</author>
<author>B. Leguy</author>
<author>B. Ratoandromanana</author>
<title>The Family of One-Counter Languages is Closed Under Quotient.</title>
<pages>579-588</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta22.html#LatteuxLR85</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00267045</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/KariKLW03">
<author>Lila Kari</author>
<author>Stavros Konstantinidis</author>
<author>Elena Losseva</author>
<author>Geoff Wozniak</author>
<title>Sticky-free and overhang-free DNA languages.</title>
<pages>119-157</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>An essential step of any DNA computation is encoding the input data on single or double DNA strands. Due to the biochemical properties of DNA, complementary single strands can bind to one another forming double-stranded DNA. Consequently, data-encoding DNA strands can sometimes interact in undesirable ways when used in computations. It is crucial thus to analyze properties that guard against such phenomena and study sets of sequences that ensure that no unwanted bindings occur during any computation. This paper formalizes and investigates properties of DNA languages that guarantee their robusteness during computations. After defining and investigating several types of DNA languages possessing good encoding properties, such as sticky-free and overhang-free languages, we give algorithms for deciding whether regular DNA languages are invariant under bio-operations. We also give a method for constructing DNA languages that, in addition to being invariant and sticky-free, possess error-detecting properties. Finally, we present the results of running tests that check whether several known gene languages (the set of genes of a given organism) as well as the input DNA languages used in Adleman’s DNA computing experiment, have the defined properties.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0118-7</ee>
<url>db/journals/acta/acta40.html#KariKLW03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Franck78">
<author>Reinhold Franck</author>
<title>A Class of Linearly Parsable Graph Grammars.</title>
<pages>175-201</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Franck78</url>
<abstract>Specializing an existing graph grammar model we look in detail at node context-free graph grammars. With a slight generalization the parse trees for context-free Chomsky grammars can be used to describe derivations of these graph grammars.As shown already in former works the precedence graph grammars are defined as a subclass of context-free graph grammars by certain algebraic restrictions on the form of the rules. Then we can prove that every precedence grammar is unambiguous and additionally the reduction process in such a grammar read as replacement system is finite.The most important aim in defining the predence relations was a simple parsing method. This is realized because it is shown that the syntactic analysis for precedence graph grammars can be done in a time which linearly depends on the size of the input graph.The whole method has been implemented and a documentation is available.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289155</ee>
</article>
<article mdate="2011-02-16" key="journals/acta/KabirWB11">
<author>Md. Enamul Kabir</author>
<author>Hua Wang</author>
<author>Elisa Bertino</author>
<title>Efficient systematic clustering method for <i>k</i>-anonymization.</title>
<pages>51-66</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper presents a clustering (Clustering partitions record into clusters such that records within a cluster are similar to each other, while records in different clusters are most distinct from one another.) based k-anonymization technique to minimize the information loss while at the same time assuring data quality. Privacy preservation of individuals has drawn considerable interests in data mining research. The k-anonymity model proposed by Samarati and Sweeney is a practical approach for data privacy preservation and has been studied extensively for the last few years. Anonymization methods via generalization or suppression are able to protect private information, but lose valued information. The challenge is how to minimize the information loss during the anonymization process. We refer to the challenge as a systematic clustering problem for k-anonymization which is analysed in this paper. The proposed technique adopts group-similar data together and then anonymizes each group individually. The structure of systematic clustering problem is defined and investigated through paradigm and properties. An algorithm of the proposed problem is developed and shown that the time complexity is in \({O(\frac{n^{2}}{k})}\), where n is the total number of records containing individuals concerning their privacy. Experimental results show that our method attains a reasonable dominance with respect to both information loss and execution time. Finally the algorithm illustrates the usability for incremental datasets.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0131-6</ee>
<url>db/journals/acta/acta48.html#KabirWB11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Giammo76"> 
<author>Thomas Giammo</author>
<title>Validation of a Computer Performance Model of the Exponential Queuing Network Family.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>137-152</pages>
<url>db/journals/acta/acta7.html#Giammo76</url>
<abstract>The applicability and accuracy of a general queuing network approach to the modeling of computer performance was tested in an actual production environment. The validation exercise established that such an approach had both sufficient flexibility and precision to be of use in long range planning efforts. The accuracy of the results further suggests that these techniques may be successfully extended to a wide range of uses.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265767</ee>
</article>

<article mdate="2004-06-28" key="journals/acta/ScottJ04">
<author>Elizabeth Scott</author>
<author>Adrian Johnstone</author>
<title>Reducing non-determinism in right nulled GLR parsers.</title>
<pages>459-489</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>Tomita’s general parsing algorithm is linear on LR(1) grammars but fails to terminate on grammars with hidden left recursion and is not efficient in the presence of \(\epsilon\)-rules. When Right Nulled (RN) parse tables are used Tomita style GLR algorithms operate correctly and more efficiently on all context free grammars. However, an RN table may contain more conflicts than the corresponding LR table, making the construction of parts of the internal structure redundant. We show that in certain cases conflicts can be removed from an RN table without compromising the correctness of the associated parser. In particular, all conflicts can be removed if the grammar is LR(1). This improves the performance of the parser and allows resolved RN tables for LR(1) grammars to be used with standard (deterministic) LR stack-based parsing algorithms, adding the ‘short-circuiting’ of right nullable reductions to the armoury of efficient implementation techniques for such algorithms.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0137-z</ee>
<url>db/journals/acta/acta40.html#ScottJ04</url>
</article>
<article mdate="2008-05-21" key="journals/acta/BrazdilKS08">
<author>Tom&aacute;s Br&aacute;zdil</author>
<author>Anton&iacute;n Kucera</author>
<author>Oldrich Strazovsk&yacute;</author>
<title>Deciding probabilistic bisimilarity over infinite-state probabilistic systems.</title>
<pages>131-154</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We prove that probabilistic bisimilarity is decidable over probabilistic extensions of BPA and BPP processes. For normed subclasses of probabilistic BPA and BPP processes we obtain polynomial-time algorithms. Further, we show that probabilistic bisimilarity between probabilistic pushdown automata and finite-state systems is decidable in exponential time. If the number of control states in PDA is bounded by a fixed constant, then the algorithm needs only polynomial time.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0066-8</ee>
<url>db/journals/acta/acta45.html#BrazdilKS08</url>
</article>
<article mdate="2012-08-13" key="journals/acta/SantoneV12">
<author>Antonella Santone</author>
<author>Gigliola Vaglini</author>
<title>Abstract reduction in directed model checking CCS processes.</title>
<pages>313-341</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Model checking tools face a combinatorial blow up of the state-space (commonly known as the state explosion problem) that must be addressed to formally verify concurrent systems. We propose an approach combining abstraction techniques and heuristic search to overcome the problem above. In particular, heuristic search can avoid the bottleneck of the exhaustive exploration of the global state graph of a system, while retaining the advantages of abstraction techniques.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0161-3</ee>
<url>db/journals/acta/acta49.html#SantoneV12</url>
</article>
<article mdate="2015-06-08" key="journals/acta/0001BK15">
<author>Joachim Klein 0001</author>
<author>Christel Baier</author>
<author>Sascha Kl&uuml;ppelholz</author>
<title>Compositional construction of most general controllers.</title>
<pages>443-482</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>Given a system \({\fancyscript{A}}\) and an objective \(\varPhi \), the task of controller synthesis is to design a decision making policy that ensures \(\varPhi \) to be satisfied. This article deals with transition system-like system models and controllers that base their decisions on the observables of the actions performed so far. We present a framework for the compositional construction of controllers for conjunctive sequences of linear-time objectives in an online manner. For this approach, it is crucial that the controllers enforce the objectives in a most general manner, being as permissive as possible. We then present game-based algorithms for the construction of such most general controllers for invariance, reachability and \(\omega \)-regular objectives.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0239-9</ee>
<url>db/journals/acta/acta52.html#0001BK15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Belaga89">
<author>Edward G. Belaga</author>
<title>Through the Mincing Machine with a Boolean Layer Cake.</title>
<pages>381-407</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#Belaga89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276024</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KearnsS83">
<author>John P. Kearns</author>
<author>Mary Lou Soffa</author>
<title>The Implementation of Retention in a Coroutine Environment.</title>
<pages>221-233</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#KearnsS83</url>
<abstract>An efficient storage management scheme for languages supporting both coroutines and procedures is discussed. This scheme requires identifying those program components whose run time instances might need retention. These components could include both procedures and coroutines. A compile-time marking technique for determining these components in a block structured coroutine environment is presented. The impact that variations in the form of the coroutine control structures have on the technique is also addressed. Using the compile time marking as a guide, the storage management scheme can contract gracefully into a stack when programs use only a procedure call/return control discipline.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265556</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Hwang98">
<author>Hsien-Kuei Hwang</author>
<title>Asymptotic Expansions of the Mergesort Recurrences.</title>
<pages>911-919</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035011/80350911.htm</ee>
<url>db/journals/acta/acta35.html#Hwang98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nicolas82">
<author>Jean-Marie Nicolas</author>
<title>Logic for Improving Integrity Checking in Relational Data Bases.</title>
<pages>227-253</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Nicolas82</url>
<abstract>When an “updating” operation occurs on the current state of a data base, one has to ensure the new state obeys the integrity constraints. So, some of them have to be evaluated on this new state. The evaluation of an integrity constraint can be time consuming, but one can improve such an evaluation by taking advantage from the fact that the integrity constraint is satisfied in the current state. Indeed, it is then possible to derive a simplified form of this integrity constraint which is sufficient to evaluate in the new state in order to determine whether the initial constraint is still satisfied in this new state. The purpose of this paper is to present a simplification method yielding such simplified forms for integrity constraints. These simplified forms depend on the nature of the updating operation which is the cause of the state change. The operations of inserting, deleting, updating a tuple in a relation as well as transactions of such operations are considered. The proposed method is based on syntactical criteria and is validated through first order logic. Examples are treated and some aspects of the method application are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263192</ee>
</article>
<article mdate="2011-11-25" key="journals/acta/PernaWSI11">
<author>Juan Ignacio Perna</author>
<author>Jim Woodcock</author>
<author>Augusto Sampaio</author>
<author>Juliano Iyoda</author>
<title>Correct hardware synthesis - An algebraic approach.</title>
<pages>363-396</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>This paper presents an algebraic compilation approach to the correct synthesis (compilation into hardware) of a synchronous language with shared variables and parallelism. The synthesis process generates a hardware component that implements the source program by means of gradually reducing it into a highly parallel state-machine. The correctness of the compiler follows by construction from the correctness of the transformations involved in the synthesis process. Each transformation is proved sound from more basic algebraic laws of the source language; the laws are themselves formally derived from a denotational semantics expressed in the Unified Theories of Programming. The proposed approach is based on previous efforts that handle both software and hardware compilation, in a pure algebraic style, but the complexity of our source language demanded significant adaptations and extensions to the existing approaches.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0142-y</ee>
<url>db/journals/acta/acta48.html#PernaWSI11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MaurerSW77"> 
<author>Hermann A. Maurer</author>
<author>Arto Salomaa</author>
<author>Derick Wood</author>
<title>EOL Forms.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>75-96</pages>
<url>db/journals/acta/acta8.html#MaurerSW77</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276185</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Langmaack73a"> 
<author>Hans Langmaack</author>
<title>On Procedures as Open Subroutines. I</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>311-333</pages>
<url>db/journals/acta/acta2.html#Langmaack73a</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Szelepcsenyi88">
<author>R&oacute;bert Szelepcs&eacute;nyi</author>
<title>The Method of Forced Enumeration for Nondeterministic Automata.</title>
<pages>279-284</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#Szelepcsenyi88</url>
<abstract>Every family of languages, recognized by nondeterministic L(n) tape-bounded Turing machines, where L(n)≥logn, is closed under complement. As a special case, the family of context-sensitive languages is closed under complement. This solves the open problem from [4].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299636</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BauerO84">
<author>G. Bauer</author>
<author>Friedrich Otto</author>
<title>Finite Complete Rewriting Systems and the Complexity of the Word Problem.</title>
<pages>521-540</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BauerO84</url>
<abstract>It is well known that the word problem for a finite complete rewriting system is decidable. Here it is shown that in general this result cannot be improved. This is done by proving that each sufficiently rich complexity class can be realized by the word problem for a finite complete rewriting system. Further, there is a gap between the complexity of the word problem for a finite complete rewriting system and the complexity of the least upper bound for the lengths of the chains generated by this rewriting system, and this gap can get arbitrarily large. Thus, the lengths of these chains do not give any information about the complexity of the word problem. Finally, it is shown that the property of allowing a finite complete rewriting system is not an invariant of finite monoid presentations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271645</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/IlieS00">
<author>Lucian Ilie</author>
<author>Arto Salomaa</author>
<title>On the Expressiveness of Subset-Sum Representations.</title>
<pages>665-672</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036008/00360665.htm</ee>
<url>db/journals/acta/acta36.html#IlieS00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Kameda83">
<author>Hisao Kameda</author>
<title>A Note on Multi-queue Scheduling of Two Tasks.</title>
<pages>113-120</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Kameda83</url>
<abstract>Optimal schedules in a central server model, consisting of a ‘CPU’ server and m ‘I/O’ servers, are obtained for the case of two customers. Each customer has exponential service time distributions with a distinct mean at the CPU server and with the same mean at any I/O servers. The performance measure considered is an arbitrarily weighted sum of the CPU utilization for each customer. It is shown that the optimal CPU and I/O schedules are either one of preemptive priority disciplines depending on certain conditions; the conditions are also obtained. A proof is given to the conjecture made by Spirn on the model and the results of Spirn's are generalized.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289409</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HauschildtJ94">
<author>Dirk Hauschildt</author>
<author>Matthias Jantzen</author>
<title>Petri Net Algorithms in the Theory of Matrix Grammars.</title>
<pages>719-728</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#HauschildtJ94</url>
<abstract>This paper shows that the languages over a one-letter alphabet generated by context-free matrix grammars are always regular. Moreover we give a decision procedure for the question of whether a context-free matrix language is finite. Hereby we strengthen a result of [Mk 92] and settle a number of open questions in [DP 89]. Both results are obtained by a reduction to Petri net problems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178731</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Honkala98">
<author>Juha Honkala</author>
<title>Decision Problems Concerning Thinness and Slenderness of Formal Languages.</title>
<pages>625-636</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta35.html#Honkala98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035007/80350625.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/JacobsG85">
<author>Dean Jacobs</author>
<author>David Gries</author>
<title>General Correctness: A Unification of Partial and Total Correctness.</title>
<pages>67-83</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#JacobsG85</url>
<abstract>General correctness, which subsumes partial and total correctness, is defined for both weakest preconditions and strongest postconditions. Healthiness properties for general-correctness predicate transformers are more uniform and complete than those for partial- and total-correctness systems. In fact, the healthiness properties for partial and total correctness are simple restrictions of those for general correctness. General correctness allows simple formulations of the connections between weakest and strongest postconditions and between the notions of weakest precondition under the “demonic” and “angelic” interpretations of nondeterminism. A problem that plagues sp-sp(P, C) is undefined if execution of C begun in some state of P may not terminate — disappears with the generalization.This paper is a study of some simple theory underlying predicate transformer semantics, and as yet has little bearing on current programming practices. The theory uses a relational model of programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290146</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeeuwenO82">
<author>Jan van Leeuwen</author>
<author>Mark H. Overmars</author>
<title>Stratified Balanced Search Trees.</title>
<pages>345-359</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#LeeuwenO82</url>
<abstract>We develop a new perspective on trees, that enables us to distinguish and analyse many different subclasses of known classes of (height-)balanced search trees in a uniform manner. The approach shows that a great many different local constraints, including an arbitrary degree of density, can be enforced on everyday balanced search tree models, without losing the O(log n) bound on the time for insertions, deletions and finds. The theory extends known concepts from the study of B-trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289574</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/OttmannSW85">
<author>Thomas Ottmann</author>
<author>Michael Schrapp</author>
<author>Derick Wood</author>
<title>Purely Top-Down Updating Algorithms for Stratified Search Trees.</title>
<pages>85-100</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#OttmannSW85</url>
<abstract>The existence of purely top-down updating algorithms for balanced search trees is of importance when maintaining such trees in a concurrent environment, where purely top-down means a single sweep from the root to frontier along a search path. We present algorithms for internal- and external-search trees in the general framework of stratified trees. This enables us to demonstrate that many classes of balanced search trees have such updating schemes, although, for example, weight-balanced trees do not fit into this framework.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290147</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BauerW88">
<author>Friedrich L. Bauer</author>
<author>Martin Wirsing</author>
<title>Crypt-Equivalent Algebraic Specifications.</title>
<pages>111-153</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta25.html#BauerW88</url>
<abstract>Equivalence is a fundamental notion for the semantic analysis of algebraic specifications. In this paper the notion of “crypt-equivalence” is introduced and studied w.r.t. two “loose” approaches to the semantics of an algebraic specification T: the class of all first-order models of T and the class of all term-generated models of T. Two specifications are called crypt-equivalent if for one specification there exists a predicate logic formula which implicitly defines an expansion (by new functions) of every model of that specification in such a way that the expansion (after forgetting unnecessary functions) is homologous to a model of the other specification, and if vice versa there exists another predicate logic formula with the same properties for the other specification. We speak of “first-order crypt-equivalence” if this holds for all first-order models, and of “inductive crypt-equivalence” if this holds for all term-generated models. Characterizations and structural properties of these notions are studied. In particular, it is shown that first order crypt-equivalence is equivalent to the existence of explicit definitions and that in case of “positive definability” two first-order crypt-equivalent specifications admit the same categories of models and homomorphisms. Similarly, two specifications which are inductively crypt-equivalent via sufficiently complete implicit definitions determine the same associated categories. Moreover, crypt-equivalence is compared with other notions of equivalence for algebraic specifications: in particular, it is shown that first-order cryptequivalence is strictly coarser than “abstract semantic equivalence” and that inductive crypt-equivalence is strictly finer than “inductive simulation equivalence” and “implementation equivalence”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263582</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DemersKR82">
<author>Alan J. Demers</author>
<author>C. Keleman</author>
<author>Bernd Reusch</author>
<title>On Some Decidable Properties of Finite State Translations.</title>
<pages>349-364</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#DemersKR82</url>
<abstract>In this paper we present algorithms to decide: 1) single-valuedness of nondeterministic finite transducers, 2) equivalence of single-valued transducers, and 3) whether a given nondeterministic finite transduction can be realized by a deterministic transducer. When such a deterministic realization is possible our proof gives an effective construction of the deterministic transducer.The decidability of single-valuedness and equivalence for a-transducers has been obtained independently by Blattner and Head [3]. Our results introduce different characterizations for decidability and use a different proof that is interesting on its own.We began this research by generalizing the results about decoding automata presented in [5]. A report of these results with a heavy emphasis placed on applications to crytography appears in [6]. This paper presents results applicable in the more general area of finite state translations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264358</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Comments-Walter79">
<author>Beate Commentz-Walter</author>
<title>Size-Depth Tradeoff in Monotone Boolean Formulae.</title>
<pages>227-243</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Comments-Walter79</url>
<abstract>Formula size and depth are two important complexity measures of Boolean functions. We study the tradeoff between those two measures: We give an infinite set of Boolean functions and show for nearly each of them: There is no monotone formula computing it optimal with respect to both measures. We give a lower and upper bound on the product of size and depth of monotone formulae computing our functions. That implies, moreover, a logarithmic lower bound on circuit depth.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264580</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Kou89">
<author>Lawrence T. Kou</author>
<title>On Efficient Implementation of an Approximation Algorithm for the Steiner Tree Problem.</title>
<pages>369-380</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta27.html#Kou89</url>
<abstract>This paper studies the design and implementation of an approximation algorithm for the Steiner tree problem. Given any undirected distance graph G and a set of Steiner points S, the algorithm produces a Steiner tree with total weight on its edges no more than 2(1−1/L) times the total weight on the optimal Steiner tree, where L is the number of leaves in the optimal Steiner tree. Our implementation of the algorithm, in the worst case, makes it run in 0(¦E g¦+¦V g−S¦log¦V g−S¦+¦S¦log ¦S¦) time for general graph G and in 0(¦S¦ log¦S¦+M log β(M,¦V g−S¦)) time for sparse graph G, where E g is the set of edges in G, Vg is the set of vertices in G, M = min {¦E g, (¦V g−S¦−1)2/2} and β(x,y) = min {i¦log(i) y ≦ x/y}.The implementation is not likely to be improved significantly without the improvement of the shortest paths algorithm and the minimum spanning tree algorithm as the algorithm essentially composes of the computation of the multiple sources shortest paths of a graph with ¦V g¦ vertices and ¦E g¦ edges and the minimum spanning tree of a graph with ¦V g−S¦ vertices and M edges.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264613</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Meduna03">
<author>Alexander Meduna</author>
<title>Coincidental extension of scattered context languages.</title>
<pages>307-314</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>For a symbol, #, and a string, x = a 1 a 2 ...a n - 1 a n , any string of the form # i a 1 # i a 2 # i...# i a n - 1 # i a n # i, where \(\) 0, is a coincidental #-extension of x. A language, K, is a coincidental #-extension of L if every string of K represents a coincidental extension of a string in L and the deletion of all #s in K results in L. This paper proves that for every recursively enumerable language, E, there exists a propagating scattered context language that represents a coincidental extension of E.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0112-0</ee>
<url>db/journals/acta/acta39.html#Meduna03</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Fernau01">
<author>Henning Fernau</author>
<title>Parallel communicating grammar systems with terminal transmission.</title>
<pages>511-540</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037007/10370511.htm</ee>
<url>db/journals/acta/acta37.html#Fernau01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KempfBG87">
<author>M. Kempf</author>
<author>Rudolf Bayer</author>
<author>Ulrich G&uuml;ntzer</author>
<title>Time Optimal Left to Right Construction of Position Trees.</title>
<pages>461-474</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#KempfBG87</url>
<abstract>In the following paper we are presenting a new algorithm for the on-line construction of position trees. Reading a given input string from left to right we are generating its position tree with the aid of the general concept of infix trees. An additional chain structure within the trees, called tail node connection, enables us to construct the tree within the best possible time (proportional to the number of nodes).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292114</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/LarsenOS01">
<author>Kim S. Larsen</author>
<author>Thomas Ottmann</author>
<author>Eljas Soisalon-Soininen</author>
<title>Relaxed balance for search trees with local rebalancing.</title>
<pages>743-763</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037010/10370743.htm</ee>
<url>db/journals/acta/acta37.html#LarsenOS01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HuangJ89">
<author>Yennun Huang</author>
<author>Pankaj Jalote</author>
<title>Analytic Models for the Primary Site Approach to Fault-Tolerance.</title>
<pages>543-557</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta26.html#HuangJ89</url>
<abstract>A common approach for supporting fault tolerance against node failures is the primary site approach. In this approach the service to be made fault-tolerant is replicated at many nodes, one of which is designated as primary and the others as backups. All the requests for the service are sent to the primary site. The primary site periodically checkpoints its state on the backups. If the primary fails, one of the backups takes over as primary, and to maintain consistency, it first re-executes all the requests performed by the previous primary since the last checkpoint. Two important issues that effect performance of this approach are the frequency of checkpointing and the degree of replication of the service. If the checkpointing interval is decreased the overhead of reexecuting old requests decreases, but the overhead for checkpointing increases. If the degree of replication increases, on the one hand, the availability of the system for user services increases since the reliability of the system increases. On the other hand, the checkpointing time increases, which reduces the availability of the system. In this paper, we present an analytic model to study the optimum checkpointing interval, and a queuing model to study the optimum degree of replication for a service in a primary site system. The reliability of a primary site system is also studied.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263579</ee>
</article>
<article mdate="2005-04-25" key="journals/acta/JiangH05">
<author>Yiwei Jiang</author>
<author>Yong He</author>
<title>Preemptive online algorithms for scheduling with machine cost.</title>
<pages>315-340</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>For most scheduling problems the set of machines is fixed initially and remains unchanged. Recently Imreh and Noga proposed adding the concept of machine cost to scheduling problems and considered the so-called List Model problem. For this problem, we are given a sequence of independent jobs with positive sizes, which must be processed non-preemptively on a machine. No machines are initially provided, and when a job is revealed the algorithm has the option to purchase new machines. The objective is to minimize the sum of the makespan and cost of machines. In this paper, a modified model of List Model is presented where preemption is allowed. For this model, it is shown that better performance is possible. We present an online algorithm with a competitive ratio of \((2\sqrt{6} + 2)/5\approx 1.3798\) while the lower bound is 4/3. For the semi-online problem with decreasing sizes, we design an optimal algorithm with a competitive ratio of 4/3, which improves the known upper bound of 3/2. The algorithm does not introduce any preemption, and hence is also an optimal semi-online algorithm for the non-preemptive semi-online problem. For the semi-online problem with known largest size, we present an optimal algorithm with a competitive ratio of 4/3.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0156-9</ee>
<url>db/journals/acta/acta41.html#JiangH05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Stewart93">
<author>Iain A. Stewart</author>
<title>Logical and Schematic Characterization of Complexity Classes.</title>
<pages>61-87</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta30.html#Stewart93</url>
<abstract>We consider classes of well-known program schemes from a complexity theoretic viewpoint. We define logics which express all those problems solvable using our program schemes and show that the class of problems so solved or expressed coincides exactly with the complexity classPSPACE (our problems are viewed as sets of finite structures over some vocabulary). We derive normal form theorems for our logics and use these normal form theorems to show that certain problems concerning acceptance and termination of our program schemes and satisfiability of our logical formulae arePSPACE-complete. Moreover, we show that a game problem, seemingly disjoint from logic and program schemes, isPSPACE-complete using the results described above. We also highlight similarities between the results of this paper and the literature, so providing the reader with an introduction to this area of research.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01200263</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kuspert83">
<author>Klaus K&uuml;spert</author>
<title>Storage Utilization in B*-Trees with a Generalized Overflow Technique.</title>
<pages>35-55</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Kuspert83</url>
<abstract>We analyze storage utilization in random B *-trees (trees, where all data are stored in the leaf nodes). Extending a proposal of Bayer and McCreight, in case of insertion into a full node, up to m}-1 adjacent nodes are scanned for empty space. If this search is successful, entries are shifted on leaf level to gain free space for the new one; otherwise, the entries of the m nodes scanned are distributed as uniformly as possible over m}+1 nodes. Using iterative models it is shown that for large trees of high order storage utilization converges to m · ln((m}+1)/m).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263927</ee>
</article>
<article mdate="2007-09-11" key="journals/acta/AfratiCGP07">
<author>Foto N. Afrati</author>
<author>Rada Chirkova</author>
<author>Manolis Gergatsoulis</author>
<author>Vassia Pavlaki</author>
<title>View selection for <i>real</i> conjunctive queries.</title>
<pages>289-321</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Given a query workload, a database and a set of constraints, the view-selection problem is to select views to materialize so that the constraints are satisfied and the views can be used to compute the queries in the workload efficiently. A typical constraint, which we consider in the present work, is to require that the views can be stored in a given amount of disk space. Depending on features of SQL queries (e.g., the DISTINCT keyword) and on whether the database relations on which the queries are applied are sets or bags, the queries may be computed under set semantics, bag-set semantics, or bag semantics. In this paper we study the complexity of the view-selection problem for conjunctive queries and views under these semantics. We show that bag semantics is the “easiest to handle” (we show that in this case the decision version of view selection is in NP), whereas under set and bag-set semantics we assume further restrictions on the query workload (we only allow queries without self-joins in the workload) to achieve the same complexity. Moreover, while under bag and bag-set semantics filtering views (i.e., subgoals that can be dropped from the rewriting without impacting equivalence to the query) are practically not needed, under set semantics filtering views can reduce significantly the query-evaluation costs. We show that under set semantics the decision version of the view-selection problem remains in NP only if filtering views are not allowed in the rewritings. Finally, we investigate whether the cgalg algorithm for view selection introduced in Chirkova and Genesereth (Linearly bounded reformulations of conjunctive databases, pp. 987–1001, 2000) is suitable in our setting. We prove that this algorithm is sound for all cases we examine here, and that it is complete under bag semantics for workloads of arbitrary conjunctive queries and under bag-set semantics for workloads of conjunctive queries without self-joins.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0046-z</ee>
<url>db/journals/acta/acta44.html#AfratiCGP07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hinz92">
<author>Didier Y. Hinz</author>
<title>A Run-Time Load Balancing Strategy for Highly Parallel Systems.</title>
<pages>63-94</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta29.html#Hinz92</url>
<abstract>We discuss a simple run-time load balancing strategy which applies to numerical applications working on planar domains with localized data dependency. We develop an iterative and adaptive partitioner, able to work in a distributed way among the processors of a parallel system. Our algorithm subdivides data space into general quadrilaterals, where each processor works on the data of one area. The topology of these domains is that of a rectangular grid and does not change during execution. In this way a very simple and efficient communication structure is given. The administration overhead due to irregular geometry is small. Also, the overhead caused by periodically read-justing load balance is rather small because of the adaptivity and parallelity of the partitioning algorithm. We ran an scientific application to compare our method with a method working by recursive bisection, and obtained satisfactory results.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178566</ee>
</article>
<article mdate="2008-01-15" key="journals/acta/JiangH07">
<author>Yiwei Jiang</author>
<author>Yong He</author>
<title>Optimal semi-online algorithms for preemptive scheduling problems with inexact partial information.</title>
<pages>571-590</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>In semi-online scheduling problems, we always assume that some partial additional information is exactly known in advance. This may not be true in some application. This paper considers semi-online problems on identical machines with inexact partial information. Three problems are considered, where we know in advance that the optimal value, or the largest job size are in given intervals, respectively, while their exact values are unknown. We give both lower bounds of the problems and competitive ratios of algorithms as functions of a so-called disturbance parameter r ∈[1, ∞). We establish for which r the inexact partial information is useful to improve the performance of a semi-online algorithm with respect to its pure online problem. Optimal preemptive semi-online algorithms are then obtained.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0058-8</ee>
<url>db/journals/acta/acta44.html#JiangH07</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Ravelo99">
<author>Jes&uacute;s N. Ravelo</author>
<title>Two Graph Algorithms Derived.</title>
<pages>489-510</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036006/90360489.htm</ee>
<url>db/journals/acta/acta36.html#Ravelo99</url>
</article>
<article mdate="2003-11-25" key="journals/acta/SagivFRW98">
<author>Shmuel Sagiv</author>
<author>Nissim Francez</author>
<author>Michael Rodeh</author>
<author>Reinhard Wilhelm</author>
<title>A Logic-Based Approach to Program Flow Analysis.</title>
<pages>457-504</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta35.html#SagivFRW98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035006/80350457.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Perrot77"> 
<author>Jean-Fran&ccedil;ois Perrot</author>
<title>Mono&iuml;des syntactiques des langages alg&eacute;briques.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>399-413</pages>
<url>db/journals/acta/acta7.html#Perrot77</url>
<abstract>Syntactic monoids have been considered so far almost only for rational (= regular) languages. We start here a systematic study of the syntactic monoids of algebraic (= context-free) languages. We exhibit a whole class of finitely generated monoids, none of which is isomorphic to the syntactic monoid of an algebraic language. We show that if M 1 and M 2 are syntactic monoids of algebraic languages L 1 and L 2, and if neither M 1 nor M 2 has a zero, then there exists an algebraic language L whose syntactic monoid is isomorphic to the direct product M 2×M2. We then prove that the algebraic language ¯L 0 Complement of {n n yn zn; n≧1} has a syntactic monoid M 0 such that M 0×M 0 is not isomorphic to the syntactic monoid of any algebraic language, whence follows that any algebraic language L′ whose syntatic monoid is isomorphic to M 0 must be non deterministic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289471</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/GonnetRG80">
<author>Gaston H. Gonnet</author>
<author>Lawrence D. Rogers</author>
<author>J. Alan George</author>
<title>An Algorithmic and Complexity Analysis of Interpolation Search.</title>
<pages>39-52</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#GonnetRG80</url>
<abstract>We begin with a brief survey of the literature concerning the Interpolation Search algorithm, then provide a detailed description of the algorithm and how to implement it to search a particular table or file. We next analyze the complexity of the search method by investigating the moments of the distribution of the number of table accesses needed to locate a given record. For a table containing n entries, we find that the expected value of the number of accesses is log2 log2 n+O(1) and that the variance is O(log2 log2 n). Lastly we provide some approximations for the expected value for the successful and unsuccessful search in such a table.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288534</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/Valmari15">
<author>Antti Valmari</author>
<title>On constructibility and unconstructibility of LTS operators from other LTS operators.</title>
<pages>207-234</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>An LTS operator can be constructed from a set of LTS operators up to an equivalence if and only if there is an LTS expression that only contains operators from the set and whose result is equivalent to the result of the operator. In this publication this idea is made precise in the context where each LTS has an alphabet of its own and the operators may depend on the alphabets. Then the extent to which LTS operators are constructible is studied. Most, if not all, established LTS operators have the property that each trace of the result arises from the execution of no more than one trace of each of its argument LTSs, and similarly for infinite traces. All LTS operators that have this property and satisfy some other rather weak regularity properties can be constructed from parallel composition and hiding up to the equivalence that compares the alphabets, traces, and infinite traces of the LTSs. Furthermore, a collection of other miscellaneous constructibility and unconstructibility results is presented.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0217-2</ee>
<url>db/journals/acta/acta52.html#Valmari15</url>
</article>
<article mdate="2010-01-04" key="journals/acta/CarpiD09">
<author>Arturo Carpi</author>
<author>Flavio D'Alessandro</author>
<title>Strongly transitive automata and the Cern&yacute; conjecture.</title>
<pages>591-607</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>The synchronization problem is investigated for a new class of deterministic automata called strongly transitive. An extension to unambiguous automata is also considered.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0106-7</ee>
<url>db/journals/acta/acta46.html#CarpiD09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/TaubenfeldM96">
<author>Gadi Taubenfeld</author>
<author>Shlomo Moran</author>
<title>Possibility and Impossibility Results in a Shared Memory Environment.</title>
<pages>1-20</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta33.html#TaubenfeldM96</url>
<abstract>We focus on unreliable asynchronous shared memory model which support only atomic read and write operations. For such a model we provide a necessary condition for the solvability of problems in the presence of multiple undetectable crash failures. Also, by using game-theoretical notions, a necessary and sufficient condition is provided, for the solvability of problems in the presence of multiple undetectable initial failures (i.e., processes may fail only prior to the execution).Our results imply that many problems such as consensus, choosing a leader, ranking, matching and sorting are unsolvable in the presence of a single crash failure, and that variants of these problems are solvable in the presence of a single crash failure, and that variants of these problems are solvable in the presence of t-1 crash failures but not in the presence of t crash failures.We show that a shared memory model can simulate various message passing models, and hence our impossibility results hold also for those message passing models. Our results extend and generalize previously known impossibility results for various asynchronous models.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050034</ee>
</article>
<article mdate="2005-03-14" key="journals/acta/Duggan05">
<author>Dominic Duggan</author>
<title>Type-based hot swapping of running modules.</title>
<pages>181-220</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>While dynamic linking has become an integral part of the run-time execution of modern programming languages, there is increasing recognition of the need for support for hot swapping of running modules, particularly in long-lived server applications. The interesting challenge for such a facility is to allow the new module to change the types exported by the original module, while preserving type safety. This paper describes a type-based approach to hot swapping running modules. The approach is based on a reflective mechanism for dynamically adding type sharing constraints to the type system, realized by programmer-defined version adapters in the run-time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://www.springerlink.com/index/10.1007/s00236-004-0151-1</ee>
<url>db/journals/acta/acta41.html#Duggan05</url>
</article>
<article mdate="2003-11-25" key="journals/acta/EhrichC00">
<author>Hans-Dieter Ehrich</author>
<author>Carlos Caleiro</author>
<title>Specifying Communication in Distributed Information Systems.</title>
<pages>591-616</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036008/00360591.htm</ee>
<url>db/journals/acta/acta36.html#EhrichC00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/PatersonW86">
<author>Mike Paterson</author>
<author>Ingo Wegener</author>
<title>Nearly Optimal Hierarchies for Network and Formula Size.</title>
<pages>217-221</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#PatersonW86</url>
<abstract>How large are the “gaps” in the complexity hierarchies for Boolean functions with respect to network size and formula size? A gap is a non-empty interval of integers none of which is the complexity of any Boolean function. It is shown for the most natural bases that there are no gaps at all over a broad range of values and that the largest gap anywhere is less than n.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289499</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/Dingel06">
<author>J&uuml;rgen Dingel</author>
<title>Compositional Analysis of C/C++ Programs with VeriSoft.</title>
<pages>45-71</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper describes how the state space exploration ool VeriSoft can be used to analyze parallel C/C++ programs compositionally. VeriSoft is employed for two analyses: transition traceanalysis and assume/guarantee reasoning. Both analyses are compositional in the sense that the behaviour of a parallel program is determined in terms of the behaviour of its constituent processes. While both analyses have traditionally been carried out with “pencil and paper”, the paper demonstrates how VeriSoft can be used to automate them. In the context of transition trace analysis, the question whether a given program can exhibit a given trace is addressed with VeriSoft. To implement assume/guarantee reasoning, VeriSoft is used to determine whether a given program satisfies a given assume/guarantee specification. Since VeriSoft’s state space exploration is bounded and thus not complete in general, our proposed analyses are only meant to complement standard reasoning about parallel programs using traces or assume/guarantee specifications. For instance, a successful analysis does not always imply the general correctness of an assume/guarantee specification. However, it increases the confidence in the verification effort. On the other hand, an unsuccessful analysis always produces a counterexample which can be used to correct the specification or the program. VeriSoft’s optimization and visualization techniques make the analyses relatively efficient and effective.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0016-x</ee>
<url>db/journals/acta/acta43.html#Dingel06</url>
</article>
<article mdate="2003-11-25" key="journals/acta/AlonsoS01">
<author>Laurent Alonso</author>
<author>Ren&eacute; Schott</author>
<title>On the tree inclusion problem.</title>
<pages>653-670</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037009/10370653.htm</ee>
<url>db/journals/acta/acta37.html#AlonsoS01</url>
</article>
<article mdate="2014-07-08" key="journals/acta/MedunaZ14">
<author>Alexander Meduna</author>
<author>Petr Zemek</author>
<title>Controlled finite automata.</title>
<pages>327-337</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>This paper discusses finite automata regulated by control languages over their states and transition rules. It proves that under both regulations, regular-controlled finite automata and context-free-controlled finite automata characterize the family of regular languages and the family of context-free languages, respectively. It also establishes conditions under which any state-controlled finite automaton can be turned into an equivalent transition-controlled finite automaton and vice versa. The paper also demonstrates a close relation between these automata and programmed grammars. Indeed, it proves that finite automata controlled by languages generated by propagating programmed grammars with appearance checking are computationally complete. In fact, it demonstrates that this computational completeness holds even in terms of these automata with a reduced number of states.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0199-5</ee>
<url>db/journals/acta/acta51.html#MedunaZ14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HarmanT96">
<author>Neal A. Harman</author>
<author>J. V. Tucker</author>
<title>Algebraic Models of Microprocessors: Architecture and Organisation.</title>
<pages>421-456</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta33.html#HarmanT96</url>
<abstract>We present an algebraic method for modeling microprocessors at different levels of abstraction, and for expressing the relationships between each level. We consider microprocessors at levels of abstraction determined by time and details of construction. The algebraic models isolate features of the scientific structure of microprocessor computation, providing: (i) a basis for modular decomposition of the description of microprocessors, including correctness criteria; and (ii) equational specification and verification techniques for the design of microprocessors relevant to a range of specification languages and theorem provers. Our specifications are iterated maps that decompose the modeling of the computer into easily understood, equationally specified stages, represented by algebras. We illustrate our algebraic tools with an example of a simple computer.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050051</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Pratt78">
<author>Terrence W. Pratt</author>
<title>Program Analysis and Optimization through Kernel-Control Decomposition.</title>
<pages>195-216</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Pratt78</url>
<abstract>The decomposition of a program into a control part, which is concerned only with determining the flow of control, and a kernel part, which is concerned only with computing output values, is proposed. It is shown that such a kernel-control decomposition is easily made and forms a useful and intuitive basis for analyzing and optimizing programs. A sequence of four progressively more abstract formal models of programs is developed, based on the concept of kernel-control decomposition. The application of these models to the study of program equivalence, termination, and optimization is outlined. The most general of the formal models, that of a set of programs forming a control structure class, formalizes a broad notion of equivalence of control structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288882</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Coulondre03">
<author>St&eacute;phane Coulondre</author>
<title>A top-down proof procedure for generalized data dependencies.</title>
<pages>1-29</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/3039001/30390001.htm</ee>
<url>db/journals/acta/acta39.html#Coulondre03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ArakiT81">
<author>Toshiro Araki</author>
<author>Nobuki Tokura</author>
<title>Flow Languages Equal Recursively Enumerable Languages.</title>
<pages>209-217</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#ArakiT81</url>
<abstract>Recently, A.C. Shaw introduced a new class of expressions called flow expressions, and conjectured that the formal descriptive power of flow expressions lies somewhat below context-sensitive grammers. In this paper, we give a negative answer for his conjecture, that is, we show that all recursively enumerable languages may be denoted by flow expressions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289261</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HaldarV96">
<author>Sibsankar Haldar</author>
<author>K. Vidyasankar</author>
<title>Simple Extensions of 1-writer Atomic Variable Constructions to Multiwriter Ones.</title>
<pages>177-202</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta33.html#HaldarV96</url>
<abstract>We present several simple wait-free constructions of multiwriter multireader multivalued atomic shared variables. These are extensions of two 1-writer constructions in the literature and use a multiwriter multireader fixed-valued atomic variable. All the constructions are intuitive, and their correctness proofs are short and easy to follow. Some constructions are conflictfree, that is, in each execution, no reading of a buffer overlaps with any writing of that buffer. All the conflict-free constructions have the property that there is only one reading of a buffer in a read execution. Some of them have the additional property that there is only one writing of a 1-reader buffer, for each reader, in a write execution.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050040</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BrownBK82">
<author>Donna J. Brown</author>
<author>Brenda S. Baker</author>
<author>Howard P. Katseff</author>
<title>Lower Bounds for On-Line Two-Dimensional Packing Algorithms.</title>
<pages>207-225</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#BrownBK82</url>
<abstract>Many problems, such as cutting stock problems and the scheduling of tasks with a shared resource, can be viewed as two-dimensional bin packing problems. Using the two-dimensional packing model of Baker, Coffman, and Rivest, a finite list L of rectangles is to be packed into a rectangular bin of finite width but infinite height, so as to minimize the total height used. An algorithm which packs the list in the order given without looking ahead or moving pieces already packed is called an on-line algorithm. Since the problem of finding an optimal packing is NP-hard, previous work has been directed at finding approximation algorithms. Most of the approximation algorithms which have been studied are on-line except that they require the list to have been previously sorted by height or width. This paper examines lower bounds for the worst-case performance of on-line algorithms for both non-preordered lists and for lists preordered by increasing or decreasing height or width.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264439</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/KouvatsosT89">
<author>Demetres D. Kouvatsos</author>
<author>Nasreddine Tabet-Aouel</author>
<title>A Maximum Entropy Priority Approximation for a Stable <i> G/G/ </i> 1 Queue.</title>
<pages>247-286</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta27.html#KouvatsosT89</url>
<abstract>The principle of maximum entropy is used under two different sets of mean value constraints to analyse a stableG/G/1 queue withR priority classes under preemptive-resume (PR) and non-preemptive head-of-line (HOL) scheduling disciplines. New one-step recursions for the maximum entropy state probabilities are established and closed form approximations for the marginal queue length distribution per priority class are derived. To expedite the utility of the maximum entropy solutions exact analysis, based on the generalised exponential (GE) distribution, is used to approximate the marginal mean queue length and idle state probability class constraints for both the PR and HOLG/G/1 priority queues. Moreover, these results are used as building blocks in order to provide new approximate formulae for the mean and coefficient of variation of the effective priority service-time and suggest a maximum entropy algorithm for general open queueing networks with priorities in the context of the reduced occupancy approximation (ROA) method. Numerical examples illustrate the accuracy of the proposed maximum entropy approximations in relation to simulations involving different interarrival-time and service-time distributions per class. Comments on the extension of the work to more complex types of queueing systems are included.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00572990</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Maggiolo-SchettiniW96">
<author>Andrea Maggiolo-Schettini</author>
<author>J&oacute;zef Winkowski</author>
<title>A Kernel Language for Programmed Rewriting of (Hyper)graphs.</title>
<pages>523-546</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#Maggiolo-SchettiniW96</url>
<abstract>The paper presents a formalism for rewriting (hyper)graphs in a controlled manner. This formalism is essentially a simple programming language with productions, that is rewriting rules, playing the role of basic instructions. Programs in this language are built from productions by means of rather standard constructors, including a parallel composition. They may contain parameters to point to specific elements of graphs to which they are supposed to be applied. Programs are intended to describe how to transform a graph and a valuation of parameters in this graph in order to reach a resulting graph and a resulting valuation of parameters.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036461</ee>
</article>
<article mdate="2005-12-14" key="journals/acta/GayH05">
<author>Simon J. Gay</author>
<author>Malcolm Hole</author>
<title>Subtyping for session types in the pi calculus.</title>
<pages>191-225</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>Extending the pi calculus with the session types proposed by Honda et al. allows high-level specifications of structured patterns of communication, such as client-server protocols, to be expressed as types and verified by static typechecking. We define a notion of subtyping for session types, which allows protocol specifications to be extended in order to describe richer behaviour; for example, an implemented server can be refined without invalidating type-correctness of an overall system. We formalize the syntax, operational semantics and typing rules of an extended pi calculus, prove that typability guarantees absence of run-time communication errors, and show that the typing rules can be transformed into a practical typechecking algorithm.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0177-z</ee>
<url>db/journals/acta/acta42.html#GayH05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CostaS84">
<author>Gerardo Costa</author>
<author>Colin Stirling</author>
<title>A Fair Calculus of Communicating Systems.</title>
<pages>417-441</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#CostaS84</url>
<abstract>In this paper we are concerned with an operational approach to fairness, the problem of defining and generating the fair execution sequences of a concurrent language. One solution invokes two semantic levels: one level (the positive) prescribes the finite and infinite execution sequences without regard to their fairness while the other (the negative) filters out the unfair ones. The first level is given as a set of generative rules whereas the second is encoded as a definition of fair execution sequence. Entirely positive approaches have been proposed which appeal to random assignment. Here we offer an alternative positive approach for a subset of Milner's CCS. We show that rules can be given for generating just the fair sequences which avoid random assignment.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271640</ee>
</article>
<article mdate="2007-01-08" key="journals/acta/MutyamK02">
<author>Madhu Mutyam</author>
<author>Kamala Krithivasan</author>
<title>Generalized normal form for rewriting P systems.</title>
<pages>721-734</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038010/20380721.htm</ee>
<url>db/journals/acta/acta38.html#MutyamK02</url>
</article>
<article mdate="2008-01-15" key="journals/acta/BergstraM07">
<author>Jan A. Bergstra</author>
<author>C. A. Middelburg</author>
<title>Synchronous cooperation for explicit multi-threading.</title>
<pages>525-569</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>We develop an algebraic theory of threads, synchronous cooperation of threads and interaction of threads with Maurer machines, and investigate program parallelization using the resulting theory. Program parallelization underlies techniques for speeding up instruction processing on a computer that make use of the abilities of the computer to process instructions simultaneously in cases where the state changes involved do no influence each other. One of our findings is that a strong induction principle is needed when proving theorems about sufficient conditions for the correctness of program parallelizations. The induction principle introduced has brought us to construct a projective limit model for the theory developed.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0057-9</ee>
<url>db/journals/acta/acta44.html#BergstraM07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Pohlmann91">
<author>Werner Pohlmann</author>
<title>A Fixed Point Approach to Parallel Discrete Event Simulation.</title>
<pages>611-629</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#Pohlmann91</url>
<abstract>Discrete event simulation is viewed as solving a fixed point problem whose unknowns are infinite histories or streams of event and time information. Stream domains provide two notions of convergence, which correspond to the usual categorization of simulation methods. Metric convergence leads to optimistic parallel simulation (the classic event list mechanism turns out to be a specialization), and convergence in the sense of partial orders leads to conservative parallel simulation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178679</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/MiddeldorpO00">
<author>Aart Middeldorp</author>
<author>Hitoshi Ohsaki</author>
<title>Type Introduction for Equational Rewriting.</title>
<pages>1007-1029</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036012/00361007.htm</ee>
<url>db/journals/acta/acta36.html#MiddeldorpO00</url>
</article>
<article mdate="2009-03-05" key="journals/acta/BozzelliKRS09">
<author>Laura Bozzelli</author>
<author>Mojm&iacute;r Kret&iacute;nsk&yacute;</author>
<author>Vojtech Reh&aacute;k</author>
<author>Jan Strejcek</author>
<title>On decidability of LTL model checking for process rewrite systems.</title>
<pages>1-28</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We establish a decidability boundary of the model checking problem for infinite-state systems defined by Process Rewrite Systems (PRS) or weakly extended Process Rewrite Systems (wPRS), and properties described by basic fragments of action-based Linear Temporal Logic (LTL) with both future and past operators. It is known that the problem for general LTL properties is decidable for Petri nets and for pushdown processes, while it is undecidable for PA processes.We show that the problem is decidable for wPRS if we consider properties defined by LTL formulae with only modalities strict eventually, strict always, and their past counterparts. Moreover, we show that the problem remains undecidable for PA processes even with respect to the LTL fragment with the only modality until or the fragment with modalities next and infinitely often.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0082-3</ee>
<url>db/journals/acta/acta46.html#BozzelliKRS09</url>
</article>
<article mdate="2015-01-08" key="journals/acta/SmidO89">
<author>Michiel H. M. Smid</author>
<author>Mark H. Overmars</author>
<title>Maintaining Range Trees in Secondary Memory. Part II: Lower Bounds.</title>
<pages>453-480</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta27.html#SmidO89</url>
<abstract>When storing and maintaining a data structure in secondary memory it is important to partition it into parts such that each query and update passes through a small number of parts. In this way the number of disk accesses and the amount of data transport required can be kept low. In Part I of this paper a number of partition schemes were given for partitioning range trees. In this paper we study lower bounds for partitions. In this way we prove that many of the partitions given in Part I are optimal.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289019</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Cohen79">
<author>J. W. Cohen</author>
<title>The Multiple Phase Service Network with Generalized Processor Sharing.</title>
<pages>245-284</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Cohen79</url>
<abstract>An analysis is given of multiple phase service facilities of which queueing networks are special models, for the case of a service discipline to be denoted as generalized processor sharing. Under this discipline requests are served simultaneously with a rate depending on the phase and the number of requests present here. The model is of a very general type, its analysis is given for arbitrary routing matrices and absolutely continuous required service time distributions. The mathematical technique used is that of the supplementary variable. Generalisations of known results for closed and open networks are obtained and new results about the average sojourn time of a request in the system are derived, in particular for requests with given route and given processing times at the nodes of the route. Some basic results about reversed processes and departure processes are discussed. For a special but important model the workload is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264581</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Taylor83">
<author>Richard N. Taylor</author>
<title>Complexity of Analyzing the Synchronization Structure of Concurrent Programs.</title>
<pages>57-84</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Taylor83</url>
<abstract>Foundational to verification of some aspects of communicating concurrent systems is knowledge of the synchronization which may occur during execution. The synchronization determines the actions that may occur in parallel, may determine program data flow, and may also lead to inherently erroneous situations (e.g. deadlock). This paper formalizes the notion of the synchronization structure of concurrent programs that use the rendezvous (or similar) mechanism for achieving synchronization. The formalism is oriented towards supporting verification as performed by automated static program analysis. Complexity results are presented which indicate what may be expected in this area and which also shed light on the difficulty of correctly constructing concurrent systems. Specifically, most of the analysis tasks considered are shown to be intractable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263928</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wright81">
<author>William E. Wright</author>
<title>Binary Search Trees in Secondary Memory.</title>
<pages>3-17</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Wright81</url>
<abstract>Binary search trees are shown to be reasonable alternatives to multiway trees for files stored in magnetic bubble memory. An algorithm for maintaining AVL trees is shown to be by far the most efficient of eight algorithms considered, when applied to secondary memory. A simplified model for analyzing the AVL algorithm is developed. A practical AVL algorithm for secondary memory is presented. Simulation results showing the performance of the AVL algorithm and a basic nonbalancing algorithm are given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00269807</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MongenetCP94">
<author>Catherine Mongenet</author>
<author>Philippe Clauss</author>
<author>Guy-Ren&eacute; Perrin</author>
<title>Geometrical Tools to Map Systems of Affine Recurrence Equations on Regular Arrays.</title>
<pages>137-160</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta31.html#MongenetCP94</url>
<abstract>We propose a method based on geometrical tools to map problems onto regular and synchronous processor arrays. The problems we consider are defined by systems of affine recurrence equations (SARE). From such a problem specification we extract the data dependencies in terms of two classes of vectors: the utilization vectors and the dependence vectors. We use these vectors to express constraints on the timing or the allocation functions. We differentiate two classes of constraints. The causal ones are intrinsic timing constraints induced by the system of equations defining the problem. A given choice of target architecture may impose new constraints on the timing or the allocation. We call them the architecture-related constraints. We use these constraints to determine first an affine timing function and next an allocation by projection. We finally illustrate the method with three examples: the matrix multiplication, the recursive convolution and the LLt Cholesky factorization.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01192158</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CremersH78">
<author>Armin B. Cremers</author>
<author>Thomas N. Hibbard</author>
<title>Orthogonality of Information Structures.</title>
<pages>243-261</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#CremersH78</url>
<abstract>In the mathematical framework of data spaces the paper develops some important general principles of information structuring. These principles are related to the notions of redundancy of information, completeness of a set of access paths, information sharing and compounding, and virtual access to information. The results are relevant to both sequential and concurrent processing.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288884</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KirousisV95"> 
<author>Lefteris M. Kirousis</author>
<author>Andreas G. Veneris</author>
<title>Efficient Algorithms for Checking the Atomicity of a Run of Read and Write Operations.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>2</number>
<year>1995</year> 
<pages>155-170</pages>
<url>db/journals/acta/acta32.html#KirousisV95</url>
<abstract>LetX 1,...,X c be variables shared by a number of processorsP 1,...,P q that operate in a totally asynchronous and wait-free manner. An operation by a processor is either a write to one of the variables or a read of the values ofall variables. Operations arenot assumed to be instantaneous and may arbitrarily overlap in time. A succession of possibly overlapping operationsa 1,...,a n (i.e., a run) is said to be atomic, if these operations can be serialized in a way compatible with any existing precedences among them and so that any read operation returns for each variable the value of the most recent — with respect to the serialization — write operation on this variable. This paper examines the complexity of the combinatorial problem of testing a run for atomicity. First, it is pointed out that when there is only one shared variable or when only one processor is allowed to write to each variable, known theorems lead to polynomial-time algorithms for checking the atomicity of a run (the variable of the time-complexity function is the number of operations in the run). It is then proved that checking atomicity has polynomial-time complexity in the general case of more than one variables and with all processors allowed to read and write each variable. For the proof, the atomicity problem is reduced to the problem of consecutive 1s in matrices. The reduction entails showing a combinatorial result that might be interesting on its own.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177745</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/MakinenS02">
<author>Erkki M&auml;kinen</author>
<author>Tarja Syst&auml;</author>
<title>Minimally adequate teacher synthesizes statechart diagrams.</title>
<pages>235-259</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038004/20380235.htm</ee>
<url>db/journals/acta/acta38.html#MakinenS02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BakkerM87">
<author>J. W. de Bakker</author>
<author>John-Jules Ch. Meyer</author>
<title>Order and Metric in the Stream Semantics of Elemental Concurrency.</title>
<pages>491-511</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#BakkerM87</url>
<abstract>Two denotational semantics for a language with simple concurrency are presented. The language has parallel composition in the form of the shuffle operation, in addition to the usual sequential concepts including full recursion. Two linear time models, both involving sets of finite and infinite streams, are given. The first model is order-theoretic and based on the Smyth order. The second model employs complete metric spaces. Various technical results are obtained relating the order-theoretic and metric notions. The paper culminates in the proof that the two semantics for the language considered coincide. The paper completes previous investigations of the same language, establishing the equivalence of altogether four semantic models for it.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263291</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Orman97">
<author>Levent V. Orman</author>
<title>Relational Database Constraints as Counterexamples.</title>
<pages>167-189</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta34.html#Orman97</url>
<abstract> First order static database constraints are expressed as counterexamples, i.e., examples that violate the integrity of the database. Examples are data and as such they can be specified and stored as data, and structured into database files for efficient search and retrieval. To express all first order constraints as counterexamples, a new normal form for first order logic is created which, after some syntactic transformation, is amenable to storage in flat files, and efficient search and retrieval. The critical contribution is the ability to manage a large number constraints on secondary storage devices, and eliminate the requirement to transport all constraints to main memory for testing.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050078</ee>
</article>
<article mdate="2015-06-15" key="journals/acta/SchneiderCS85">
<author>Fred B. Schneider</author>
<author>Richard Conway 0003</author>
<author>Dale Skeen</author>
<title>Thrifty Execution of Task Pipelines.</title>
<pages>35-45</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#SchneiderCS85</url>
<abstract>A sequence of tasks that must be performed on a sequential database can be scheduled in various ways. Schedules will differ with respect to the number of accesses made to peripheral storage devices and the amount of memory space consumed by buffers. Buffer requirements are discussed for task schedules that avoid accesses to peripherals storing the sequential database. The relationship between certain thrifty scheduling policies and loop jamming, a standard code optimization technique, is also identified. Application to UNIX pipelines and to file processing is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290144</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MarcusM92">
<author>Leo Marcus</author>
<author>Telis Menas</author>
<title>Expressibility of Output Equals Input.</title>
<pages>645-662</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#MarcusM92</url>
<abstract>We examine the common and seemingly simple specification that the output stream equals the input stream. We show that this is not in full generality expressible in first-order or temporal logic by an infinite set of sentences or a recursive specification, but requires certain extra assumptions, such as the existence of a clock or discrete input values.The main negative results are stated for first-order expressibility and have direct corollaries for inexpressibility in first-order temporal logic: output equals input with arbitrary delay is not expressible by a (perhaps infinite) theory (Theorems 2 and 3), even with a timestamp (Theorem 8), and is not expressible for an ω timeline by a sentence, even with a timestamp (Theorem 10). Output equals input with constant delay cannot be expressed for ω timeline by a sentence with extra unary predicates over the timeline.As an example of the positive results, we show output equals input can be expressed by a sentence in the language with a (weak) clock if the base model contains either an extra function (Theorem 14), or arithmetic (Theorem 15).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185565</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MarloweR90">
<author>Thomas J. Marlowe</author>
<author>Barbara G. Ryder</author>
<title>Properties of Data Flow Frameworks.</title>
<pages>121-163</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta28.html#MarloweR90</url>
<abstract>A comprehensive overview of data flow frameworks and their characterizing properties is presented, to clarify property definitions and demonstrate their interrelation. Properties ensuring the existence of a solution are differentiated from those guaranteeing particular convergence behavior for specific solution procedures. Examples illustrate the orthogonality of these precision and convergence properties. In addition, several data flow problems are categorized with respect to these properties.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01237234</ee>
</article>
<article mdate="2007-09-11" key="journals/acta/MorrisT07">
<author>Joseph M. Morris</author>
<author>Malcolm Tyrrell</author>
<title>Dual unbounded nondeterminacy, recursion, and fixpoints.</title>
<pages>323-344</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>In languages with unbounded demonic and angelic nondeterminacy, functions acquire a surprisingly rich set of fixpoints. We show how to construct these fixpoints, and describe which ones are suitable for giving a meaning to recursively defined functions. We present algebraic laws for reasoning about them at the language level, and construct a model to show that the laws are sound. The model employs a new kind of power domain-like construct for accommodating arbitrary nondeterminacy.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0049-9</ee>
<url>db/journals/acta/acta44.html#MorrisT07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FalinDA94">
<author>Gennadi Falin</author>
<author>M. Mart&igrave;n D&igrave;az</author>
<author>Jesus R. Artalejo</author>
<title>Information Theoretic Approximations for the <i> M/G/ </i> 1 Retrial Queue.</title>
<pages>559-571</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#FalinDA94</url>
<abstract>In this paper we present information theoretic approximations for theM/G/1 queue with retrials. Various approximations for this model are obtained according to the available information about the service time probability density and the steady-state distribution of the system state. The results are well-suited for numerical computation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213207</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Knuth71a"> 
<author>Donald E. Knuth</author>
<title>Top-Down Syntax Analysis.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>79-110</pages>
<url>db/journals/acta/acta1.html#Knuth71a</url>
<abstract>The theory and practice of classical “top-down” parsing methods is presented in a tutorial manner.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289517</ee>
</article>

<article mdate="2015-01-08" key="journals/acta/MeyerO89">
<author>John-Jules Ch. Meyer</author>
<author>Ernst-R&uuml;diger Olderog</author>
<title>Hiding in Stream Semantics of Uniform Concurrency.</title>
<pages>381-397</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta27.html#MeyerO89</url>
<abstract>This paper shows how to treat the hiding operator originally defined by Hoare et al. for finite observations of processes, in an order theoretic setting based on finite and infinite streams. The main technical contribution is the continuity proof of the hiding operator based on a mixture of topological and order-theoretic arguments. As an application of the continuity of hiding, syntactic transformation rules for its calculation are derived. This calculus utilizes a general fixed point transformation technique.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289016</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BayerS84">
<author>Rudolf Bayer</author>
<author>Peter Schlichtiger</author>
<title>Data Management Support for Database Management.</title>
<pages>1-28</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BayerS84</url>
<abstract>Database management systems today face a rising demand for higher transaction rates and shorter response time. One of the essential requirements for meeting this demand is appropriate operating system support for database management functions. This paper proposes the introduction of the concept of “consistency-preserving containers” into data management in order to improve data management support for database management. Moreover, it presents the formal definition of a transactionoriented interface between data management and database management based on this concept, and introduces a locking scheme allowing high concurrency of transactions while guaranteeing consistency. Logging and recovery aspects of the concept are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289137</ee>
</article>
<article mdate="2004-05-17" key="journals/acta/FanSY98">
<author>Chen-Ming Fan</author>
<author>Huei-Jan Shyr</author>
<author>Shyr-Shen Yu</author>
<title>d-Words and d-Languages.</title>
<pages>709-727</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350709.htm</ee>
<url>db/journals/acta/acta35.html#FanSY98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AndersonB82">
<author>S. O. Anderson</author>
<author>Roland Carl Backhouse</author>
<title>An Alternative Implementation of an Insertion-Only Recovery Technique.</title>
<pages>289-298</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#AndersonB82</url>
<abstract>In an earlier paper [7] Fischer, Milton and Quiring developed algorithms for insertion-only error recovery. In related work [3] a simple factorisation lemma for error repairs was developed; by applying this lemma to the work of Fischer, Milton and Quiring their implementation is simplified and storage requirements reduced though there may be a small penalty in the execution time of the algorithm. In addition some flaws in their theoretical analyses are corrected and an alternative to the “immediate error detection property” is proposed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263195</ee>
</article>
<article mdate="2005-01-25" key="journals/acta/EpsteinT04">
<author>Leah Epstein</author>
<author>Tamir Tassa</author>
<title>Approximation schemes for the Min-Max Starting Time Problem.</title>
<pages>657-674</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>We consider the off-line scheduling problem of minimizing the maximal starting time. The input to this problem is a sequence of n jobs and m identical machines. The goal is to assign the jobs to the machines so that the first time at which all jobs have already started running is minimized, under the restriction that the processing of the jobs on any given machine must respect their original order. Our main result is a polynomial time approximation scheme (PTAS) for this problem in the case where m is considered as part of the input. As the input to this problem is a sequence of jobs, rather than a set of jobs where the order is insignificant, we present techniques that are designed to handle order constraints imposed by the sequence. Those techniques are combined with common techniques of assignment problems in order to yield a PTAS for this problem. We also show that when m is a constant, the problem admits a fully polynomial time approximation scheme. Finally, we show that the makespan problem in the linear hierarchical model may be reduced to the min-max starting time problem, thus concluding that the former problem also admits a PTAS.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0145-z</ee>
<url>db/journals/acta/acta40.html#EpsteinT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Harrison91">
<author>Peter G. Harrison</author>
<title>On the Expansion of Non-Linear Functions.</title>
<pages>559-574</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#Harrison91</url>
<abstract>Expansion theorems are obtained for classes of non-linear functions. From these, properties of some complex recursive functions are derived by finding equivalent non-recursive definitions, and a combinator-based formulation facilitates a simpler analysis than is typical of the applicative calculus approach.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463945</ee>
</article>
<article mdate="2009-05-20" key="journals/acta/Blondel98">
<author>Vincent D. Blondel</author>
<title>Structured Numbers: Properties of a Hierarchy of Operations on Binary Trees.</title>
<pages>1-15</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035001/80350001.htm</ee>
<url>db/journals/acta/acta35.html#Blondel98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nielsen74"> 
<author>Mogens Nielsen</author>
<title>EOL Systems with Control Devices.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>373-386</pages>
<url>db/journals/acta/acta4.html#Nielsen74</url>
<abstract>regular control on the use of subsets of productionsappearance checkingminimal table interpretationFinally the notions of matrix and vector control are introduced, and the effects of these mechanisms are investigated. This leads to results very much different from corresponding well-known results for context-free grammars.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289618</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Leung87">
<author>Clement H. C. Leung</author>
<title>Analysis of Space Allocation in a Generally Fragmented Linear Store.</title>
<pages>93-104</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#Leung87</url>
<abstract>The space allocation process in a fragmented linear store with general fragmentation characteristics is analysed. For a given allocation requirement t, exact expression for the n-th moment of the allocation penalty for single block contiguous allocation is obtained, which for large t is shown to be O(¯F(t)−n ), where ¯F(·) is the complementary distribution function of the free block sizes. For multiple block non-contiguous allocation, it is shown that the corresponding penalty can be approximated by an n-th degree polynomial and is O(t n) for large t. Compared with experimental values, the model results are able to achieve good agreement.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290708</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikK97">
<author>Karel Culik II</author>
<author>Jarkko Kari</author>
<title>Computational Fractal Geometry with WFA.</title>
<pages>151-166</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta34.html#CulikK97</url>
<abstract>We define two measures of “fractalness” of gray-tone images: the degree of self-similarity and the gray-tone fractal dimension as a generalization of Minkovski dimension of compact sets. We show how to compute both these measures from the WFA-representation of a gray-tone image. Since we have developed a WFA-inference algorithm which computes a good approximation of any gray-tone image we can compute a close approximation of both our measures of fractalness for any gray-tone image.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050077</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/OstrandPW81">
<author>Thomas J. Ostrand</author>
<author>Marvin C. Paull</author>
<author>Elaine J. Weyuker</author>
<title>Parsing Regular Grammars with Finite Lookahead.</title>
<pages>125-138</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#OstrandPW81</url>
<abstract>Not every unambiguous regular grammar can be parsed by a finite state machine, even if a lookahead facility is added to the machine's capabilities. Those which can be parsed with a fixed lookahead of k are said to be FL(k). If such a grammar has n non-terminals, it never needs more than (n(n−1)/2) + 1 lookahead, and there exist grammars which do require this much. An algorithm is presented for determining whether a grammar is fixed lookahead parsable, and if so, for finding the minimum lookahead needed. The algorithm sets up and solves a set of O(n2) equations using O(n4) steps. Two parsing methods for FL(k) grammars are discussed. One uses a large precomputed parsing table, and operates in real time. The second parses an input string in time proportional to its length, while using approximately 3n storage locations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261256</ee>
</article>
<article mdate="2010-04-28" key="journals/acta/CernaKK99">
<author>Ivana Cern&aacute;</author>
<author>Mojm&iacute;r Kret&iacute;nsk&yacute;</author>
<author>Anton&iacute;n Kucera</author>
<title>Comparing Expressibility of Normed BPA and Normed BPP Processes.</title>
<pages>233-256</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036003/90360233.htm</ee>
<url>db/journals/acta/acta36.html#CernaKK99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FischerM92">
<author>Charles N. Fischer</author>
<author>Jon Mauney</author>
<title>A Simple, Fast, and Effective LL(1) Error Repair Algorithm.</title>
<pages>109-120</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta29.html#FischerM92</url>
<abstract>Validation and locally least-cost repair are two simple and effective techniques for dealing with syntax errors. We show how the two can be combined into an efficient and effective error-handler for use with LL(1) parsers. Repairs are computed using an extension of the FMQ algorithm. Tables are created as necessary, rather than precomputed, and possible repairs are kept in a priority queue. Empirical results show that the repairs chosen with this strategy are of very high quality and that speed is quite acceptable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178502</ee>
</article>
<article mdate="2005-12-14" key="journals/acta/BergerHY05">
<author>Martin Berger</author>
<author>Kohei Honda</author>
<author>Nobuko Yoshida</author>
<title>Genericity and the pi-calculus.</title>
<pages>83-141</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>Types in processes delineate specific classes of interactive behaviour in a compositional way. Key elements of process theory, in particular behavioural equivalences, are deeply affected by types, leading to applications in the description and analysis of diverse forms of computing. As one of the examples of types for processes, this paper introduces a second-order polymorphic π-calculus based on duality principles, building on type structures coming from typed π-calculi, Linear Logic and game semantics. Of various extensions of first-order typed π-calculi with polymorphism, the present paper focusses on the linear polymorphic π-calculus, extending its first-order counterpart [46]. Fundamental elements of the theory of linear polymorphic processes are studied, including establishment of their strong normalisability using Girard's “candidates,” introduction of a behavioural theory of polymorphic labelled transitions which strengthens Pierce-Sangiorgi's polymorphic bisimulation via duality, and a fully abstract embedding of System F in polymorphic processes, establishing a precise connection between the universe of polymorphic functions and the universe of polymorphic processes. The proof combines process-theoretic reasoning with techniques from game semantics. The abstract nature of polymorphic labelled transitions plays an essential role in full abstraction, elucidating subtle aspects of polymorphism in functions and interaction.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0175-1</ee>
<url>db/journals/acta/acta42.html#BergerHY05</url>
</article>
<article mdate="2012-09-18" key="journals/acta/CaronCM12">
<author>Pascal Caron</author>
<author>Jean-Marc Champarnaud</author>
<author>Ludovic Mignot</author>
<title>Multi-tilde-bar expressions and their automata.</title>
<pages>413-436</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>The aim of this paper is to extend the family of Glushkov automata. This is achieved by designing new operators, the so-called multi-tilde-bar operators, that allow us to compute Glushkov functions for the associated extended expressions. Conversely an extended Glushkov automaton with \(n+1\) states can be converted into an extended expression with \(n\) occurrences of symbols. It leads to a characterization in terms of graphs of the family of extended Glushkov automata. Moreover, extended expressions are shown to be superpolynomially more succinct than standard expressions.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0167-x</ee>
<url>db/journals/acta/acta49.html#CaronCM12</url>
</article>
<article mdate="2005-01-25" key="journals/acta/Mahmoud04a">
<author>Hosam M. Mahmoud</author>
<title>Erratum: The size of random bucket trees via urn models.</title>
<pages>63</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0148-9</ee>
<url>db/journals/acta/acta41.html#Mahmoud04a</url>
</article>
<article mdate="2014-05-14" key="journals/acta/BloemCGHHJKK14">
<author>Roderick Bloem</author>
<author>Krishnendu Chatterjee</author>
<author>Karin Greimel</author>
<author>Thomas A. Henzinger</author>
<author>Georg Hofferek</author>
<author>Barbara Jobstmann</author>
<author>Bettina K&ouml;nighofer</author>
<author>Robert K&ouml;nighofer</author>
<title>Synthesizing robust systems.</title>
<pages>193-220</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>Systems should not only be correct but also robust in the sense that they behave reasonably in unexpected situations. This article addresses synthesis of robust reactive systems from temporal specifications. Existing methods allow arbitrary behavior if assumptions in the specification are violated. To overcome this, we define two robustness notions, combine them, and show how to enforce them in synthesis. The first notion applies to safety properties: If safety assumptions are violated temporarily, we require that the system recovers to normal operation with as few errors as possible. The second notion requires that, if liveness assumptions are violated, as many guarantees as possible should be fulfilled nevertheless. We present a synthesis procedure achieving this for the important class of GR(1) specifications, and establish complexity bounds. We also present an implementation of a special case of robustness, and show experimental results.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0191-5</ee>
<url>db/journals/acta/acta51.html#BloemCGHHJKK14</url>
</article>
<article mdate="2005-01-25" key="journals/acta/DelvauxH04">
<author>Steven Delvaux</author>
<author>Leon Horsten</author>
<title>On best transitive approximations to simple graphs.</title>
<pages>637-655</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>In this paper, we investigate both combinatorial and complexity aspects of the problem of finding best transitive approximations to simple graphs. These problems are addressed in an interlocked way. We provide new and simple proofs of known results and in addition prove some new theorems.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0144-0</ee>
<url>db/journals/acta/acta40.html#DelvauxH04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/GenlebeTB73"> 
<author>Erol Gelenbe</author>
<author>Paolo Tiberio</author>
<author>J. C. A. Boekhorst</author>
<title>Page Size in Demand-Paging Systems.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>1-23</pages>
<url>db/journals/acta/acta3.html#GenlebeTB73</url>
<abstract>The problem of determining page size in a page on demand system is discussed in detail in this paper. After having introduced the problem, the effect page size may have on various system performance measures is reviewed based on measurements of program behaviour and on simple models of system behaviour.This discussion is followed by a detailed study of the effect of the choice of page size on the efficient utilization of primary memory space. The wasted space-time integral (WSTI) of primary memory space is selected as a measure of this utilisation and a new model of program and system behaviour is used to compute the WSTI for different secondary memory devices (drum, ECS and LCS) and different system behaviour parameters such as the time spent in supervisor mode by the operating system to initiate a page transfer, the time spent in the CPU queue by a program which has recovered from a page fault before it receives the attention of the CPU, the global page fault rate (or arrival rate at the secondary storage devices used for paging) and other factors. The influence of each of these factors is discussed and analyzed, and the conditions under which one or another of these dominates the problem is identified.In the Appendix, one of the problems posed by our model, the use of approximate formulae for fragmentation which remain valid for a large class of probability distribution functions of program size, is analyzed in detail. Some tests are developed for the validity of these formulae.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288648</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/WirsingPPD83">
<author>Martin Wirsing</author>
<author>Peter Pepper</author>
<author>Helmuth Partsch</author>
<author>Walter Dosch</author>
<title>On Hierarchies of Abstract Data Types.</title>
<pages>1-33</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#WirsingPPD83</url>
<abstract>Hierarchical abstract data types are algebraic specifications of computation structures where certain sorts, function symbols, and axioms are designated as being primitive. On hierarchical abstract data types additional structure is imposed. An algebraic specification is thus decomposed into several well-separated levels, such that both the understanding and the independent implementation of the levels is supported. This paper provides both model-theoretic and deduction-oriented conditions guaranteeing the soundness of a hierarchical specification. Furthermore necessary and sufficient conditions for the existence of initial and terminal models are investigated, and their close connection to the soundness of a hierarchy is demonstrated. In order to provide freedom and flexibility for specifications a wide class of axioms — namely universal-existential formulas — are admitted.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264293</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Torlone94">
<author>Riccardo Torlone</author>
<title>Update Operations in Deductive Databases with Functional Dependencies.</title>
<pages>573-600</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#Torlone94</url>
<abstract>We study the problem of updating intensional relations in the framework of deductive databases on which integrity constraints (specifically functional dependencies) are defined. First, a formalization of a model-theoretic semantics of updates is provided: the notions ofrepresentability, consistency anddeterminism are introduced to characterize the various cases. Then, a proof-theoretic approach, based on a variant of resolution integrated with the chase procedure, is defined, showing that the method exactly captures the above notions. It turns out that using functional dependencies it is possible to resolve potential ambiguities in several practical cases. Also, precomputations can be performed at definition time to execute update requests more efficiently.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213208</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EngelfrietLR88">
<author>Joost Engelfriet</author>
<author>George Leih</author>
<author>Grzegorz Rozenberg</author>
<title>Apex Graph Grammars and Attribute Grammars.</title>
<pages>537-571</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta25.html#EngelfrietLR88</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00279953</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Miyakawa85">
<author>Masahiro Miyakawa</author>
<title>Optimum Decision Trees - An Optimal Variable Theorem and its Related Applications.</title>
<pages>475-498</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta22.html#Miyakawa85</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00267042</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SackS85">
<author>J&ouml;rg-R&uuml;diger Sack</author>
<author>Thomas Strothotte</author>
<title>An Algorithm for Merging Heaps.</title>
<pages>171-186</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#SackS85</url>
<abstract>We present an algorithm to merge priority queues organized as heaps. The worst case number of comparisons required to merge two heaps of sizes k and n is O(log(n)*log(k)). The algorithm requires O(k) +log(n)*log (k)) data movements if heaps are implemented using arrays and O(log(n)*log(k)) for a pointer-based implementation. Previous algorithms require either O(n+k) data movements and comparisons, or O(k*log(log(n+k))) comparisons and O(k*log(n+k)) data movements. The algorithm presented in this paper improves on the previous algorithms for the case when k>log(n).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264229</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Krishnamurthy85">
<author>Balakrishnan Krishnamurthy</author>
<title>Short Proofs for Tricky Formulas.</title>
<pages>253-275</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta22.html#Krishnamurthy85</url>
<abstract>The object of this paper is to demonstrate how certain tricky mathematical arguments can be encoded as short formal proofs for the propositional tautologies representing the mathematical statements. Using resolution as a base proof system for the propositional calculus, we exhibit these short proofs under resolution augmented by one of two principles: the principle of extension, originally suggested by Tseitin, and the principle of symmetry, introduced in this paper. These short proofs illustrate the power of extension and symmetry in theorem proving.The principle of extension allows the introduction of auxiliary variables to represent intermediate formulas so that the length of a proof can be significantly reduced by manipulating these variables instead of the formulas that they stand for. Symmetry, on the other hand, allows one to recognize that a tautology remains invariant under certain permutations of variable names, and use that information to avoid repeated independent derivations of intermediate formulas that are merely permutational variants of one another.First we show that a number of inductive arguments can be encoded as short formal proofs using either extension or symmetry. We provide the details for the tautologies derived by encoding the statement, “An acyclic digraph on n vertices must have a source.” We then consider the familiar checkerboard puzzle which asserts that a checkerboard, two of whose diagonally opposite corner squares are removed, cannot be perfectly covered with dominoes. We demonstrate short proofs for the tautologies derived from the above assertion, using extension to mimic the tricky informal argument. Finally, we consider statements asserting the Ramsey property of numbers much larger than the critical Ramsey numbers. We show that the proof of Ramsey's theorem can be imitated using the principle of symmetry to yield short proofs for these tautologies.The main theme of the paper is that both extension and symmetry are very powerful augmentations to resolution. We leave open whether either extension or symmetry can polynomially simulate the other.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265682</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wright85">
<author>William E. Wright</author>
<title>Some Average Performance Measures for the B-Tree.</title>
<pages>541-557</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Wright85</url>
<abstract>Several average performance measures are presented for large B-trees formed from insertions, where large refers to the number of keys. Formulas are first derived for the expected number of nodes of each size on the bottom level of the tree, where the size of a node is the number of keys currently contained in the node. This is followed by formulas for the probability of making an insertion into a node of a given size, the probability of a split during an insertion into a node, and the expected number of splits during an insertion into the tree. It is shown that for large trees of high order m, the expected number of splits per insertion is approximately 1/((ln 2) m). A formula is presented for the average storage utilization, and it is shown that this average approaches ln 2 as m approaches infinity. A simpler formula is derived for the average storage utilization at the bottom level of the tree, and it is shown that this formula is an increasing function of m ranging from 2/3 to ln 2. It is shown that the expected tree height and the expected search path length are approximately logarithmic to the base (ln 2) m. Simulation results are presented to corroborate the theoretical analysis.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289710</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Lamport80">
<author>Leslie Lamport</author>
<title>The `Hoare Logic' of Concurrent Programs.</title>
<pages>21-37</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Lamport80</url>
<abstract>Hoare's logical system for specifying and proving partial correctness properties of sequential programs is generalized to concurrent programs. The basic idea is to define the assertion {P} S {Q} to mean that if execution is begun anywhere in S with P true, then P will remain true until S terminates, and Q will be true if and when S terminates. The predicates P and Q may depend upon program control locations as well as upon the values of variables. A system of inference rules and axiom schemas is given, and a formal correctness proof for a simple program is outlined. We show that by specifying certain requirements for the unimplemented parts, correctness properties can be proved without completely implementing the program. The relation to Pnueli's temporal logic formalism is also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289062</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Cristian82">
<author>Flaviu Cristian</author>
<title>Robust Data Types.</title>
<pages>365-397</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Cristian82</url>
<abstract>Data types with total operations and exceptions are proposed as basic building blocks for the construction of modular robust software. A notation for specifying such data types is presented and the issues underlying their correct implementation in a programming language supporting data abstraction and exception handling are discussed and illustrated by examples. New light is shed on some important aspects of exception handling such as the identification and specification of exceptions, the precise detection of exception occurrences, recovery of consistent states after exception detections and verification of the correct implementation of specified exceptional effects for operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264158</ee>
</article>
<article mdate="2005-01-25" key="journals/acta/Mahmoud04">
<author>Hosam M. Mahmoud</author>
<title>Random sprouts as internet models, and P&oacute;lya processes.</title>
<pages>1-18</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The sprout, a tree growing in real time is introduced. The sprout is a generalization and an embedding in time of the standard recursive tree. The sprout is proposed as a model for the growth of the Internet. The tree size is analyzed via an associated two-color stochastic process (the sprout process), which is a special case of the Pólya process. Owing to its potential as a modeling tool, the more general Pólya process is analyzed on average. In addition to the usage of the Pólya process in evaluating sprouts, we also give a heuristic interpretation of the result for Pólya urns, which might be a first step toward understanding several nonclassic urn models, as those with nonconstant row sum and those with multiple eigenvalues.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0146-y</ee>
<url>db/journals/acta/acta41.html#Mahmoud04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BayerS77">
<author>Rudolf Bayer</author>
<author>Mario Schkolnick</author>
<title>Concurrency of Operations on  B-Trees.</title>
<pages>1-21</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#BayerS77</url>
<abstract>Concurrent operations on B-trees pose the problem of insuring that each operation can be carried out without interfering with other operations being performed simultaneously by other users. This problem can become critical if these structures are being used to support access paths, like indexes, to data base systems. In this case, serializing access to one of these indexes can create an unacceptable bottleneck for the entire system. Thus, there is a need for locking protocols that can assure integrity for each access while at the same time providing a maximum possible degree of concurrency. Another feature required from these protocols is that they be deadlock free, since the cost to resolve a deadlock may be high.Recently, there has been some questioning on whether B-tree structures can support concurrent operations. In this paper, we examine the problem of concurrent access to B-trees. We present a deadlock free solution which can be tuned to specific requirements. An analysis is presented which allows the selection of parameters so as to satisfy these requirements.The solution presented here uses simple locking protocols. Thus, we conclude that B-trees can be used advantageously in a multi-user environment.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263762</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NurmiS96">
<author>Otto Nurmi</author>
<author>Eljas Soisalon-Soininen</author>
<title>Chromatic Binary Search Trees. A Structure for Concurrent Rebalancing.</title>
<pages>547-557</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#NurmiS96</url>
<abstract>We propose a new rebalancing method for binary search trees that allows rebalancing and updating to be uncoupled. In this way we obtain fast updates and, whenever the search tree is accessed by multiple users, a high degree of concurrency. The trees we use are obtained by relaxing the balance conditions ofred-black trees. The relaxed red-black trees, calledchromatic trees, contain information of possible imbalance such that the rebalancing can be done gradually as a shadow process, or it can be performed separately when no urgent operations are present.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036462</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TamminenLSWW86">
<author>Markku Tamminen</author>
<author>W. K. Luk</author>
<author>Paolo Sipala</author>
<author>Lin S. Woo</author>
<author>C. K. Wong</author>
<title>Constructing Maximal Slicings from Geometry.</title>
<pages>267-288</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#TamminenLSWW86</url>
<abstract>We present an optimal algorithm to determine whether a placement of N isothetic non-overlapping rectangles (macros) can be represented by a slicing tree, and if so, to find a representation of minimal height. A slicing is a recursive partition of the overall bounding rectangle, by straight horizontal or vertical cuts, into rectangular regions, each one containing exactly one macro. The algorithm first determines a representation of the empty space of the placement by means of maximally extended horizontal and vertical channels. A second phase then generates a maximal slicing tree (an ordered tree with unbounded degree and maximal branching, i.e., minimal height) in a top-down fashion. The complexity of each phase is O(N log N). The problem arises in steps (1) and (2) of our top-down approach to VLSI custom chip design, which consists of (1) floorplanning by slicing, (2) hierarchicial global wiring, and (3) detailed layout of macros.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289114</ee>
</article>
<article mdate="2009-03-05" key="journals/acta/Ben-Amram09">
<author>Amir M. Ben-Amram</author>
<title>A complexity tradeoff in ranking-function termination proofs.</title>
<pages>57-72</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>To prove that a program terminates, we can employ a ranking function argument, where program states are ranked so that every transition decreases the rank. Alternatively, we can use a set of ranking functions with the property that every cycle in the program’s flow-chart can be ranked with one of the functions. This “local” approach has gained interest recently on the grounds that local ranking functions would be simpler and easier to find. The current study is aimed at better understanding the tradeoffs involved, in a precise quantitative sense. We concentrate on a convenient setting, the Size-Change Termination framework (SCT). In SCT, programs are replaced by an abstraction whose termination is decidable. Moreover, sufficient classes of ranking functions (both global and local) are known. Our results show a tradeoff: either exponentially many local functions of certain simple forms, or an exponentially complex global function may be required for proving termination.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0085-0</ee>
<url>db/journals/acta/acta46.html#Ben-Amram09</url>
</article>
<article mdate="2004-06-28" key="journals/acta/BarbutiT04">
<author>Roberto Barbuti</author>
<author>Luca Tesei</author>
<title>Timed automata with urgent transitions.</title>
<pages>317-347</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We propose an extension to the formalism of timed automata by allowing urgent transitions. An urgent transition is a transition which must be taken within a fixed time interval from its enabling time and it has higher priority than other non-urgent transitions enabled in the same state. We give a set of rules formally describing the behavior of urgent transitions and we show that, from a language theoretic point of view, the addition of urgency does not improve the expressive power of timed automata. From a specification point of view, the use of urgent transitions allows shorter and clear specifications of behaviors involving urgency and priority. We use timed automata with urgent transitions for specifying a multicast protocol for mobile computing.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0135-6</ee>
<url>db/journals/acta/acta40.html#BarbutiT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AutebertBB82">
<author>Jean-Michel Autebert</author>
<author>Joffroy Beauquier</author>
<author>Luc Boasson</author>
<title>Formes de langages et de grammaires.</title>
<pages>193-213</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#AutebertBB82</url>
<abstract>This paper is devoted to the study of context-free languages over infinite alphabets. This work can be viewed as a new attempt to study families of grammars, replacing the usual “grammar forms” and giving a new point of view on these questions. A language over an infinite alphabet or I-language appears as being a model for a family of usual languages; an interpretation is an homomorphism from the infinite alphabet to any finite alphabet. Using this notion of interpretation we can associate to each family of I-languages an image, called its shadow, which is a family of usual languages.The closure properties of families, generalizing to infinite alphabets the family of context-free languages, lead to define rational transductions between infinite alphabets or I-transductions, and then, families of I-languages closed under I-transductions, or I-cones. We study here relations between the closure properties of a family of I-languages and these of its shadow. As a result, we obtain that any union closed rational cone of context-free languages, principal or not, is the shadow of a principal I-cone.This work leads to new results about the classical theory of context-free languages. For instance, we prove that any principal rational cone of context-free languages can be generated by a context-free language, whose grammar has only 6 variables. This work also leads to more general considerations about the adequacy of some generating devices to the generated languages. It appears that the context-free grammars are fair, in a sense that we define, for generating context-free languages but that non-expansive context-free grammars are not for generating non-expansive context-free languages. This point of view raises a number of questions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288970</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BenderPW87">
<author>Edward A. Bender</author>
<author>Cheryl E. Praeger</author>
<author>Nicholas C. Wormald</author>
<title>Optimal Worst Case Trees.</title>
<pages>475-489</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#BenderPW87</url>
<abstract>Design and analysis of sorting and searching algorithms lead to the study of rooted trees with information stored either at the leaves or at all vertices. We consider the problem of minimising the maximum search cost when n items must be stored. Trees which achieve this minimum are almost regular and can usually be found in constant time. If regular trees are used, the maximum cost for a search is nearly best possible. If information is stored at all vertices, the root degree of large optimum trees take on one of two adjacent values, and both usually occur infinitely often for linear cost.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292115</ee>
</article>
<article mdate="2012-01-27" key="journals/acta/CoffmanDK12">
<author>Edward G. Coffman Jr.</author>
<author>Dariusz Dereniowski</author>
<author>Wieslaw Kubiak</author>
<title>An efficient algorithm for finding ideal schedules.</title>
<pages>1-14</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We study the problem of scheduling unit execution time jobs with release dates and precedence constraints on two identical processors. We say that a schedule is ideal if it minimizes both maximum and total completion time simultaneously. We give an instance of the problem where the min-max completion time is exceeded in every preemptive schedule that minimizes total completion time for that instance, even if the precedence constraints form an intree. This proves that ideal schedules do not exist in general when preemptions are allowed. On the other hand, we prove that, when preemptions are not allowed, then ideal schedules do exist for general precedence constraints, and we provide an algorithm for finding ideal schedules in O(n 3) time, where n is the number of jobs. In finding such ideal schedules we resolve a conjecture of Baptiste and Timkovsky (Math. Methods Oper. Res. 60(1):145–153, 2004) Further, our algorithm for finding min-max completion-time schedules requires only O(n 3) time, while the most efficient solution to date has required O(n 9) time.</abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0146-7</ee>
<url>db/journals/acta/acta49.html#CoffmanDK12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FiadeiroS88">
<author>Jos&eacute; Luiz Fiadeiro</author>
<author>Am&iacute;lcar Sernadas</author>
<title>Specification and Verification of Database Dynamics.</title>
<pages>625-661</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta25.html#FiadeiroS88</url>
<abstract>A framework is proposed for the structured specification and verification of database dynamics. In this framework, the conceptual model of a database is a many sorted first order linear tense theory whose proper axioms specify the update and the triggering behaviour of the database. The use of conceptual modelling approaches for structuring such a theory is analysed. Semantic primitives based on the notions of event and process are adopted for modelling the dynamic aspects. Events are used to model both atomic database operations and communication actions (input/output). Nonatomic operations to be performed on the database (transactions) are modelled by processes in terms of trigger/reaction patterns of behaviour. The correctness of the specification is verified by proving that the desired requirements on the evolution of the database are theorems of the conceptual model. Besides the traditional data integrity constraints, requirements of the form “Under condition W, it is guaranteed that the database operation Z will be successfully performed” are also considered. Such liveness requirements have been ignored in the database literature, although they are essential to a complete definition of the database dynamics.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00291052</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Shore82">
<author>John E. Shore</author>
<title>Information Theoretic Approximations for <i> M/G/ </i> 1 und <i> G/G/ </i> 1 Queuing Systems.</title>
<pages>43-61</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Shore82</url>
<abstract>This paper presents new results concerning the use of information theoretic inference techniques in system modeling and concerning the widespread applicability of certain simple queuing theory formulas. For the case when an M/G/1 queue provides a reasonable system model but when information about the service time probability density is limited to knowledge of a few moments, entropy maximization and cross-entropy minimization are used to derive information theoretic approximations for various performance distributions such as queue length, waiting time, residence time, busy period, etc. Some of these approximations are shown to reduce to exact M/M/1 results when G = M. For the case when a G/G/1 queue provides a reasonable system model, but when information about the arrival and service distributions is limited to the average arrival and service rates, it is shown that various well known M/M/1 formulas are information theoretic approximations. These results not only provide a new method for approximating the performance distributions, but they help to explain the widespread applicability of the M/M/1 formulas.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262975</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KleinH83">
<author>Peter Klein</author>
<author>Friedhelm Meyer auf der Heide</author>
<title>A Lower Time Bound for the Knapsack Problem on Random Access Machines.</title>
<pages>385-395</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#KleinH83</url>
<abstract>We consider random access machines which read the input integer by integer (not bit by bit). For this computational model we prove a quadratic lower bound for the n-dimensional knapsack problem. For this purpose, we combine a method due to Paul and Simon [1] to apply decision tree arguments to random access machines (with indirect storage access!) and a method due to Dobkin and Lipton [2] who proved the same lower bound for linear decision trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290735</ee>
</article>
<article mdate="2006-05-10" key="journals/acta/Hesselink06">
<author>Wim H. Hesselink</author>
<title>Splitting forward simulations to copewith liveness.</title>
<pages>583-602</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>In the literature, the conditions on history variables or forward simulations that are related to liveness are expressed in terms of behaviours, and are stronger than convenient and necessary. In this paper, we propose alternative conditions on the simulation relation, which are expressed in terms of the next state relation, and are closely tied to the weak or strong fairness conditions of the specifications. The proof of soundness of this proposal is based on a new theorem that asserts the existence of a strongly fair scheduler for infinitely many alternatives. The theory is extended to simulations in which the concrete specification (occasionally) does fewer steps than the abstract specification it implements.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0007-y</ee>
<url>db/journals/acta/acta42.html#Hesselink06</url>
</article>
<article mdate="2005-03-14" key="journals/acta/LamoureuxN05">
<author>Michael G. Lamoureux</author>
<author>Bradford G. Nickerson</author>
<title>A deterministic skip list for k-dimensional range search.</title>
<pages>221-255</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>This paper presents a new data structure for multi-dimensional point data which is based on an extension of the deterministic skip list data structure projected into k dimensions. The structure is labeled the k-d Range Deterministic Skip List and it supports fast insertions, deletions, and range search. The k-d Range Deterministic Skip List is optimal (i.e. \(\Theta (\lg^{{\rm k}}n + \)t) to locate and report t of n data points in range) for k-dimensional range search, assuming that our data points are elements of a commutative semigroup with set union as the commutative and associative addition operation. A dynamic data structure is defined to be optimally balanced if the product of its worst case cost functions for k-dimensional range search, insertion, deletion, storage, and preprocessing is minimal. The k-d Range Deterministic Skip List is found to be optimally balanced based on this definition.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://www.springerlink.com/index/10.1007/s00236-004-0157-8</ee>
<url>db/journals/acta/acta41.html#LamoureuxN05</url>
</article>
<article mdate="2003-11-25" key="journals/acta/MoffatPW98">
<author>Alistair Moffat</author>
<author>Ola Petersson</author>
<author>Nicholas C. Wormald</author>
<title>A Tree-Based Mergesort.</title>
<pages>775-793</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035009/80350775.htm</ee>
<url>db/journals/acta/acta35.html#MoffatPW98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AtrawalaT82">
<author>Ashok K. Agrawala</author>
<author>Satish K. Tripathi</author>
<title>On an Exponential Server with General Cyclic Arrivals.</title>
<pages>319-334</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#AtrawalaT82</url>
<abstract>A E n¦ M ¦ 1 queue is defined as a single server queue with exponential service time and general cyclic arrival distributions of cycle length n. The waiting time distribution for such a queue is proved to be a sum of n exponential terms; this is a generalization of G ¦ M ¦ 1 queue results. Based on this a method for obtaining the steady-state waiting time distributions for E n¦ M ¦ 1 queues is introduced. An example is presented to show an application of E n¦ M ¦ 1 queues in deterministic routing.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263197</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Eichner74"> 
<author>Lutz Eichner</author>
<title>Total lineare Realisierbarkeit endlicher Automaten.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>385-397</pages>
<url>db/journals/acta/acta3.html#Eichner74</url>
<abstract>Starting out from the research in [1] we prove: If a finite sequential machine a is linearly realizable over a finite field with characteristic 2 and additional over a finite field with characteristic ≠2, then a is linearly realizable over every finite field. Moreover we will see, that a is linearly realizable over every finite field if and only if the extended output function satisfies certain conditions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263591</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Deussen75"> 
<author>Peter Deussen</author>
<title>A Decidability Criterion for van Wijngaarden Grammars.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>353-375</pages>
<url>db/journals/acta/acta5.html#Deussen75</url>
<abstract>Van Wijngaarden grammars are a very useful instrument for syntactically describing even the most complex languages. This is illuminated specifically by describing the language of valid formulas of first order logic by a van Wijngaarden grammar.Normal forms of van Wijngaarden grammars and restrictions which guarantee decidability are discussed and ALGOL 68 is considered under these views.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264566</ee>
</article>

<article mdate="2005-11-14" key="journals/acta/EpsteinS05">
<author>Leah Epstein</author>
<author>Rob van Stee</author>
<title>Online square and cube packing.</title>
<pages>595-606</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>In online square packing, squares of different sizes arrive online and need to be packed into unit squares which are called bins. The goal is to minimize the number of bins used. Online cube packing is defined analogously. We show an upper bound of 2.2697 and a lower bound of 1.6406 for online square packing, and an upper bound of 2.9421 and a lower bound of 1.6680 for online cube packing. The upper bound for squares can be further reduced to 2.24437 using a computer proof. These results improve on the previously known results for the two problems. We also show improved lower bounds for higher dimensions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0169-z</ee>
<url>db/journals/acta/acta41.html#EpsteinS05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Beynon85">
<author>Meurig Beynon</author>
<title>Replaceability and Computational Equivalence for Monotone Boolean Functions.</title>
<pages>433-449</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#Beynon85</url>
<abstract>Replacement rules have played an important role in the study of monotone boolean function complexity. In this paper, notions of replaceability and computational equivalence are formulated in an abstract algebraic setting, and examined in detail for finite distributive lattices — the appropriate algebraic context for monotone boolean functions. It is shown that when computing an element f of a finite distributive lattice D, the elements of D partition into classes of computationally equivalent elements, and define a quotient of D in which all intervals of the form [t ∧ f, t ∨ f] are boolean. This quotient is an abstract simplicial complex with respect to ordering by replaceability. Other results include generalisations and extensions of known theorems concerning replacement rules for monotone boolean networks. Possible applications of computational equivalence in developing upper and lower bounds on monotone boolean function complexity are indicated, and new directions of research both abstract mathematical and computational, are suggested.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288777</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BertinoM88">
<author>Elisa Bertino</author>
<author>Daniela Musto</author>
<title>Correctness of Semantic Integrity Checking in Database Management Systems.</title>
<pages>25-57</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#BertinoM88</url>
<abstract>Although today’s applications are very demanding with regard to semantic integrity, few database systems provide capabilities of this type. In this paper, a definition of integrity constraint is given in terms of Relational Algebra and certain aspects are then discussed concerning transaction management in the presence of such integrity constraints. In particular, the problem of when to enforce a set of integrity constraints during the execution of a transaction is addressed. For this purpose the notion ofIntegrity Enforcement Schedule is introduced. An Integrity Enforcement Schedule represents the sequence of integrity checking actions performed during the execution of a transaction. A correctness criterion for the Integrity Enforcement Schedules is established, and a sufficient condition for the correctness is provided. Finally the notion ofMinimal Integrity Enforcement Schedule is introduced. The Minimal Integrity Enforcement Schedules are those Integrity Enforcement Schedules in which every constraint is verified ‘as soon as possible”. For this reason they are really desirable in the transaction management to avoid expensive rollingback operations. Algorithms for their construction are presented, together with the associated correctness proofs.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915445</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AvenhausM78">
<author>J&uuml;rgen Avenhaus</author>
<author>Klaus Madlener</author>
<title>Subrekursive Komplexit&auml;t bei Gruppen: II. Der Einbettungssatz von Higman f&uuml;r entscheidbare Gruppen.</title>
<pages>183-193</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#AvenhausM78</url>
<abstract>Higman's embedding theorem states that every recursively presented (r.p.) group can be embedded in a finitely presented (f.p.) group. We use the results of part I together with an idea of Aanderaa [1] to show that the embedding can be realized preserving the complexity of the word problem of the r.p. group.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289077</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DuC92">
<author>M. W. Du</author>
<author>S. C. Chang</author>
<title>A Model and a Fast Algorithm for Multiple Errors Spelling Correction.</title>
<pages>281-302</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta29.html#DuC92</url>
<abstract>A new model for multiple errors spelling correction is proposed. The model handles insert, delete, change, and transpose errors. In the new model, we put constraints on possible editing sequences to reflect the error occurrence phenomenon in spelling, resulting in an error measure different from the traditional editing distance error measure. Properties of the “error distance matrix” between two character strings are studied under the assumptions of the new model. A cut-off criterion has been discovered, which can detect whether the error distance between two character strings is greater than a prespecified value during the calculation. Based on this cut-off criterion, a fast algorithm has been developed to find the nearest neighbors of a given character string in a dictionary. Experiments have been conducted with results showing that the cut-off criterion can greatly cut down the computation time needed for the nearest neighbor searching.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185682</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Leeuwen79">
<author>Jan van Leeuwen</author>
<title>A Useful Lemma for Context-Free Programmed Grammars.</title>
<pages>373-386</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Leeuwen79</url>
<abstract>We show that all quasi-realtime one-way multi-counter languages can be generated by a context-free ɛ-free programmed grammar (even under the free interpretation). The result can be used to obtain a new and almost trivial proof of the fundamental theorem that arbitrary context-free programmed grammars can generate all recursively enumerable languages. The proof of our result also yields the following, interesting characterization: the quasi-realtime one-way multi-counter languages are precisely the ɛ-limited homomorphic images of (free) context-free programmed production languages. It follows that the (free) derivation languages of context-free or even context-free programmed grammars, which were known to be context-sensitive, are in fact contained in the family of context-free ɛ-free programmed languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289095</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SuzukiK83">
<author>Ichiro Suzuki</author>
<author>Tadao Kasami</author>
<title>Three Measures for Synchronic Dependence in Petri Nets.</title>
<pages>325-338</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#SuzukiK83</url>
<abstract>Three notions of distance for measuring the synchronic dependence of transition firings in Petri nets are studied. For the first two notions we present algorithms for obtaining a basis of the linear space of weight vectors for which the distance is finite, and methods for computing the distance for any given weight vector by examining a finite set of vectors obtained a priori. For the third notion of distance, the problem of deciding whether a given weight vector yields a finite distance is shown to be equivalent to the reachability problem. Finally it is shown that a basis of the linear space of weight vectors for which the weighted sum of token counts is bounded over all reachable markings can be obtained effectively. Also some complexity results are given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290730</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/RanjanPG00">
<author>Desh Ranjan</author>
<author>Enrico Pontelli</author>
<author>Gopal Gupta</author>
<title>Data structures for order-sensitive predicates in parallel nondeterministic systems.</title>
<pages>21-43</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037001/00370021.htm</ee>
<url>db/journals/acta/acta37.html#RanjanPG00</url>
</article>
<article mdate="2003-11-25" key="journals/acta/AstesianoR01">
<author>Egidio Astesiano</author>
<author>Gianna Reggio</author>
<title>Labelled transition logic: an outline.</title>
<pages>831-879</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>11-12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037011/10370831.htm</ee>
<url>db/journals/acta/acta37.html#AstesianoR01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KrzesinskiT78">
<author>Anthony E. Krzesinski</author>
<author>Peter Teunissen</author>
<title>A Multiclass Networt Model of a Demand Paging Computer System.</title>
<pages>331-343</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#KrzesinskiT78</url>
<abstract>The paper presents a multiclass network model of a demand paging computer system. The powerful class and class changing mechanism of a multiclass network are used to model the serial co-operation of user and system functions in program execution. The workload itself is modelled as a mix of programs, each with different CPU, I/O, paging and locality characteristics. The effect of paging, I/O and program termination overheads on systems performance is evaluated, as well as the transient overhead of rapid page loading upon program activation. The model is then used to compute the optimal multiprogramming level and the optimal multiprogramming mix as a function of workload composition and system overhead. The model is finally used to confirm certain heuristic load control rules proposed by Denning et al.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289046</ee>
</article>
<article mdate="2009-03-05" key="journals/acta/BashirovKL09">
<author>Rza Bashirov</author>
<author>Fabrice Kordon</author>
<author>H&uuml;seyin Lort</author>
<title>Exploiting colored Petri nets to decide on permutation admissibility.</title>
<pages>43-55</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this work, we propose an innovative approach to investigate the admissibility of permutations to multistage interconnection networks—a challenging problem of switching theory. The proposed approach is centered upon modeling of multistage interconnection networks with colored Petri nets and use of Petri net analysis tools such as the unfolding technique and the invariants method. To assess the feasibility of the proposed approach we demonstrate that the complete unfoldings obtained in this work are polynomial in the problem size and employ an acyclic structure. The approach takes advantage of easy to use, yet extremely efficient, software tools.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0084-1</ee>
<url>db/journals/acta/acta46.html#BashirovKL09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/OukselM92">
<author>Aris M. Ouksel</author>
<author>Otto Mayer</author>
<title>A Robust and Efficient Spatial Data Structure.</title>
<pages>335-373</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta29.html#OukselM92</url>
<abstract>A new structure for organizing a set of multidimensional points called the nested interpolation-based grid file (NIBGF) is introduced. The structure represents a synthesis and an improvement over interpolation-based grid files (IBGF), BANG files, andK-D-B-trees. It decomposes the data search space into uniquely identifiable regions which may either be disjoint as in interpolation-based grid files or enclose each other as in the BANG files. In addition to possessing the symmetry of access and clustering properties characteristic of grid file structures, the performance of NIBGF is comparable to aB-tree performance as far as the index is concerned, even in the worst case scenario, and to the BANG file performance as far as the data regions are concerned. These properties make the new structure suitable for efficient implementation of relational database operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178777</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Shostak77"> 
<author>Robert E. Shostak</author>
<title>On the Role of Unification in Mechanical Theorem Proving.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>319-323</pages>
<url>db/journals/acta/acta7.html#Shostak77</url>
<abstract>A generalization of the Skolem-Herbrand-Gödel Theorem is stated and proved, clarifying the role of unification in resolution. It is shown that any of the pre-resolution theorem-proving procedures of the Davis and Putnam variety can be upgraded to incorporate unification.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290340</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Mahmoud86">
<author>Hosam M. Mahmoud</author>
<title>On the Average Internal Path Length of <i> m </i> -ary Search Trees.</title>
<pages>111-117</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta23.html#Mahmoud86</url>
<abstract></abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00268078</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HarjuKL92">
<author>Tero Harju</author>
<author>H. C. M. Kleijn</author>
<author>Michel Latteux</author>
<title>Deterministic Sequential Functions.</title>
<pages>545-554</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#HarjuKL92</url>
<abstract>The simple rational partial functions accepted by generalized sequential machines are shown to coincide with the compositions ℋ ℋ P −1 ℋ, where ℋ P consists of the prefix codings. The rational functions accepted by generalized sequential machines are proved to coincide with the compositions ℋ ℳℋ P −1 ℛ ℋ , where ℳ is the family of endmarkers and ℛ is the family of removals of endmarkers. (The compositions are read from left to right). We also show that ℳ ℋℋ P −1 ℋ is the family of the subsequential functions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185560</ee>
</article>
<article mdate="2013-02-05" key="journals/acta/KleijnKPR13">
<author>Jetty Kleijn</author>
<author>Maciej Koutny</author>
<author>Marta Pietkiewicz-Koutny</author>
<author>Grzegorz Rozenberg</author>
<title>Step semantics of boolean nets.</title>
<pages>15-39</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Boolean nets are a family of Petri net models with very simple markings which are sets of places. We investigate several classes of boolean nets distinguished by different kinds of individual connections between places and transitions, as well as different ways in which these connections are combined in order to specify the effect of executing steps of transitions. The latter aspect can be captured by connection monoids. A key advantage of using connection monoids is that by describing the step semantics of a class of Petri nets in terms of a connection monoid, one can apply results developed within a general theory of Petri net synthesis. In this paper, we provide an extensive classification of boolean nets which can be described by connection monoids. This classification is based on the realisation that the different ways of interpreting combinations of connections can be made explicit using a higher level monoid. Moreover, we demonstrate that connection monoids can capture other behavioural properties of boolean nets, such as structural conflicts between transitions.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0170-2</ee>
<url>db/journals/acta/acta50.html#KleijnKPR13</url>
</article>
<article mdate="2003-11-25" key="journals/acta/BonnerM00">
<author>Anthony J. Bonner</author>
<author>Giansalvatore Mecca</author>
<title>Querying Sequence Databases with Transducers.</title>
<pages>511-544</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036007/00360511.htm</ee>
<url>db/journals/acta/acta36.html#BonnerM00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Unterauer79">
<author>Karl Unterauer</author>
<title>Dynamic Weighted Binary Search Trees.</title>
<pages>341-362</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Unterauer79</url>
<abstract>We present an algorithm which optimizes a weighted binary tree after an insertion or deletion. The resulting tree is nearly optimal. The algorithm needs O(n) space. In the case of an insertion the expected number of operations is equal to or less than the height of the tree. All results presented in this paper can also be found in [15].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289093</ee>
</article>
<article mdate="2004-05-17" key="journals/acta/ShyrY98">
<author>Huei-Jan Shyr</author>
<author>Shyr-Shen Yu</author>
<title>Bi-Catenation and Shuffle Product of Languages.</title>
<pages>689-707</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350689.htm</ee>
<url>db/journals/acta/acta35.html#ShyrY98</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Broy01">
<author>Manfred Broy</author>
<title>Letter from the Editor.</title>
<pages>227-228</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>4/5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037004/10370227.htm</ee>
<url>db/journals/acta/acta37.html#Broy01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hartmanis72"> 
<author>Juris Hartmanis</author>
<title>On Non-Determinancy in Simple Computing Devices.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>336-344</pages>
<url>db/journals/acta/acta1.html#Hartmanis72</url>
<abstract>This paper studies one-tape Turing machines with k read-only heads which are restricted to the original input. The main result shows that if any set accepted by such a 3-head non-deterministic Turing machine can be accepted by a deterministic Turing machine with more read-only heads, then the deterministic and non-deterministic context-sensitive languages are identical. Several related results are derived and some tantalizing open problems are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289513</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Reichardt86">
<author>Johannes Reichardt</author>
<title>Deterministic Grammars and Grammar Morphisms.</title>
<pages>567-583</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#Reichardt86</url>
<abstract>The present categorial approach to bottom-up parsing context free grammars treats two aspects of determinism. One is an abstraction of grammatical determinism from actual parsing strategies. The other is the transfer of determinism under grammar transformations. The approach is based on the characterization of a parse step as categorial limit, which on the one hand yields a convenient pattern for grammar type definition, and leads on the other hand in a transparent way to invariance results on deterministic grammars under homomorphic transformations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288470</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/DubeF00">
<author>Danny Dub&eacute;</author>
<author>Marc Feeley</author>
<title>Efficiently building a parse tree from a regular expression.</title>
<pages>121-144</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037002/00370121.htm</ee>
<url>db/journals/acta/acta37.html#DubeF00</url>
</article>
<article mdate="2006-11-22" key="journals/acta/Hesselink06a">
<author>Wim H. Hesselink</author>
<title>Refinement verification of the lazy caching algorithm.</title>
<pages>195-222</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>The lazy caching algorithm of Afek et al. (ACM Trans. Program. Lang. Syst. 15, 182–206, 1993) is a protocol that allows the use of local caches with delayed updates. It results in a memory model that is not atomic (linearizable) but only sequentially consistent as defined by Lamport. In Distributed Computing 12 (1999), specifying and proving sequential consistency for the lazy caching algorithm was made into a benchmark for verification models. The present note contains such a specification and proof. It provides a simulation from the implementation to the abstract specification. The concrete verification only relies on the state space and the next-state relation. All behavioural aspects are treated in theories independent of the specific algorithm. The proofs of the underlying theories and of the concrete algorithm have been verified with the proof assistant PVS.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0020-1</ee>
<url>db/journals/acta/acta43.html#Hesselink06a</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hehner79">
<author>Eric C. R. Hehner</author>
<title>do Considered od: A Contribution to the Programming Calculus.</title>
<pages>287-304</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Hehner79</url>
<abstract>The utility of repetitive constructs is challenged. Recursive refinement is claimed to be semantically as simple, and superior for programming ease and clarity. Some programming examples are offered to support this claim. The relation between the semantics of predicate transformers and “least fixed point” semantics is presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289091</ee>
</article>
<article mdate="2013-06-06" key="journals/acta/ChenCSS13">
<author>Dongfeng Chen</author>
<author>Rada Chirkova</author>
<author>Fereidoon Sadri</author>
<author>Tiia J. Salo</author>
<title>Query optimization in information integration.</title>
<pages>257-287</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>The problem of decentralized data sharing, which is relevant to a wide range of applications, is still a source of major theoretical and practical challenges, in spite of many years of sustained research. In this paper we focus on the challenge of efficiency of query evaluation in information integration systems that use the global-as-view approach, with the objective of developing query-processing strategies that would be widely applicable and easy to implement in real-life applications. Our algorithms take into account important features of today’s data sharing applications: XML as likely interface or representation for data sources; the potential for information overlap across data sources; and the need for inter-source processing, as in joins of data across sources. The focus of this paper is on performance-related characteristics of several alternative approaches that we propose for efficient query processing in information integration, including an approach that uses materialized restructured views. We use synthetic and real-life datasets in our implementation of an information integration system shell to provide experimental results that demonstrate that our algorithms are efficient and competitive in the information integration setting. In addition, our experimental results allow us to make context-specific recommendations on selecting query-processing approaches from our proposed alternatives. As such, our approaches could form a basis for scalable query processing in information integration and interoperability in many practical settings.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0179-1</ee>
<url>db/journals/acta/acta50.html#ChenCSS13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Qian91">
<author>Xiaolei Qian</author>
<title>The Expressive Power of the Bounded-Iteration Construct.</title>
<pages>631-656</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#Qian91</url>
<abstract>The bounded-iteration constructforeach x in R/p do t od is very commonly used in database programming, due to the fact that database programs are dominated by data retrieval and manipulation tasks rather than by complex computations. Hence in database programming language design, it is important to understand the expressive power of the bounded-iteration construct and its relationship with other language constructs. We study the bounded-iteration construct within the context of a simple database programming language called theiterative transaction language. The language is shown to have NPTIME expressive power, and the deterministic subclass of it has PTIME expressive power, without any extra machineries or restrictions. We show that the bounded-iteration construct is essential for achieving this expressiveness, by characterizing its relationship with other constructs in the language. We also identify another natural subclass of iterative transactions calledfirst-order transactions with exactly first-order expressive power. The complexity of first-order transactions in terms of nested iterations and intermediate states is connected further to the complexity of first-order updates in terms of quantification depth.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178680</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Khoshnevisan90">
<author>Hessam Khoshnevisan</author>
<title>Efficient Memo-Table Management Strategies.</title>
<pages>43-81</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta28.html#Khoshnevisan90</url>
<abstract>A large, automatically detectable class of non-linear functions is defined and their evaluation graphs are characterised. These results are then used to develop space-efficient implementation ofmemo-functions. We generate a variant of memo-functions which can be used to linearise the time cost of calls of a non-linear function to itself whilst executing in bounded space. These memo-functions dynamically garbage collect (or reuse) memo-table entries when it is known that such entries will not be useful again. For each non-linear function a function called the “table-manager” function is synthesised by a static analysis of the definition of the non-linear function. The table-managers delete (or reuse) entries that are guaranteed to be obsolete as a result of any insertion into the memo-tables. In this way they ensure that the size of the tables is minimised. Furthermore, the sizes of the tables for these memo-functions are guaranteed not to exceed a compile-time constant found by the same static analysis which synthesises the table-managers. The applicability of the method also includes many problems which have been previously solved by applyingdynamic programming techniques. An implementation of these memo-functions for the functional language HOPE is also outlined.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02983374</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Claus73"> 
<author>Volker Claus</author>
<title>Die mittlere Additionsdauer eines Paralleladdierwerks</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>283-291</pages>
<url>db/journals/acta/acta2.html#Claus73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/DeussenM77"> 
<author>Peter Deussen</author>
<author>Kurt Mehlhorn</author>
<title>Van Wijngaarden Grammars and Space Complexity Classs EXSPACE.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>193-199</pages>
<url>db/journals/acta/acta8.html#DeussenM77</url>
<abstract>Top-down and bottom-up decision strategies for van Wijngaarden grammars led to type R and type L van Wijngaarden grammars. The corresponding language families are now shown to be equal and, furthermore, to equal EXSPACE. Thus, EXSPACE is characterised syntactically, and the closure properties of type L and type R languages are those of EXSPACE.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289249</ee>
</article>

<article mdate="2015-06-12" key="journals/acta/Fox73"> 
<author>Bennett L. Fox</author>
<title>Reducing the Number of Multiplikations in Iterative Processes.</title>
<pages>43-45</pages>
<year>1973</year> 
<volume>3</volume> 
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta3.html#Fox73</url>
<abstract>In any iteration scheme, such as v k=f(Qv k−1), where a fixed matrix multiplies a vector that depends on the iteration number, Winograd's method for computing inner products can be used in a straightforward manner to reduce the number of multiplications required at the cost of more additions. The key observation is that certain quantities required by Winograd's method have to be computed only at the first iteration. In the Jacobi method for solving systems of linear equations, f is linear. Gauss-Seidel iteration often converges faster than Jacobi iteration, but it cannot be put in the above form. A simple trick is necessary to apply Winograd's method in an efficient recursive manner. Our proposed method is better than the naive method when it is faster to add than to multiply. Versions of Jacobi and Gauss-Seidel iteration appropriate for optimization (as in Markov decision problems) are presented. The analysis specializes easily to the linear equation case.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288651</ee>
</article><article mdate="2011-11-25" key="journals/acta/AmanC11">
<author>Bogdan Aman</author>
<author>Gabriel Ciobanu</author>
<title>Solving a weak NP-complete problem in polynomial time by using mutual mobile membrane systems.</title>
<pages>409-415</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Mutual mobile membrane systems represent a variant of mobile membrane systems in which endocytosis and exocytosis work whenever the involved membranes “agree” on the movement by using mutual complement objects placed in membranes. We provide a semi-uniform polynomial solution for a weak NP-complete problem (namely partition problem) by means of mutual mobile membrane systems.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0144-9</ee>
<url>db/journals/acta/acta48.html#AmanC11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Kuich81">
<author>Werner Kuich</author>
<title>The Characterization of Parallel Ultralinear Grammars by Rational Power Series.</title>
<pages>129-139</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Kuich81</url>
<abstract>G is parallel ultralinear,G is parallel nonterminal bounded,PL(G), the parallel label language, is regular,f G(y, z), the generating function counting height and length of the yield of the derivation trees of G, is rational.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288960</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BiskupDS95"> 
<author>Joachim Biskup</author>
<author>Pratul Dublish</author>
<author>Yehoshua Sagiv</author>
<title>Optimization of a Subclass of Conjunctive Queries.</title>
<pages>1-26</pages>
<volume>32</volume> 
<year>1995</year> 
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta32.html#BiskupDS95</url>
<abstract>The optimization problem for a subclass of conjunctive queries which is formed by the union of the class of fan-out free queries and a subclass of typed fan-out queries is investigated. The typed fan-out queries in this class are obtained from simple tableaux by allowing atmost one attribute to violate the simple-tablau property. The optimization problem for several restricted subsets of typed fan-out queries is already known to be NP-hard. It is shown that the queries under consideration possess several useful properties which are then used to obtain an O(n 2) optimization algorithm based on the implication graph technique. The optimization of typed fan-out queries, obtained from simple tableaux by allowing atmost two attributes to violate the simple tableau property, is shown to be NP-hard. The optimization of simple tableaux in the presence of functional dependencies is also investigated and is shown to be NP-hard.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185403</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/MannaP74"> 
<author>Zohar Manna</author>
<author>Amir Pnueli</author>
<title>Axiomatic Approach to Total Correctness of Programs.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>243-263</pages>
<url>db/journals/acta/acta3.html#MannaP74</url>
<abstract>We present here an axiomatic approach which enables one to prove by formal methods that his program is “totally correct” (i.e., it terminates and is logically correct—does what it is supposed to do). The approach is similar to Hoare's approach [3] for proving that a program is “partially correct” (i.e., that whenever it terminates it produces correct results). Our extension to Hoare's method lies in the possibility of proving both correctness and termination by one unified formalism. One can choose to prove total correctness by a single step, or by incremental proof steps, each step establishing more properties of the program.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288637</ee>
</article>

<article mdate="2007-06-13" key="journals/acta/CurrieV07">
<author>James D. Currie</author>
<author>Terry I. Visentin</author>
<title>On Abelian 2-avoidable binary patterns.</title>
<pages>521-533</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>We give the first example of a binary pattern which is Abelian 2-avoidable, but which contains no Abelian fourth power. We introduce a family \(\{f_n\}_{n=1}^\infty\) of binary morphisms which offer a common generalization of the Fibonacci morphism and the Abelian fourth-power-free morphism of Dekking. We show that the Fibonacci word begins with arbitrarily high Abelian powers, but for n ≥ 2, the fixed point of f n avoids x n+2 in the Abelian sense. The sets of patterns avoided in the Abelian sense by the fixed points of f n and f n+1 are mutually incomparable for n ≥ 2.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0030-z</ee>
<url>db/journals/acta/acta43.html#CurrieV07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hennessy95"> 
<author>Matthew Hennessy</author>
<title>Concurrent Testing of Processes.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>6</number>
<year>1995</year> 
<pages>509-543</pages>
<url>db/journals/acta/acta32.html#Hennessy95</url>
<abstract>Using a form of “ST-operational semantics” we develop a noninterleaving semantic theory of processes based on testing. This operational semantics is based on the assumption that all actions have a non-zero duration and the allowed tests can therefore distinguish between the beginning and the termination of actions. The result is a semantic theory in which concurrency is differentiated from nondeterminism.We show that the semantic preorder based on these tests is preserved by so-called “stable” action refinements and may be characterised as the largest such preorder contained in the standard testing preorder.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178906</ee>
</article>


<article mdate="2003-11-25" key="journals/acta/TorreN01">
<author>Salvatore La Torre</author>
<author>Margherita Napoli</author>
<title>Timed tree automata with an application to temporal logic.</title>
<pages>89-116</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038002/10380089.htm</ee>
<url>db/journals/acta/acta38.html#TorreN01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HorwitzR91">
<author>Susan Horwitz</author>
<author>Thomas W. Reps</author>
<title>Efficient Comparison of Program Slices.</title>
<pages>713-732</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta28.html#HorwitzR91</url>
<abstract>Theslice of a program with respect to a componentc is a projection of the program that includes all components that might affect (either directly or transitively) the values of the variables used atc. Slices can be extracted particularly easily from a program representation called a program dependence graph, originally introduced as an intermediate program representation for performing optimizing, vectorizing, and parallelizing transformations. This paper presents a linear-time algorithm for determining whether two slices of a program dependence graph are isomorphic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01261653</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Hansen73"> 
<author>Per Brinch Hansen</author>
<title>A Reply to Comments on "A Comparison of Two Synchronizing Concepts"</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>189-190</pages>
<url>db/journals/acta/acta2.html#Hansen73</url>
</article>


<article mdate="2011-02-16" key="journals/acta/MitranaT11">
<author>Victor Mitrana</author>
<author>Cristina T&icirc;rnauca</author>
<title>New bounds for the query complexity of an algorithm that learns DFAs with correction and equivalence queries.</title>
<pages>43-50</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this note, we show that the number of equivalence queries asked by an algorithm proposed in Becerra-Bonache et al. (Proceedings of the 8th International Colloquium on Grammatical Inference (ICGI ’06), Lecture Notes in Artificial Intelligence, Springer-Verlag, Berlin 2006) that learns deterministic finite automata with correction and equivalence queries is at most the injectivity degree of the target language, a notion that corresponds to the number of repetitions among the correcting words of all the elements in the quotient of that language by the Myhill-Nerode equivalence. Further, we propose a tight upper bound for the number of correction queries as a function which depends on the index of the target language, the length of the longest counterexample returned by the teacher and the injectivity degree of the target language. However, the bounds obtained here for the number of CQs are optimal for the LCA algorithm, and they do not represent a tight upper bound for DFA learning with EQs and CQs in general.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0130-7</ee>
<url>db/journals/acta/acta48.html#MitranaT11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MateescuS93">
<author>Alexandru Mateescu</author>
<author>Arto Salomaa</author>
<title>On Simplest Possible Solutions for Post Correspondence Problems.</title>
<pages>441-457</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#MateescuS93</url>
<abstract>We investigate the simplicity of solutions for instances of the Post Correspondence Problem, from the point of view of both index words and terminal words. This leads to the notion of amixed primality type of an instance. Our main result gives an exhaustive characterization of mixed primality types.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210595</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KfouryU85">
<author>A. J. Kfoury</author>
<author>Pawel Urzyczyn</author>
<title>Necessary and Sufficient Conditions for the Universality of Programming Formalisms.</title>
<pages>347-377</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#KfouryU85</url>
<abstract>Over many familiar datatypes the notion of “computable” coincides with the notion of “flowchartable”. It is also known that flowcharts are not a universal programming formalism over arbitrary datatypes, in the sense that there are datatypes over which not all computable functions are flowchartable. In this paper we consider various extensions and restrictions of the basic formalism of flowcharts, and then for every such formalism, we characterize the datatypes over which the computable functions are exactly the functions programmable in this formalism. We say that a function is computable over a datatype if it is effective relative to the primitive operations and relations of the datatype.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288773</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Shen88">
<author>Sheldon Shen</author>
<title>Cooperative Distributed Dynamic Load Balancing.</title>
<pages>663-676</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta25.html#Shen88</url>
<abstract>This paper explores and applies the concept of cooperation to the load balancing problem in a computer network. We discuss an analytical model and propose a scheme which can be classified as distributed, dynamic, and stochastic. In the case of a homogeneous network, we guarantee that the load is balanced and no communication cost or information exchange is necessary.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00291053</ee>
</article>
<article mdate="2012-03-08" key="journals/acta/Lorencs12">
<author>Aivars Lorencs</author>
<title>The identity problem of finitely generated bi-ideals.</title>
<pages>105-115</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Finitely generated bi-ideals with letters from a selected alphabet A are considered. We solve the equivalence problem for generating systems of bi-ideals, i.e., look for an effective procedure which provides the means of determining if two generating systems \({\langle u_0, . . . , u_{m-1} \rangle}\) and \({\langle v_0, . . . , v_{n-1} \rangle}\) represent equal or different bi-ideals. We offer a method of constructing, for every generating system \({\langle u_0, . . . , u_{m-1} \rangle}\) , an equivalent generating system \({\langle u^{\prime}_{0}, . . . , u^{\prime}_{m-1} \rangle}\) with differing members. We also describe an algorithm for deciding if two generating systems \({\langle u_0, u_1 \rangle}\) and \({\langle v_0, v_1 \rangle}\) are equivalent or not. For a general case, the problem of existence of such an algorithm remains open.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0152-4</ee>
<url>db/journals/acta/acta49.html#Lorencs12</url>
</article>
<article mdate="2008-05-21" key="journals/acta/KutribMW08">
<author>Martin Kutrib</author>
<author>Andreas Malcher</author>
<author>Detlef Wotschke</author>
<title>The Boolean closure of linear context-free languages.</title>
<pages>177-191</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Closures of linear context-free languages under Boolean operations are investigated. The intersection closure and the complementation closure are incomparable. By closing these closures under further Boolean operations we obtain several new language families. The hierarchy obtained by such closures of closures is proper up to a certain level, where it collapses to the Boolean closure which, in turn, is incomparable with several closures of the family of context-free languages. The Boolean closure of the linear context-free languages is properly contained in the Boolean closure of the context-free languages. A characterization of a class of non-unary languages that cannot be expressed as a Boolean formula over the linear context-free languages is presented.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0068-6</ee>
<url>db/journals/acta/acta45.html#KutribMW08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Kaufholz74"> 
<author>Gerd Kaufholz</author>
<title>&Uuml;ber die Vernetzungsstruktur von Maschinen.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>171-186</pages>
<url>db/journals/acta/acta3.html#Kaufholz74</url>
<abstract>By adding some technologically motivated postulates to the definition of finite automata, we gain a mathematical model which permits interesting insights into the network structure of computing machines. In particular we show that the design of a strongly wired part (CPU) and a weakly wired part (storage) is advisable from the viewpoint of cost minimisation. We can also deduce some results about the interdependence of wiring density and computation time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264036</ee>
</article>

<article mdate="2004-03-03" key="journals/acta/Majster-CederbaumW03">
<author>Mila E. Majster-Cederbaum</author>
<author>Jinzhao Wu</author>
<title>Towards action refinement for true concurrent real time.</title>
<pages>531-577</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>Action refinement is an essential operation in the design of concurrent systems, real-time or not. In this paper we develop a theory of action refinement in a real-time non-interleaving causality based setting, a timed extension of bundle event structures that allows for urgent interactions to model timeout. The syntactic action refinement operation is presented in a timed process algebra as incorporated in the internationally standardised specification language LOTOS. We show that the behaviour of the refined system can be inferred compositionally from the behaviour of the original system and from the behaviour of the processes substituted for actions with explicitly represented start points, that the timed versions of a linear-time equivalence, termed pomset trace equivalence, and a branching-time equivalence, termed history preserving bisimulation equivalence, are both congruences under the refinement, and that the syntactic and semantic action refinements developed coincide under these equivalence relations with respect to a metric denotational semantics. Therefore, our refinement operations behave well. They meet the commonly expected properties.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0117-8</ee>
<url>db/journals/acta/acta39.html#Majster-CederbaumW03</url>
</article>
<article mdate="2015-01-08" key="journals/acta/Cleaveland89">
<author>Rance Cleaveland</author>
<title>Tableau-Based Model Checking in the Propositional Mu-Calculus.</title>
<pages>725-747</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta27.html#Cleaveland89</url>
<abstract>This paper describes a procedure, based around the construction of tableau proofs, for determining whether finite-state systems enjoy properties formulated in the propositional mu-calculus. It presents a tableau-based proof system for the logic and proves it sound and complete, and it discusses techniques for the efficient construction of proofs that states enjoy properties expressed in the logic. The approach is the basis of an ongoing implementation of a model checker in the Concurrency Workbench, an automated tool for the analysis of concurrent systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264284</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ReifS88">
<author>John H. Reif</author>
<author>Scott A. Smolka</author>
<title>The Complexity of Reachability in Distributed Communicating Processes.</title>
<pages>333-354</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta25.html#ReifS88</url>
<abstract>A crucial problem in the analysis of communicating processes is the detection of program statements that are unreachable due to communication deadlocks. In this paper, we consider the computational complexity of the reachability problem for various models of communicating processes. We obtain these models by making simplifying assumptions about the behavior of message queues and program control, with the hope that reachability may become easier to decide. Depending on the assumptions made, we show that reachability is undecidable, requires nearly exponential space infinitely often, or is NP-complete. In obtaining these results, we demonstrate a very close relationship between the decidable models and Petri nets and Habermann's path expressions, respectively.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00283332</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Epstein03">
<author>Leah Epstein</author>
<title>Bin stretching revisited.</title>
<pages>97-117</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/3039002/30390097.htm</ee>
<url>db/journals/acta/acta39.html#Epstein03</url>
</article>
<article mdate="2010-01-04" key="journals/acta/Zuliani09">
<author>Paolo Zuliani</author>
<title>Reasoning about faulty quantum programs.</title>
<pages>403-432</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We show how to use a programming language for formally describing and reasoning about errors in quantum computation. The formalisation is based on the concept of performing the correct operation with probability at least p, and the erroneous one with probability at most 1 − p. We apply the concept to two examples: Bell’s inequalities and the Deutsch–Jozsa quantum algorithm. The former is a fundamental thought experiment aimed at showing that Quantum Mechanics is not “local and realist”, and it is used in quantum cryptography protocols. We study it assuming faulty measurements, and we derive hardware reliability conditions that must be satisfied in order for the experiment to support its conclusions. The latter is a quantum algorithm for efficiently solving a classification problem for Boolean functions. The algorithm solves the problem with no error, but when we introduce faulty operations it becomes a two-sided error algorithm. Reasoning is accomplished via standard programming laws and quantum laws.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0100-0</ee>
<url>db/journals/acta/acta46.html#Zuliani09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Alblas81">
<author>Henk Alblas</author>
<title>A Characterization of Attribute Evaluation in Passes.</title>
<pages>427-464</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Alblas81</url>
<abstract>This paper describes the evaluation of semantic attributes in a bounded number of passes from left-to-right and/or from right-to-left over the derivation tree of a program. Evaluation strategies where different instances of the same attribute in any derivation tree are restricted to be evaluated in one pass, with for every derivation tree the same pass number, are referred to as simple multi-pass whereas the unrestricted pass-oriented strategies are referred to as pure multi-pass.A graph theoretic characterization is given, showing in which cases an attribute grammar meets the simple multi-pass requirements and what are the minimal pass numbers of its attributes for a given sequence of pass directions. For the special cases where only left-to-right passes are made or where left-to-right and right-to-left passes strictly alternate, new algorithms are developed that associate minimal pass numbers with attributes and indicate in case of failure the attributes that cause the rejection of the grammar. Mixing of a simple multi-pass strategy with other evaluation strategies, in case the grammar is not simple multi-pass, is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264495</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PengP92">
<author>Wuxu Peng</author>
<author>S. Purushothaman</author>
<title>Analysis of a Class of Communicating Finite State Machines.</title>
<pages>499-522</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#PengP92</url>
<abstract>Thereachability, deadlok detection andunboundedness detection problems are considered for the class ofcyclic one-type message networks of communicating finite state machines. We show that all the three problems are effectively solvable by (a) constructing canonical execution event sequences which belong to a context-free language, and (b) showing that the reachability sets are semilinear. Our algorithms have polynomial complexity in terms of size of a global structure of a network, called theshuffle-product. The relationships between general Petri nets and the class of communicating finite state machines considered here are also explored.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185558</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Back88">
<author>Ralph-Johan Back</author>
<title>A Calculus of Refinements for Program Derivations.</title>
<pages>593-624</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta25.html#Back88</url>
<abstract>A calculus of program refinements is described, to be used as a tool for the step-by-step derivation of correct programs. A derivation step is considered correct if the new program preserves the total correctness of the old program. This requirement is expressed as a relation of (correct) refinement between nondeterministic program statements. The properties of this relation are studied in detail. The usual sequential statement constructors are shown to be monotone with respect to this relation and it is shown how refinement between statements can be reduced to a proof of total correctness of the refining statement. A special emphasis is put on the correctness of replacement steps, where some component of a program is replaced by another component. A method by which assertions can be added to statements to justify replacements in specific contexts is developed. The paper extends the weakest precondition technique of Dijkstra to proving correctness of larger program derivation steps, thus providing a unified framework for the axiomatic, the stepwise refinement and the transformational approach to program construction and verification.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00291051</ee>
</article>
<article mdate="2007-06-13" key="journals/acta/VagnerM07a">
<author>Ladislav Vagner</author>
<author>Borivoj Melichar</author>
<title>Parallel LL parsing.</title>
<pages>73</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract></abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0032-x</ee>
<url>db/journals/acta/acta44.html#VagnerM07a</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Apt81">
<author>Krzysztof R. Apt</author>
<title>Recursive Assertions and Parallel Programs.</title>
<pages>219-232</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Apt81</url>
<abstract>We prove that recursive assertions are enough for proofs of parallel programs considered in Owicki and Gries [7]. In other words, we prove that for any parallel program S and recursive assertions p and q if {p} S{q} is true under the standard interpretation in natural numbers then all intermediate assertions needed in the proof can be chosen recursive. Finally, we show that if auxiliary variables are used only as program counters then the above result does not hold.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289262</ee>
</article>
<article mdate="2012-09-18" key="journals/acta/GolovachLMP12">
<author>Petr A. Golovach</author>
<author>Bernard Lidick&yacute;</author>
<author>Barnaby Martin</author>
<author>Dani&euml;l Paulusma</author>
<title>Finding vertex-surjective graph homomorphisms.</title>
<pages>381-394</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>The Surjective Homomorphism problem is to test whether a given graph G called the guest graph allows a vertex-surjective homomorphism to some other given graph H called the host graph. The bijective and injective homomorphism problems can be formulated in terms of spanning subgraphs and subgraphs, and as such their computational complexity has been extensively studied. What about the surjective variant? Because this problem is NP-complete in general, we restrict the guest and the host graph to belong to graph classes \({{\mathcal G}}\) and \({{\mathcal H}}\), respectively. We determine to what extent a certain choice of \({{\mathcal G}}\) and \({{\mathcal H}}\) influences its computational complexity. We observe that the problem is polynomial-time solvable if \({{\mathcal H}}\) is the class of paths, whereas it is NP-complete if \({{\mathcal G}}\) is the class of paths. Moreover, we show that the problem is even NP-complete on many other elementary graph classes, namely linear forests, unions of complete graphs, cographs, proper interval graphs, split graphs and trees of pathwidth at most 2. In contrast, we prove that the problem is fixed-parameter tractable in k if \({{\mathcal G}}\) is the class of trees and \({{\mathcal H}}\) is the class of trees with at most k leaves, or if \({{\mathcal G}}\) and \({{\mathcal H}}\) are equal to the class of graphs with vertex cover number at most k.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0164-0</ee>
<url>db/journals/acta/acta49.html#GolovachLMP12</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Ullman73"> 
<author>Jeffrey D. Ullman</author>
<title>Fast Algorithms for the Elimination of Common Subexpressions</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>191-213</pages>
<url>db/journals/acta/acta2.html#Ullman73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/RudnickiD86">
<author>Piotr Rudnicki</author>
<author>Wlodzimierz Drabent</author>
<title>Erratum: Proving Properties of Pascal Programs in MIZAR 2.</title>
<pages>699-707</pages>
<year>1986</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta22.html#RudnickiD86</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263652</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Fernau97">
<author>Henning Fernau</author>
<title>Unconditional Transfer in Regulated Rewriting.</title>
<pages>837-857</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<url>db/journals/acta/acta34.html#Fernau97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034011/70340837.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Carter82">
<author>Lynn Robert Carter</author>
<title>Further Analysis of Code Generation for a Single Register Machine.</title>
<pages>135-147</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Carter82</url>
<abstract>This paper presents a systematic development of the analysis of code generation for the single register machine, from linear to exponential time algorithms. A class of expressions with common subexpressions is introduced which can be optimally coded in quadratic time. A heuristic based on this development is shown to produce code size better than 5/4 that of an optimal coding, for any expression. A method is proposed which would improve this bound, but the most straightforward implementation is shown to require exponential time. Finally, a new analysis of the exponential time bound is presented which more closely describes the complexity of the task of producing optimal code.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264435</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Lamport76"> 
<author>Leslie Lamport</author>
<title>The Synchronization of Independent Processes.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>15-34</pages>
<url>db/journals/acta/acta7.html#Lamport76</url>
<abstract>This paper considers the problem of programming a multiple process system so that it continues to operate despite the failure of individual processes. A powerful synchronizing primitive is defined, and it is used to solve some sample problems. An algorithm is then given which implements this primitive under very weak assumptions about the nature of interprocess communication, and a careful informal proof of its correctness is given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265219</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Kamimura85">
<author>Tsutomu Kamimura</author>
<title>An Effectively Given Initial Semigroup.</title>
<pages>203-227</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#Kamimura85</url>
<abstract>The notion of effectively given domains is extended to semigroups. We show that the initial algebra for the semigroups with finite generators is effectively given. The initial algebra we describe uses expressions and trees of symbols of generators and the partial order in the algebra is defined using a formal system on expressions. The main body of the paper lies in the demonstration of the decidability of this formal system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264231</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/KhomenkoKV03">
<author>Victor Khomenko</author>
<author>Maciej Koutny</author>
<author>Walter Vogler</author>
<title>Canonical prefixes of Petri net unfoldings.</title>
<pages>95-118</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>In this paper, we develop a general technique for truncating Petri net unfoldings, parameterized according to the level of information about the original unfolding one wants to preserve. Moreover, we propose a new notion of completeness of a truncated unfolding. A key aspect of our approach is an algorithm-independent notion of cut-off events, used to truncate a Petri net unfolding. Such a notion is based on a cutting context and results in the unique canonical prefix of the unfolding. Canonical prefixes are complete in the new, stronger sense, and we provide necessary and sufficient conditions for its finiteness, as well as upper bounds on its size in certain cases. A surprising result is that after suitable generalization, the standard unfolding algorithm presented in [8], and the parallel unfolding algorithm proposed in [12], despite being non-deterministic, generate the canonical prefix. This gives an alternative correctness proof for the former algorithm, and a new (much simpler) proof for the latter one.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0122-y</ee>
<url>db/journals/acta/acta40.html#KhomenkoKV03</url>
</article>
<article mdate="2009-06-22" key="journals/acta/SawaJ09">
<author>Zdenek Sawa</author>
<author>Petr Jancar</author>
<title>Hardness of equivalence checking for composed finite-state systems.</title>
<pages>169-191</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Computational complexity of comparing behaviours of systems composed from interacting finite-state components is considered. The main result shows that the respective problems are EXPTIME-hard for all relations between bisimulation equivalence and trace preorder, as conjectured by Rabinovich (Inf Comput 139(2):111–129, 1997). The result is proved for a specific model of parallel compositions where the components synchronize on shared actions but it can be easily extended to other similar models,   to labelled 1-safe Petri nets. Further hardness results are shown for special cases of acyclic systems.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0088-x</ee>
<url>db/journals/acta/acta46.html#SawaJ09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DuponcheelD86">
<author>Luc Duponcheel</author>
<author>M. Duponcheel</author>
<title>Acceptable Functional Programming Systems.</title>
<pages>67-98</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta23.html#DuponcheelD86</url>
<abstract>In this paper we present a self-contained treatment of the theory of computable functions using acceptable functional programming systems. We construct a particular acceptable functional programming system. Within the framework of this system we prove two main theorems to show that, when working with substitution operators, the fixed point function defined by the mechanism of the system and the fixed point function defined by the recursion theorem are both equal to the least fixed point. Furthermore we show that the programs defined by the mechanism of the system are easier and faster than the ones defined by the recursion theorem. We make some suggestions about how to implement the system using a suitable environment. We also formulate a natural question: what is the relationship between substitution operators and computable operators?</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00268076</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Hesselink03">
<author>Wim H. Hesselink</author>
<title>Preference rankings in the face of uncertainty.</title>
<pages>211-231</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>An agent may have to choose between actions based on incomplete knowledge of its environment. The incomplete knowledge is modelled as the local state of the agent, which represents the set of states of the environment that the agent deems possible. A policy determines a ranking (as a total preorder) of the set of actions as a function of the local state. A policy is maximin representable when it is based on a utility function via the maximin principle. The theory of Brafman and Tennenholz on necessary and sufficient conditions for policies to be maximin representable is sharpened, extended, and related to maximax and Laplace representability.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0108-9</ee>
<url>db/journals/acta/acta39.html#Hesselink03</url>
</article>
<article mdate="2004-03-03" key="journals/acta/CurrieM03">
<author>James D. Currie</author>
<author>Erica Moodie</author>
<title>A word on 7 letters which is non-repetitive up to mod 5.</title>
<pages>451-468</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract></abstract>
<ee>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0001-5903&amp;volume=39&amp;issue=6&amp;spage=451</ee>
<url>db/journals/acta/acta39.html#CurrieM03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Heilbrunner85">
<author>Stephan Heilbrunner</author>
<title>Truly Prefix-Correct Chain-Free <i> LR </i> (1) Parsers.</title>
<pages>499-536</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta22.html#Heilbrunner85</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00267043</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rego89">
<author>Vernon Rego</author>
<title>Some Efficient Computational Algorithms Related to Phase Models.</title>
<pages>157-177</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta27.html#Rego89</url>
<abstract>This paper develops efficient computational algorithms for some models that utilize phase type distributions. As in other instances, such as matrix-geometric methods, where the PH-distribution lends itself to useful and efficient computational methods, we examine how certain probabilities based on these distributions may be efficiently computed. The examples that we consider include token ring networks, simple multiqueues, and order statistics. By exploiting the geometric nature of PH-densities, it is shown that certain exponential time computations can be reduced to linear time, if recursive algorithms are used. We demonstrate speedup with the aid of a practical example, using a recursive as well as a nonrecursive algorithm, in verifying the stability of a queue on a token ring network.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265152</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kowaltowski77"> 
<author>Tomasz Kowaltowski</author>
<title>Axiomatic Approach to Side Effects and General Jumps.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>357-360</pages>
<url>db/journals/acta/acta7.html#Kowaltowski77</url>
<abstract>Hoare's axiomatic method is applied in order to describe two controversial features: side effects and general jumps. The relative simplicity of this description suggests that reasons for the exclusion of these features from programming languages are subtler than it has been thought.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289468</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/NicollinSY93">
<author>Xavier Nicollin</author>
<author>Joseph Sifakis</author>
<author>Sergio Yovine</author>
<title>From ATP to Timed Graphs and Hybrid Systems.</title>
<pages>181-202</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta30.html#NicollinSY93</url>
<abstract>The paper presents results of ongoing work aiming at the unification of some behavioral description formalisms for timed systems. We propose for the algebra of timed processes ATP a very general semantics in terms of a time domain. It is then shown how ATP can be translated into a variant of timed graphs. This result allows the application of existing model-checking techniques to ATP. Finally, we propose a notion of hybrid systems as a generalization of timed graphs. Such systems can evolve, either by executing a discrete transition, or by performing some “continuous” transformation. The formalisms studied admit the same class of models: time deterministic and time continuous, possibly infinitely branching transition systems labeled by actions or durations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178579</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DeinekoRW96">
<author>Vladimir G. Deineko</author>
<author>R&uuml;diger Rudolf</author>
<author>Gerhard J. Woeginger</author>
<title>On the Recognition of Permuted Supnick and Incomplete Monge Matrices.</title>
<pages>559-569</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#DeinekoRW96</url>
<abstract>Incomplete Monge matrices are a generalization of standard Monge matrices: the values of some entries are not specified and the Monge property only must hold for all specified entries. We derive several combinatorial properties of incomplete Monge matrices and prove that the problem of recognizingpermuted incomplete Monge matrices is NP-complete. For the special case of permutedSupnick matrices, we derive a fast recognition algorithm and thereby identify a special case of then-vertex travelling salesman problem which can be solved inO(n 2logn) time.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036463</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/DassowPTY01">
<author>J&uuml;rgen Dassow</author>
<author>Gheorghe Paun</author>
<author>Gabriel Thierrin</author>
<author>Sheng Yu</author>
<title>Tree-systems of morphisms.</title>
<pages>131-153</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038002/10380131.htm</ee>
<url>db/journals/acta/acta38.html#DassowPTY01</url>
</article>
<article mdate="2012-06-14" key="journals/acta/ChoffrutMMP12">
<author>Christian Choffrut</author>
<author>Andreas Malcher</author>
<author>Carlo Mereghetti</author>
<author>Beatrice Palano</author>
<title>First-order logics: some characterizations and closure properties.</title>
<pages>225-248</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>The characterization of the class of FO[+]-definable languages by some generating or recognizing device is still an open problem. We prove that, restricted to word bounded languages, this class coincides with the class of semilinear languages. We also study the closure properties of the classes of languages definable in FO[+1], FO[<], FO[+] and FOC[+] under the main classical operations.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0157-z</ee>
<url>db/journals/acta/acta49.html#ChoffrutMMP12</url>
</article>
<article mdate="2006-05-10" key="journals/acta/BrlekPR06">
<author>Srecko Brlek</author>
<author>Elisa Pergola</author>
<author>Olivier Roques</author>
<title>Non uniform random generation of generalized Motzkin paths.</title>
<pages>603-616</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>We consider in this paper the class M k n of generalized Motzkin paths of length n, that is, lattice paths using steps (1,1), (1,−1), (k,0), where k is a fixed positive integer, starting at the origin (0,0), running above the x-axis, and ending at (n,0). The area is the region bounded by the path and the x-axis. We first establish a bijection between the area of paths in M k n and some lattice paths of length n+1. Then, by using a rejection technique, we obtain a linear algorithm with an average time complexity (k mod 2 +1)(n+1).</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0008-x</ee>
<url>db/journals/acta/acta42.html#BrlekPR06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HsuP95"> 
<author>Wen-Jing Hsu</author>
<author>Carl V. Page</author>
<title>Parallel Tree Contraction and Prefix Computations on a Large Family of Interconnection Topologies.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>2</number>
<year>1995</year> 
<pages>145-153</pages>
<url>db/journals/acta/acta32.html#HsuP95</url>
<abstract>The derivation of the prefixes of a given sequence (prefix computation) and the fast reduction of a tree to a single node (tree contraction) are two useful primitives for many applications on parallel computers. It is well known that certain special cases of the two problems can be solved efficiently on the hypercube. Here we extend this result to a large family of parallel computers. The family of parallel computers are based on a novel interconnection scheme called thegeneralized Fibonacci cube that encompasses both the hypercube and the second-order Fibonacci cube in [8]. Specifically, we show that thek-th order Fibonacci tree of sizeN can be reduced to a single node inO(logN) steps on ak-th order Fibonacci cube withN nodes (processors). Assuming thatO(logN) data items are on each of theN processors, we also show that the prefixes can be computed inO(logN) steps on thek-th order Fibonacci cube.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177744</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/RozenbergL73"> 
<author>Grzegorz Rozenberg</author>
<author>Aristid Lindenmayer</author>
<title>Developmental Systems with Locally Catenative Formulas</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>214-248</pages>
<url>db/journals/acta/acta2.html#RozenbergL73</url>
</article>


<article mdate="2005-01-25" key="journals/acta/DolevS04">
<author>Shlomi Dolev</author>
<author>Elad Schiller</author>
<title>Self-stabilizing group communication in directed networks.</title>
<pages>609-636</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>This paper presents the first self-stabilizing group membership service, multicast service, and resource allocation service for directed networks. The first group communication algorithm is based on a token circulation over a virtual ring. The second algorithm is based on construction of distributed spanning trees. In addition, a technique is presented that emulates, in a self-stabilizing fashion, any undirected communication network over strongly connected directed networks, is presented. A resource allocation asynchronous algorithm for strongly connected directed networks is presented.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0143-1</ee>
<url>db/journals/acta/acta40.html#DolevS04</url>
</article>
<article mdate="2011-08-10" key="journals/acta/PolyvyanyyWW11">
<author>Artem Polyvyanyy</author>
<author>Matthias Weidlich</author>
<author>Mathias Weske</author>
<title>Connectivity of workflow nets: the foundations of stepwise verification.</title>
<pages>213-242</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Behavioral models capture operational principles of real-world or designed systems. Formally, each behavioral model defines the state space of a system, i.e., its states and the principles of state transitions. Such a model is the basis for analysis of the system’s properties. In practice, state spaces of systems are immense, which results in huge computational complexity for their analysis. Behavioral models are typically described as executable graphs, whose execution semantics encodes a state space. The structure theory of behavioral models studies the relations between the structure of a model and the properties of its state space. In this article, we use the connectivity property of graphs to achieve an efficient and extensive discovery of the compositional structure of behavioral models; behavioral models get stepwise decomposed into components with clear structural characteristics and inter-component relations. At each decomposition step, the discovered compositional structure of a model is used for reasoning on properties of the whole state space of the system. The approach is exemplified by means of a concrete behavioral model and verification criterion. That is, we analyze workflow nets, a well-established tool for modeling behavior of distributed systems, with respect to the soundness property, a basic correctness property of workflow nets. Stepwise verification allows the detection of violations of the soundness property by inspecting small portions of a model, thereby considerably reducing the amount of work to be done to perform soundness checks. Besides formal results, we also report on findings from applying our approach to an industry model collection.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0137-8</ee>
<url>db/journals/acta/acta48.html#PolyvyanyyWW11</url>
</article>
<article mdate="2004-06-28" key="journals/acta/Domaratzki04">
<author>Michael Domaratzki</author>
<title>Trajectory-based codes.</title>
<pages>491-527</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>The notion of shuffle on trajectories is a natural generalization of many word operations considered in the literature. For a set of trajectories T, we define the notion of a T-code and examine its properties. Particular instances of T-codes are prefix-, suffix-, infix-, outfix- and hyper-codes, as well as other classes studied in the literature.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0140-4</ee>
<url>db/journals/acta/acta40.html#Domaratzki04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Kroger77"> 
<author>Fred Kr&ouml;ger</author>
<title>LAR: A Logic of Algorithmic Reasoning.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>243-266</pages>
<url>db/journals/acta/acta8.html#Kroger77</url>
<abstract>Reasoning about programs involves some logical framework which seems to go beyond classical predicate logic. LAR is an extension of predicate logic by additional concepts which are to formalize our “natural” reasoning about algorithms. Semantically, this extension introduces an underlying “time scale” on which formulas are considered and “time shifting” connectives. Besides a full model-theoretic treatment, a consistent and complete formal system for LAR is given. The pure logical system can serve as a basis for various theories. As an example, a theory of “while program schemes” is developed which contains Hoare's correctness proof system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264469</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/KuhnemannV94">
<author>Armin K&uuml;hnemann</author>
<author>Heiko Vogler</author>
<title>Synthesized and Inherited Functions. A new Computational Model for Syntax-Directed Semantic.</title>
<pages>431-477</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta31.html#KuhnemannV94</url>
<abstract>In this paper we introduce a new formal model for the concept of syntaxdirected semantics, calledmacro attributed tree transducer (for short: mat tree transducer). This model is based on (noncircular) attributed tree transducers and on macro tree transducers. In the first type of transducer, semantic values are computed by means of meaning names called synthesized attributes, and by means of context names called inherited attributes. Both, synthesized and inherited attributes represent basic semantic values. In the second type of transducer, semantic values are computed by meaning names only which are called states. However, in order to have a means of handling context information, states represent functions over semantic values. The new model integrates attributed tree transducers and macro tree transducers by allowing both, meaning names and context names to represent functions over semantic values. In analogy to the terminology of attributed tree transducers, we call such meaning names and context names also synthesized functions and inherited functions, respectively.We present an inductive characterization of the tree transformation computed by an mat tree transducer. We prove that mat tree transducers are more powerful than both, attributed tree transducers and macro tree transducers. We characterize mat tree transducers by the two-fold composition of attributed tree transducers. This characterization has three consequences: (1) the height of output trees of mat tree transducers is bounded exponentially in the size of the input tree, (2) the composition hierarchy of mat tree transducers is strict, and (3) mat tree transducers are closed under right-composition with top-down tree transducers, but not under left-composition. Moreover, we prove that the addition of inherited attributes does not increase the computational power of macro tree transducers.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178667</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtR76">
<author>Andrzej Ehrenfeucht</author>
<author>Grzegorz Rozenberg</author>
<title>On Proving that Certain Languages are not ETOL.</title>
<pages>407-415</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#EhrenfeuchtR76</url>
<abstract>In this paper a partial characterization for a subclass of ETOL languages is obtained. The main result binds together the number of occurrences (in words of a given ETOL language) of letters, from a given set, with their distribution. It provides a very helpful tool to prove that certain languages are not ETOL.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268142</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EriksenS82">
<author>Ole Eriksen</author>
<author>J&oslash;rgen Staunstrup</author>
<title>Concurrent Algorithms for Root Searching.</title>
<pages>361-376</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#EriksenS82</url>
<abstract>Concurrent algorithms for finding the root of a real continous function are analyzed. A lower bound on the running time is given, this lower bound is obtained by a synchronous algorithm. A new asynchronous algorithm is discussed in detail and its running time is analyzed. Finally, the results from running the asynchronous algorithm on a multiprocessor are shown.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289575</ee>
</article>
<article mdate="2012-06-14" key="journals/acta/BaierBGK12">
<author>Christel Baier</author>
<author>Tom&aacute;s Br&aacute;zdil</author>
<author>Marcus Gr&ouml;&szlig;er</author>
<author>Anton&iacute;n Kucera</author>
<title>Stochastic game logic.</title>
<pages>203-224</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Stochastic game logic (SGL) is a new temporal logic for multi-agent systems modeled by turn-based multi-player games with discrete transition probabilities. It combines features of alternating-time temporal logic (ATL), probabilistic computation tree logic and extended temporal logic. SGL contains an ATL-like modality to specify the individual cooperation and reaction facilities of agents in the multi-player game to enforce a certain winning objective. While the standard ATL modality states the existence of a strategy for a certain coalition of agents without restricting the range of strategies for the semantics of inner SGL formulae, we deal with a more general modality. It also requires the existence of a strategy for some coalition, but imposes some kind of strategy binding to inner SGL formulae. This paper presents the syntax and semantics of SGL and discusses its model checking problem for different types of strategies. The model checking problem of SGL turns out to be undecidable when dealing with the full class of history-dependent strategies. We show that the SGL model checking problem for memoryless deterministic strategies as well as the model checking problem of the qualitative fragment of SGL for memoryless randomized strategies is PSPACE-complete, and we establish a close link between natural syntactic fragments of SGL and the polynomial hierarchy. Further, we give a reduction from the SGL model checking problem under memoryless randomized strategies into the Tarski algebra which proves the problem to be in EXPSPACE.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0156-0</ee>
<url>db/journals/acta/acta49.html#BaierBGK12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LeeW77">
<author>D. T. Lee</author>
<author>C. K. Wong</author>
<title>Worst-Case Analysis for Region and Partial Region Searches in Multidimensional Binary Search Trees and Balanced Quad Trees.</title>
<pages>23-29</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#LeeW77</url>
<abstract>Given a file of N records each of which has k keys, the worst-case analysis for the region and partial region queries in multidimensional binary search trees and balanced quad trees are presented. It is shown that the search algorithms proposed in [1, 3] run in time O(k·N 1−1/k) for region queries in both tree structures. For partial region queries with s keys specified, the search algorithms run at most in time O(s·N 1−1/k ) in both structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263763</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Earley74"> 
<author>Jay Earley</author>
<title>Ambiguity and Precedence in Syntax Description.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>183-192</pages>
<url>db/journals/acta/acta4.html#Earley74</url>
<abstract>This paper describes a method of syntax description for programming languages which allows one to factor out that part of the description which deals with the relative precedences of syntactic units. This has been found to produce simpler and more flexible syntax descriptions. It is done by allowing the normal part of the description, which is done in BNF, to be ambiguous; these ambiguities are then resolved by a separate part of the description which gives precedence relations between the conflicting productions from the grammar. The method can be used with any left-to-right parser which is capable of detecting ambiguities and recognizing which productions they come from; We have studied its use with an LR(1) parser, and it requires a small and localized addition to the parser to enable it to deal with the precedence relations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288747</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Tsakalidis84">
<author>Athanasios K. Tsakalidis</author>
<title>Maintaining Order in a Generalized Linked List.</title>
<pages>101-112</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Tsakalidis84</url>
<abstract>We give a representation for linked lists which allows to efficiently insert and delete objects in the list and to quickly determine the order of two list elements. The basic data structure, called an indexed BB [α]-tree, allows to do n insertions and deletions in O(n log n) steps and determine the order in constant time, assuming that the locations of the elements worked at are given. The improved algorithm does n insertions and deletions in O(n) steps and determines the order in constant time. An application of this provides an algorithm which determines the ancestor relationship of two given nodes in a dynamic tree structure of bounded degree in time O(1) and performs n arbitrary insertions and deletions at given positions in time O(n) using linear space.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289142</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ErnstNO82">
<author>George W. Ernst</author>
<author>Jainendra K. Navlakha</author>
<author>William F. Ogden</author>
<title>Verification of Programs with Procedure-Type Parameter.</title>
<pages>149-169</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#ErnstNO82</url>
<abstract>A verification system is developed for proving the correctness of programs containing procedures with procedure-type parameters. The system, which reduces programs and their specifications to assertions to be proved in ordinary logic, is shown to be logically sound. The reduction process is controlled by the syntax of the program and is completely mechanical, requiring no human intervention. The resulting assertions involve higher-order predicates, but they engender no significant difficulties which are not already present in ordinary first-order theories.Our system views the intermediate objects in the reduction process as extended programs, thereby making verification a much less abstruse process. Treating logical assertions as commands appeals strongly to a programmer's intuition.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264436</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wallis78">
<author>Peter J. L. Wallis</author>
<title>The Design of a Portable Programming Language.</title>
<pages>157-167</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Wallis78</url>
<abstract>We consider the design of a strongly-typed language with userdefined types in which it is arranged that, given that a type is available, it is immaterial to the user whether it is a user-defined type or one of the “primitive types” with representations selected by the implementer. This scheme provides unprecedented freedom in choosing the primitive types; by making these machine-dependent we can ensure production of programs that are easily and efficiently portable between computers of different architectures. A general discussion of the implementer's responsibilities in choosing primitive types appropriate to his machine is illustrated by considering implementation choices for translation of the language into BCPL. Finally we discuss the contribution of the language to the solution of the portability problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289153</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Salzberg89">
<author>Betty Salzberg</author>
<title>Merging Sorted Runs Using Large Main Memory.</title>
<pages>195-215</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta27.html#Salzberg89</url>
<abstract>External sorting is usually accomplished by first creating sorted runs, then merging the runs. In the merge phase, writing and calculating can be overlapped by reading if two input buffers are used for each sorted run. If the memory is very large, the input buffers will be large and using two input buffers per sorted run will be more efficient than using only one input buffer per run and risking reduced overlap of reading and writing. In many cases, merging time can be cut in half. We derive a formula for estimating the total time for merging for a given memory size, file size, number of merging passes and for a given disk drive. We present an extreme example where in spite of having two buffers per run, significant non-overlap occurs. However, in realistic problems, we show that making one merge pass with two input buffers per run is near optimal. This contradicts earlier results on merging which do not take large memory into account.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00572988</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MiliDG85">
<author>Ali Mili</author>
<author>Jules Desharnais</author>
<author>Jean-Raymond Gagn&eacute;</author>
<title>Strongest Invariant Functions: Their Use in the Systematic Analysis of While Statements.</title>
<pages>47-66</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#MiliDG85</url>
<abstract>Strongest invariant functions, a useful tool in the analysis of while statements, are defined and discussed. Their relationships to loop invariants and to the function computed by the while statement are investigated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290145</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Leung98">
<author>Hing Leung</author>
<title>On Finite Automata with Limited Nondeterminism.</title>
<pages>595-624</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta35.html#Leung98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035007/80350595.htm</ee>
</article>
<article mdate="2015-08-18" key="journals/acta/FanWH15">
<author>Chen-Ming Fan</author>
<author>Jen-Tse Wang</author>
<author>Cheng-Chih Huang</author>
<title>Some properties of involution binary relations.</title>
<pages>483-495</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>This paper aims to investigate properties of involution binary relations, which are some particular binary relations. We study the concepts of involution spanning sets and give some examples related to different involution binary relations. Moreover, some relationships among the involution independent sets, codes, and involution codes are studied when the mapping function is either a morphic or an antimorphic involution of \(X^*\).</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0208-8</ee>
<url>db/journals/acta/acta52.html#FanWH15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/MeinkeS01">
<author>Karl Meinke</author>
<author>L. J. Steggles</author>
<title>Correctness of dataflow and systolic algorithms using algebras of streams.</title>
<pages>45-88</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038001/10380045.htm</ee>
<url>db/journals/acta/acta38.html#MeinkeS01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HertelMMN84">
<author>Stefan Hertel</author>
<author>Martti M&auml;ntyl&auml;</author>
<author>Kurt Mehlhorn</author>
<author>J&uuml;rg Nievergelt</author>
<title>Space Sweep Solves Intersection of Convex Polyhedra.</title>
<pages>501-519</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#HertelMMN84</url>
<abstract>Plane-sweep algorithms form a fairly general approach to two-dimensional problems of computational geometry. No corresponding general space-sweep algorithms for geometric problems in 3- space are known. We derive concepts for such space-sweep algorithms that yield an efficient solution to the problem of solving any set operation (union, intersection, ...) of two convex polyhedra. Our solution matches the best known time bound of O(n log n), where n is the combined number of vertices of the two polyhedra.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271644</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BannisterT83">
<author>Joseph A. Bannister</author>
<author>Kishor S. Trivedi</author>
<title>Task Allocation in Fault-Tolerant Distributed Systems.</title>
<pages>261-281</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#BannisterT83</url>
<abstract>This paper examines task allocation in fault-tolerant distributed systems. The problem is formulated as a constrained sum of squares minimization problem. The computational complexity of this problem prompts us to consider an efficient approximation algorithm. We show that the ratio of the performance of the approximation algorithm to that of the optimal solution is bounded by 9m/(8m−r+1)), wherem is the number of processors to be allocated andr is the number of times each task is to be replicated. Experience with the algorithm suggests that even better performance ratios can be expected.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01257086</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schmerl88">
<author>Ulf R. Schmerl</author>
<title>Resolution on Formula-Trees.</title>
<pages>425-438</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta25.html#Schmerl88</url>
<abstract>We introduce a nonclausal resolution calculus on formula-trees which comprises classical resolution as a special case. The resolvents produced in this calculus are more structure preserving than in nonclausal resolution by Murray and Manna and Waldinger and simpler than in nested resolution by Traugott. Proofs of correctness and completeness are given. In some examples, first experiences made when implementing the calculus are discussed.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02737109</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ForstT00">
<author>Gunnar Forst</author>
<author>Anders Thorup</author>
<title>Minimal Huffman Trees.</title>
<pages>721-734</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360721.htm</ee>
<url>db/journals/acta/acta36.html#ForstT00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Lao87">
<author>Marek J. Lao</author>
<title>Combinator-Based Compilation of Recursive Functions with Different Parameter Passing Modes.</title>
<pages>653-678</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta24.html#Lao87</url>
<abstract>Wand's technique of deriving compilers from denotational semantics is applied to a block structured language with recursive functions. The emphasis is on compilation of different parameter passing modes and a simple storage management. The technique starts by eliminating λ-variables from semantic equations through the introduction of special-purpose combinators. The final code consists of combinators equivalent to target-machine instructions (running-system procedures). The method enables us to derive a compiler and a running system directly from the denotational semantics of a language.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00282620</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CohenR76">
<author>Jacques Cohen</author>
<author>Martin S. Roth</author>
<title>On the Implementation of Strassen's Fast Multiplication Algorithm.</title>
<pages>341-355</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#CohenR76</url>
<abstract>A detailed analysis of Strassen's multiplication algorithm is presented; the analysis consists in deriving a symbolic formula, called time-formula, expressing the time taken to perform matrix multiplications using a combination of Strassen's and the regular method. The variables in the formula represent the time taken to perform the basic operations that can be executed in present day computers; these include arithmetic operations; subscripting, iteration overhead, etc. By binding actual numerical values, corresponding to a given compiler-machine configuration, to the variables one can determine the execution time for that configuration. The derived time-formula corresponds to an optimized and non-recursive version of Strassen's algorithm. This version uses a special scheme for positioning the elements of the matrices, the scheme being particularly suitable for usage in a paging environment. It has been found that Strassen's method can be used in multiplying 40 × 40 matrices (on an Algol-PDP-10 configuration) in a slightly better time than the standard method. Curves expressing the speed-up achieved by Strassen's method are presented. This information is substantiated by benchmarks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268135</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeeL92">
<author>Chung-Yee Lee</author>
<author>Surya Danusaputro Liman</author>
<title>Single Machine Flow-Time Scheduling with Scheduled Maintenance.</title>
<pages>375-382</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta29.html#LeeL92</url>
<abstract>In this paper, we investigate a single machine scheduling problem of minimizing the sum of job flow times subject to scheduled maintenance. We first provide an NP-completeness proof for the problem. This proof is much shorter than the one given in Adiri et al. [1]. The shortest processing time (SPT) sequence is then shown to have a worst case error bound of 2/7. Furthermore, an example is provided to show that the bound is tight. This example also serves as a counter-example to the 1/4 error bound provided in Adiri et al. [1].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178778</ee>
</article>
<article mdate="2013-03-07" key="journals/acta/Kahrs13">
<author>Stefan Kahrs</author>
<title>Infinitary rewriting: closure operators, equivalences and models.</title>
<pages>123-156</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Infinitary Term Rewriting allows to express infinite terms and transfinite reductions that converge to those terms. Underpinning the machinery of infinitary rewriting are closure operators on relations that facilitate the formation of transfinite reductions and transfinite equivalence proofs. The literature on infinitary rewriting has largely neglected to single out such closure operators, leaving them implicit in definitions of (transfinite) rewrite reductions, or equivalence relations. This paper unpicks some of those definitions, extracting the underlying closure principles used, as well as constructing alternative operators that lead to alternative notions of reduction and equivalence. A consequence of this unpicking is an insight into the abstraction level at which these operators can be defined. Some of the material in this paper already appeared in Kahrs (2010). The paper also generalises the notion of equational model for infinitary rewriting. This leads to semantics-based notions of equivalence that tie in with the equivalences constructed from the closure operators.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0174-y</ee>
<url>db/journals/acta/acta50.html#Kahrs13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/PaulPR80">
<author>Wolfgang J. Paul</author>
<author>Ernst J. Prau&szlig;</author>
<author>R&uuml;diger Reischuk</author>
<title>On Alternation.</title>
<pages>243-255</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#PaulPR80</url>
<abstract>Every alternating t(n)-time bounded multitape Turing machine can be simulated by an alternating t(n)-time bounded 1-tape Turing machine. Every nondeterministic t(n)-time bounded 1-tape Turing machine can be simulated by an alternating (n + (t(n)) 1/2)-timebounded 1-tape Turing machine. For wellbehaved functions t(n) every nondeterministic t(n)-time bounded 1-tape Turing machine can be simulated by a deterministic ((nlogn)1/2 + (t(n))1/2)-tape bounded off-line Turing machine. These results improve or extend results by Chandra-Stockmeyer, Lipton-Tarjan and Paterson.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264255</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BanatreFQ82">
<author>Jean-Pierre Ban&acirc;tre</author>
<author>Patrice Frison</author>
<author>Patrice Quinton</author>
<title>A Network for the Detection of Words in Continuous Speech.</title>
<pages>431-448</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#BanatreFQ82</url>
<abstract>A highly parallel algorithm for implementing word-spotting techniques is presented together with its realization on a systolic network of processors. Performances of this network are estimated and compared with results obtained on sequential architectures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289579</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LaLonde79">
<author>Wilf R. LaLonde</author>
<title>Constructing LR Parsers for Regular Right Part Grammars.</title>
<pages>177-193</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#LaLonde79</url>
<abstract>Regular right part (RRP) grammars differ from context free (CF) grammars by virtue of the fact that the production right parts are nondeterministic finite automatons (FAs). LR(k) parsers for RRP grammars are linear time parsers which can determine the right end of each handle by considering at most k terminal symbols to its right and the left end (after the right end has been found) by considering at most one parse stack state to its left. This paper is concerned with the construction of a class of LR(k) parsers for RRP grammars which makes use of FAs for determining both the right and left ends of the handle.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264024</ee>
</article>
<article mdate="2014-10-13" key="journals/acta/SorgeMNW14">
<author>Manuel Sorge</author>
<author>Hannes Moser</author>
<author>Rolf Niedermeier</author>
<author>Mathias Weller</author>
<title>Exploiting a hypergraph model for finding Golomb rulers.</title>
<pages>449-471</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>Golomb rulers are special rulers where for any two marks it holds that the distance between them is unique. They find applications in radio frequency selection, radio astronomy, data encryption, communication networks, and bioinformatics. An important subproblem in constructing “compact” Golomb rulers is Golomb Subruler  (GSR), which asks whether it is possible to make a given ruler Golomb by removing at most \(k\) marks. We initiate a study of GSR from a parameterized complexity perspective. In particular, we consider a natural hypergraph characterization of rulers and investigate the construction and structure of the corresponding hypergraphs. We exploit their properties to derive polynomial-time data reduction rules that reduce a given instance of GSR to an equivalent one with \({{\mathrm{O}}}(k^3)\) marks. Finally, we complement a recent computational complexity study of GSR by providing a simplified reduction that shows NP-hardness even when all integers are bounded by a polynomial in the input length.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0202-1</ee>
<url>db/journals/acta/acta51.html#SorgeMNW14</url>
</article>
<article mdate="2003-11-25" key="journals/acta/HoogeboomV00">
<author>Hendrik Jan Hoogeboom</author>
<author>Nike van Vugt</author>
<title>Fair sticker languages.</title>
<pages>213-225</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037003/00370213.htm</ee>
<url>db/journals/acta/acta37.html#HoogeboomV00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nishimura80">
<author>Hirokazu Nishimura</author>
<title>Descriptively Complete Process Logic.</title>
<pages>359-369</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Nishimura80</url>
<abstract>The main purpose of this paper is to contribute to the development of Pratt's [12, 13] process logic by presenting a modest language for this logic in which some reasonably powerful class of connectives is definable. In particular, Parikh's [8] formidable language SOAPL is shown to be interpretable in our new language. Semantically, Pneuli's [9, 10] temporal semantics is incorporated into that of process logic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286492</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hesselink89">
<author>Wim H. Hesselink</author>
<title>Predicate-Transformer Semantics of General Recursion.</title>
<pages>309-332</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#Hesselink89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276020</ee>
</article>
<article mdate="2007-02-07" key="journals/acta/Tabuada07">
<author>Paulo Tabuada</author>
<title>Symbolic models for control systems.</title>
<pages>477-500</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>In this paper we provide a bridge between the infinite state models used in control theory to describe the evolution of continuous physical processes and the finite state models used in computer science to describe software. We identify classes of control systems for which it is possible to construct equivalent (bisimilar) finite state models. These constructions are based on finite, but otherwise arbitrary, partitions of the set of inputs or outputs of a control system.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0036-6</ee>
<url>db/journals/acta/acta43.html#Tabuada07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Donahue77"> 
<author>James E. Donahue</author>
<title>Locations Considered Unnecessary.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>221-242</pages>
<url>db/journals/acta/acta8.html#Donahue77</url>
<abstract>Recent papers have attacked the use of locations, or pointers, as data objects in programs. This paper considers a generalization of this attack — attempting to remove locations from the underlying semantic model. Using the “mathematical semantics” of Scott and Strachey, we show that reference parameters and Algol scope rules for procedures, two constructs requiring the notion of reference, can be replaced with alternative constructs not requiring locations in the definition. Some conclusions are also drawn about the use of mathematical semantics as a language design tool.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264468</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/GiloiES75"> 
<author>Wolfgang K. Giloi</author>
<author>Jos&eacute; L. Encarna&ccedil;&atilde;o</author>
<author>S. Savitt</author>
<title>Interactaive Graphics on Intelligent Terminals in a Time-Sharing Environment.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>257-271</pages>
<url>db/journals/acta/acta5.html#GiloiES75</url>
<abstract>Interactive graphics in a time-sharing environment should be organized in such a way that the user's activities are locally processed in order to avoid unacceptably long response times — especially if only low-speed communication links are available. On the other hand, the host computer must be kept informed about the user's actions and, conversely, the display file in the terminal has to be updated whenever the execution of the application program cases a change in the visual representation. In order to avoid the transmission of redundancy, we decompose the display file into two intersecting parts such that the part in the host computer and the other in the terminal contains only the locally required information. The necessary communication between both parts is maintained by an information module generated on the base of a low-low-level intermediate language (L4) and exchanged between computer and terminal. This leads to the notion of an abstract terminal whose “machine language” is L4, facilitating the implementation and portability of graphic programming systems. The L4 concept and our experiences with its implementation is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264561</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Fisher92">
<author>Anthony J. Fisher</author>
<title>A "Yo-Yo" Parsing Algorithm for a Large Class of van Wijngaarden Grammars.</title>
<pages>461-481</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#Fisher92</url>
<abstract>An algorithm is described for parsing a large class of van Wijngaarden grammars in polynomial time. The algorithm is based on Earley's context-free parsing algorithm, with the addition of a bottom-up component and a mechanism for implementing consistent substitution. In contrast to earlier algorithms, this algorithm works for grammars which are both non-left-bound and non-right-bound.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193578</ee>
</article>
<article mdate="2014-05-14" key="journals/acta/FridmanP14">
<author>Wladimir Fridman</author>
<author>Bernd Puchala</author>
<title>Distributed synthesis for regular and contextfree specifications.</title>
<pages>221-260</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>We consider the distributed realizability problem for systems with regular and deterministic contextfree local specifications. We characterize exactly the architectures for which the realizability problem is decidable. This extends known results on local specifications in two directions. First, architectures with cycles are allowed instead of just acyclic ones and second, deterministic contextfree specifications are considered.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0194-x</ee>
<url>db/journals/acta/acta51.html#FridmanP14</url>
</article>
<article mdate="2012-09-23" key="journals/acta/OttoZ91">
<author>Friedrich Otto</author>
<author>Louxin Zhang</author>
<title>Decision Problems for Finite Special String-Rewriting Systems that are Confluent on Some Congruence Class.</title>
<pages>477-510</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#OttoZ91</url>
<abstract>The class of decision problems for which finite, special string-rewriting systems that are confluent on some congruence class effectively provide algorithms is compared to the class of decision problems for which finite, monadic, and confluent string-rewriting systems effectively yield algorithms. Among the decision problems solved are the word problem, the power problem, the left-and right-divisibility problems, the finiteness problem, the group problem, the problem of torsion-freeness, the inclusion problem, and the generalized word problem. In particular, it is shown that the technique of linear sentences of Book [7] applies to finite, special string-rewriting systems that are confluent on some congruence class.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178585</ee>
</article>
<article mdate="2014-02-14" key="journals/acta/LiZZ14">
<author>Suo Ping Li</author>
<author>Yong Qiang Zhou</author>
<author>Yong Zhou</author>
<title>Delay and energy efficiency analysis of multicast cooperative ARQ over wireless networks.</title>
<pages>51-60</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper investigates the performance of multicast cooperative ARQ (MCARQ) in wireless networks for reducing the system’s waiting time and the sum energy, where the delay and energy analytical model are proposed under equivalent service time and ideal Nyquist pulse. The packet transmission process is modulated by a three-state Markov chain, then the steady-state distribution of the MCARQ is obtained by solving the Markov chain. Further, the queue waiting time and energy efficiency of the multicast ARQ (MARQ) and MCARQ are obtained respectively. Theoretical analysis and simulation results demonstrate that the MCARQ protocol has a better performance than the MARQ in delay and energy efficiency. The presented model has potentially applications in practical systems, e.g. Multi-user MIMO communications.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0192-4</ee>
<url>db/journals/acta/acta51.html#LiZZ14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Weber92">
<author>Andreas Weber</author>
<title>On the Lengths of Values in a Finite Transducer.</title>
<pages>663-687</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#Weber92</url>
<abstract>We investigate finite transducers and their inner structure with regard to the lengths of values. Our transducer models are the normalized finite transducer (NFT) and the nondeterministic generalized sequential machine (NGSM), which is a real-time NFT. The length-degree of an NFT is defined to be the maximal number of different lengths of values for an input word or is infinite, depending on whether or not a maximum exists. We show: An NGSMM with finite length-degree can be effectively decomposed into finitely many NGSMsM 1, ...,M N having length-degree at most 1 such that the transduction realized byM is the union of the transductions realized byM 1, ...,M N. Using this decomposition, the equivalence of NGSMs with finite length-degree is recursively decidable. Whether or not an NGSM has finite length-degree can be decided in deterministic polynomial time. By reduction, all these results can be generalized to NFTs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185566</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bozapalidis91">
<author>Symeon Bozapalidis</author>
<title>Effective Construction of the Syntactic Algebra of a Recognizable Series on Trees.</title>
<pages>351-363</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta28.html#Bozapalidis91</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01893886</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Tuzhilin93">
<author>Alexander Tuzhilin</author>
<title>Querying Datalog Programs with Temporal Logic.</title>
<pages>679-700</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta30.html#Tuzhilin93</url>
<abstract>Temporal logic queries on Datalog and negated Datalog programs are studied, and their relationship to Datalog queries on these programs is explored. It is shown that, in general, temporal logic queries have more expressive power than Datalog queries on Datalog and negated Datalog programs. It is also shown that anexistential domain-independent fragment of temporal logic queries has the same expressive power as Datalog queries on negated Datalog programs with inflationary semantics. This means that for finite structures this class of queries has the power of the fixpoint logic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191723</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Ehrich74"> 
<author>Hans-Dieter Ehrich</author>
<title>Grundlagen einer Theorie der Datenstrukturen und Zugriffssysteme. Teil I: Datenstrukturen und Schemata.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>201-211</pages>
<url>db/journals/acta/acta4.html#Ehrich74</url>
<abstract>A mathematical model for data structures is presented from which other well known and widely used methods of representation can be derived easily. In this model the schema/instance relationship which is especially important with regard to data base systems, is described in terms of partitions, quotient structures, and homomorphisms of data structures. The main result is an algebraic characterization of the set of possible schemas for a given data structure.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288726</ee>
</article>

<article mdate="2006-11-22" key="journals/acta/HarjuN06">
<author>Tero Harju</author>
<author>Dirk Nowotka</author>
<title>Periods in Extensions of Words.</title>
<pages>165-171</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Let π(w) denote the minimum period of the word w,let w be a primitive word with period π(w) < |w|, and let z be a prefix of w. It is shown that if π(wz) = π(w), then |z| < π(w) − gcd (|w|, |z|). Detailed improvements of this result are also proven. Finally, we show that each primitive word w has a conjugate w′ = vu, where w = uv, such that π(w′) = |w′| and |u| < π(w). As a corollary we give a short proof of the fact that if u,v,w are words such that u 2 is a prefix of v 2, and v 2 is a prefix of w 2, and v is primitive, then |w| > 2|u|.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0014-z</ee>
<url>db/journals/acta/acta43.html#HarjuN06</url>
</article>
<article mdate="2003-11-25" key="journals/acta/BorealeS98">
<author>Michele Boreale</author>
<author>Davide Sangiorgi</author>
<title>A Fully Abstract Semantics for Causality in the \pi-Calculus.</title>
<pages>353-400</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta35.html#BorealeS98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035005/80350353.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Pager77a"> 
<author>David Pager</author>
<title>A Practical General Method for Constructing LR(k) Parsers.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>249-268</pages>
<url>db/journals/acta/acta7.html#Pager77a</url>
<abstract>The paper presents in detail the case for k=1 of a practical general method for constructing LR(k) parsers. For k=1 this method is of rival efficiency to the previous general algorithm described by the author in [21]. The method involves combining the states of an LR(k) parser as they are generated, reducing to a fraction, in the process, the number of configurations that need actually be evaluated, or for which space must be assigned — compared to such general methods as those of [1, 11, 12, 17]. The criteria of compatibility introduced for this purpose are such that the parser obtained is in practice identical in size to, or negligibly larger than, that obtained by resolving the inadequacies of an LR(o) parser (as is done for various subsets of the LR(k) grammars in [5, 8, 14, 20]).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290336</ee>
</article>

<article mdate="2005-03-14" key="journals/acta/Csuhaj-VarjuMM05">
<author>Erzs&eacute;bet Csuhaj-Varj&uacute;</author>
<author>Carlos Mart&iacute;n-Vide</author>
<author>Victor Mitrana</author>
<title>Hybrid networks of evolutionary processors are computationally complete.</title>
<pages>257-272</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>A hybrid network of evolutionary processors (an HNEP) consists of several language processors which are located in the nodes of a virtual graph and able to perform only one type of point mutations (insertion, deletion, substitution) on the words found in that node, according to some predefined rules. Each node is associated with an input and an output filter, defined by some random-context conditions. After applying in parallel a point mutation to all the words existing in every node, the new words which are able to pass the output filter of the respective node navigate simultaneously through the network and enter those nodes whose input filter they are able to pass. We show that even the so-called elementary HNEPs are computationally complete. In this case every node is able to perform only one instance of the specified operation: either an insertion, or a deletion, or a substitution of a certain symbol. We also prove that in the case of non-elementary networks, any recursively enumerable language over a common alphabet can be obtained with an HNEP whose underlying structure is a fixed graph depending on the common alphabet only.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://www.springerlink.com/index/10.1007/s00236-004-0158-7</ee>
<url>db/journals/acta/acta41.html#Csuhaj-VarjuMM05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Strassen72"> 
<author>Volker Strassen</author>
<title>Berechnung und Programm. I.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>320-335</pages>
<url>db/journals/acta/acta1.html#Strassen72</url>
<abstract>Let A be an algebraic structure and assign to each operation of A a nonnegative real number as the performance time of the operation on a given computer. The notion of a computation (or straight line program) in A yields two functions from finite subsets of A to nonnegative real numbers, namely the computational length (or complexity), and the computational depth. We characterize these functions in a quasiaxiomatic way and prove a number of general results, which will be applied to concrete problems elsewhere (see [12]–[15]).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289512</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/HwangL71"> 
<author>Frank K. Hwang</author>
<author>Shen Lin 0005</author>
<title>Optimal Merging of 2 Elements with n Elements.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>145-158</pages>
<url>db/journals/acta/acta1.html#HwangL71</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289521</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Stalmarck96">
<author>Gunnar St&aring;lmarck</author>
<title>Short Resolution Proofs for a Sequence of Tricky Formulas.</title>
<pages>277-280</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta33.html#Stalmarck96</url>
<abstract>A class of propositional formulas, encoding the property that every finite, transitive digraph with no two-cycles must have a source, has been investigated by Krishnamurty and conjectured as hard for resolution. In this note we prove, opposed to that conjecture, that there are proofs of polynomial lengths (or even linear in the lengths of the formulas) of those formulas.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050044</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Earley73"> 
<author>Jay Earley</author>
<title>Relational Level Data Structures for Programming Languages</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>293-309</pages>
<url>db/journals/acta/acta2.html#Earley73</url>
</article>


<article mdate="2006-05-10" key="journals/acta/Meduna06">
<author>Alexander Meduna</author>
<title>Deep pushdown automata.</title>
<pages>541-552</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>This paper introduces and discusses deep pushdown automata as a generalization of the classical pushdown automata. This generalization consists in allowing them to make expansions deeper in the pushdown. Based on the expansion depth, the present paper establishes an infinite hierarchy of language families that coincides with the hierarchy resulting from the n-limited state grammars, so the deep pushdown automata actually represent the automaton counterpart to these grammars. In its conclusion, this paper suggests some open problem areas.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0005-0</ee>
<url>db/journals/acta/acta42.html#Meduna06</url>
</article>
<article mdate="2008-01-15" key="journals/acta/FuzzatiMN07">
<author>Rachele Fuzzati</author>
<author>Massimo Merro</author>
<author>Uwe Nestmann</author>
<title>Distributed Consensus, revisited.</title>
<pages>377-425</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We provide a novel model to formalize a well-known algorithm, by Chandra and Toueg, that solves Consensus among asynchronous distributed processes in the presence of a particular class of failure detectors (◊\(\mathcal{S}\) or, equivalently, Ω), under the hypothesis that only a minority of processes may crash. The model is defined as a global transition system that is unambigously generated by local transition rules. The model is syntax-free in that it does not refer to any form of programming language or pseudo code. We use our model to formally prove that the algorithm is correct.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0052-1</ee>
<url>db/journals/acta/acta44.html#FuzzatiMN07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EveK77"> 
<author>J. Eve</author>
<author>Reino Kurki-Suonio</author>
<title>On Computing the Transitive Closure of a Relation.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>303-314</pages>
<url>db/journals/acta/acta8.html#EveK77</url>
<abstract>An algorithm is presented for computing the transitive closure of an arbitrary relation which is based upon Tarjan's algorithm [7] for finding the strongly connected components of a directed graph. A new formulation, justifying a somewhat simplified statement of the latter, characterises weaker restrictions on the form of the graph traversal than Tarjan's depth first conditions and reveals aspects of the behaviour of this algorithm which have been obscure hitherto.If V is the number of vertices in the directed graph representing the relation then the worst case behaviour, O(V 3) is inferior to existing algorithms [1, 2] which require O(V 3/log V) and \(O(V^{log_2 7} log V)\) operations respectively. The best case performance, O(V 2) operations, is better. Viewed in this way, it is similar to other algorithms [5, 6, 8] but it combines the improved efficiency in the presence of strongly connected components which characterises the algorithms in [5, 6] with the advantages of Warshall's algorithm [8], namely, succinctness, a single traversal of the directed graph and ability to exploit the availability of Boolean vector operations.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271339</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Martin83">
<author>Alain J. Martin</author>
<title>A General Proof Rule for Procedures in Predicate Transformer Semantics.</title>
<pages>301-313</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Martin83</url>
<abstract>A proof rule for the procedure call is derived for procedures with value, result and value-result parameters. It is extended to procedures with unrestricted global variables and to recursive procedures. Like D. Gries's proof rule, it is based on the substitution rule for assignment. However, it is more general and much simpler to apply. Assume that {U} S {V} has been proved about the procedure body S. The proof rule for determining whether a call establishes predicate E is based on finding an “adaptation” A satisfying A∧V ⇒ E′, where E′ is derived from E by some substitution of parameters.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264276</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AdamsGV79">
<author>Colin Adams</author>
<author>Erol Gelenbe</author>
<author>Jean Vicard</author>
<title>An Experimentally Validated Model of the Paging Drum.</title>
<pages>103-117</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#AdamsGV79</url>
<abstract>The behaviour of the paging drum or disc has a significant impact on the performance of multiprogrammed, paging systems. A study is made of such devices using the three tools of performance evaluation: an analytical model, a simulation model and empirical measurements. The models extend previous studies by including non-exponential arrival times and a comparison is made between the proposed analytical model and standard models using Poisson arrivals.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264019</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BookC76">
<author>Ronald V. Book</author>
<author>Ashok K. Chandra</author>
<title>Inherently Nonplanar Automata.</title>
<pages>89-94</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#BookC76</url>
<abstract>It is shown that for every finite-state automaton there exists an equivalent nondeterministic automaton with a planar state graph. However there exist finite-state automata with no equivalent deterministic automaton with a planar state graph.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263745</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/CoffmanDW02">
<author>Edward G. Coffman Jr.</author>
<author>Peter J. Downey</author>
<author>Peter M. Winkler</author>
<title>Packing rectangles in a strip.</title>
<pages>673-693</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038010/20380673.htm</ee>
<url>db/journals/acta/acta38.html#CoffmanDW02</url>
</article>
<article mdate="2006-11-22" key="journals/acta/AroraJSMC06">
<author>Amrinder Arora</author>
<author>Fanchun Jin</author>
<author>Gokhan Sahin</author>
<author>Hosam Mahmoud</author>
<author>Hyeong-Ah Choi</author>
<title>Throughput analysis in wireless networks with multiple users and multiple channels.</title>
<pages>147-164</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>We consider the problem of maximizing throughput in a multi-carrier wireless network that employs predictive link adaptation. We explicitly consider the time-penalty incurred due to link adaptation. The contributions of this paper are twofold. Firstly, several high performance algorithms (offline and online) are developed for efficient performance in multiple user and multiple channel environment under the practicable lookahead prediction of one time slot. Secondly, the presented algorithms and heuristics are shown to be competitive by deterministic and probabilistic analyses. Our results show that a modest consumption of resources for channel prediction and link adaptation may result in a significant throughput improvement.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0012-1</ee>
<url>db/journals/acta/acta43.html#AroraJSMC06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Deussen78">
<author>Peter Deussen</author>
<title>A Unified Approach to the Generation and the Acception of Formal Languages.</title>
<pages>377-390</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Deussen78</url>
<abstract>The duality of generation and acception of the Chomsky classes of languages is emphasized by considering the corresponding acceptors as Semi-Thue-Systems instead of unnatural “machines”.It is shown as one main result that lba's, pda's and fsa's are characterized by imposing extremely simple and natural length conditions on the productions of the accepting Semi-Thue-System. As a second result, the shift-reduce or LR-acceptor which is wellknown from syntax analysis is generalised for CH-1 and CH-0 languages. As for contextfree languages, the LR-acceptor when scanning a word from Left to right yields a Right-most derivation in the general sense.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289049</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GergelyU82">
<author>Tam&aacute;s Gergely</author>
<author>L&aacute;szl&oacute; &Uacute;ry</author>
<title>A Theory of Interactive Programming.</title>
<pages>1-20</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#GergelyU82</url>
<abstract>The center of study is programming that allows communication between program and its environment. A modified version of Hoare's CSP is applied as programming language and its main features in connection with semantics and completeness are investigated. Semantics is based on an appropriate type of games by using its tree representation. These entities are shown to be definable in first order logic. Hence the descriptive language is complete in the classical sense and a complete calculus is developed in the spirit of Floyd and Hoare.To illustrate the usage of the descriptive language and its calculus a program simulating a simple calculator is considered.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262972</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Dunne85">
<author>Paul E. S. Dunne</author>
<title>A 2.5<i>n</i> Lower Bound on the Monotone Network Complexity of T_3^n.</title>
<pages>229-240</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#Dunne85</url>
<abstract>The k-th threshold function, T k n , is defined as: \(T_k^n \left( {x_1 ,...,x_n } \right) = \left\{ \begin{gathered} 1 if \sum\limits_{i = 1}^n {x_i \geqq k} \hfill \\ 0 otherwise \hfill \\ \end{gathered} \right.\) where x iε{0,1} and the summation is arithmetic. We prove that any monotone network computing T 3/n(x 1,...,x n) contains at least 2.5n-5.5 gates.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264232</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/IbarraK84">
<author>Oscar H. Ibarra</author>
<author>Sam M. Kim</author>
<title>A Characterization of Systolic Binary Tree Automata and Applications.</title>
<pages>193-207</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#IbarraK84</url>
<abstract>This paper has two main contributions. The first is a natural and useful characterization of systolic binary tree automata (BTA's) in terms of a simple class of Turing machines. The second is a proof technique for showing that a language is not accepted by a BTA. Various closure properties of languages accepted by BTA's are easily obtained from these two results.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289240</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/LocuratoloR98">
<author>Elvira Locuratolo</author>
<author>Fausto Rabitti</author>
<title>Conceptual Classes and System Classes in Object Databases.</title>
<pages>181-210</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta35.html#LocuratoloR98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035003/80350181.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Gonczarowski85">
<author>Jakob Gonczarowski</author>
<title>Decidable Properties of Monadic Recursive Schemas With a Depth Parameter.</title>
<pages>277-310</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta22.html#Gonczarowski85</url>
<abstract>Monadic table counter schemas (MTCS) are defined as extensions of recursive monadic schemas by incorporating a depth-of-recursion counter. The family of languages generated by free MTCS under Herbrand interpretation is shown to be the family of ETOL languages. It is proven that the halting and divergence problems are decidable for free MTCS and that the freedom problem is decidable. Most of these results are obtained using results on regular control sequences from L system theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265683</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/KinoshitaP00">
<author>Yoshiki Kinoshita</author>
<author>John Power</author>
<title>Data Refinement and Algebraic Structure.</title>
<pages>693-719</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360693.htm</ee>
<url>db/journals/acta/acta36.html#KinoshitaP00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Bouchet79">
<author>P. Bouchet</author>
<title>Proc&eacute;dures de reprise dans les syst&egrave;mes de gestion de base de donn&eacute;es r&eacute;parties.</title>
<pages>305-340</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Bouchet79</url>
<abstract>In this paper, two recovery techniques used to restore the integrity of the distributed database management system operating in the presence of intermittent failures and with a checkpointing and roll-back recovery scheme are analysed and compared. A mathematical model of the distributed database management system is proposed to evaluate its disponibility at the updating and interrogating operations in the case of one, two, three and four distributed copies. Numerical illustrations are presented and it is shown that the recovery procedure based on the transfert of the valid copies across the network is better in some given conditions of processing of the distributed database management system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289092</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Brandwajn76">
<author>Alexandre Brandwajn</author>
<title>A Model of a Virtual Memory System.</title>
<pages>365-386</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Brandwajn76</url>
<abstract>We present a queueing network model of a virtual memory computer system including the effect of memory sharing among processes. Page fault and file request system overheads are explicitly taken into account. The fact that some memory pages have to be saved in the secondary memory at the moment of a page fault, is also taken into consideration. We obtain an approximate solution using an equivalence and decomposition approach. The effect of system and program behavior parameters (primary memory size, drum and disk characteristics, program locality, input-output rates and different pages ratios) as well as that of the total number of processes, are examined for two different system organizations. In the first one, all the processes share real core; in the second, processes having issued a file request lose their memory space until the I/O is performed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268138</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/TipS00">
<author>Frank Tip</author>
<author>Peter F. Sweeney</author>
<title>Class Hierarchy Specialization.</title>
<pages>927-982</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036012/00360927.htm</ee>
<url>db/journals/acta/acta36.html#TipS00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Clint73"> 
<author>Maurice Clint</author>
<title>Program Proving: Coroutines.</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>50-63</pages>
<url>db/journals/acta/acta2.html#Clint73</url>
<abstract>Proof methods adequate for a wide range of computer programs have been given in [1–6]. This paper develops a method suitable for programs which incorporate coroutines. The implementation of coroutines described follows closely that given in SIMULA [7, 8], a language in which such features may be used to great advantage. Proof rules for establishing the correctness of coroutines are given and the method is illustrated by the proof of a useful program for histogram compilation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00571463</ee>
</article>


<article mdate="2003-11-25" key="journals/acta/BusscheC98">
<author>Jan Van den Bussche</author>
<author>Luca Cabibbo</author>
<title>Converting Untyped Formulas to Typed Ones.</title>
<pages>637-643</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350637.htm</ee>
<url>db/journals/acta/acta35.html#BusscheC98</url>
</article>
<article mdate="2003-11-25" key="journals/acta/CulikA73"> 
<author>Karel Cul&iacute;k</author>
<author>Michael A. Arbib</author>
<title>Sequential and Jumping Machines and their Relation to Computers</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>162-171</pages>
<url>db/journals/acta/acta2.html#CulikA73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/KedemS81">
<author>Zvi M. Kedem</author>
<author>Abraham Silberschatz</author>
<title>A Characterization of Database Graphs Admitting a Simple Locking Protocol.</title>
<pages>1-13</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#KedemS81</url>
<abstract>A simple locking protocol is presented for transactions executing concurrently in a database. The locking protocol is not two-phase, but each entity in the database may be locked at most once by any transaction. The database is modeled by a directed graph whose vertices correspond to the entities, and whose arcs correspond to certain locking restrictions. Necessary and sufficient conditions which assure serializability and deadlock-freedom in the absence of a concurrency control are derived.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289586</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DewarMS82">
<author>Robert B. K. Dewar</author>
<author>Susan M. Merritt</author>
<author>Micha Sharir</author>
<title>Some Modified Algorithms for Dijkstra's Longest Upsequence Problem.</title>
<pages>1-15</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#DewarMS82</url>
<abstract>Using the techniques of “specification and transformation by parts”, algorithms are derived for the longest upsequence problem. First Dijkstra's algorithm and then two new modified merge algorithms are derived and presented in detail. The merge algorithms take advantage of natural runs in the input sequence and have a worst caseO(n logn) time complexity when appropriate merging techniques are used, but can be linear if long runs are present in the sequence. The first merge algorithm is logically equivalent to Dijkstra's algorithm; the second algorithm is based on the first one but uses a different merging technique. Expository remarks describe related results which evolved out of our work in programming by transformation; in particular, parallels are drawn between algorithms for the longest upsequence problem and algorithms for sorting.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625277</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PerrinP71"> 
<author>Dominique Perrin</author>
<author>Jean-Fran&ccedil;ois Perrot</author>
<title>Congruences et Automorphismes des Automates Finis.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>159-172</pages>
<url>db/journals/acta/acta1.html#PerrinP71</url>
<abstract>We study a class of congruences of strongly connected finite automata, called the group congruences, which may be defined in this way: every element fixing any class of the congruence induces a permutation on this class. These congruences form an ideal of the lattice of all congruences of the automaton \(\mathfrak{A}\) and we study the group associated with the maximal group congruence (maximal induced group) with respect to the Suschkevitch group of the transition monoid of \(\mathfrak{A}\). The transitivity equivalence of the subgroups of the automorphism group of \(\mathfrak{A}\) are found to be the group congruences associated with regular groups, which form also in ideal of the lattice of congruences of \(\mathfrak{A}\). We then characterize the automorphism group of \(\mathfrak{A}\) with respect to the maximal induced group. As an application, we show that, given a group G and an automaton \(\mathfrak{A}\), there exists an automaton whose automorphism group is isomorphic to G and such that the quotient by the automorphism congruence is \(\mathfrak{A}\).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289522</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/BoassonCN73"> 
<author>Luc Boasson</author>
<author>J. P. Crestin</author>
<author>Maurice Nivat</author>
<title>Familles de langages translatables et ferm&eacute;es par crochet</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>383-393</pages>
<url>db/journals/acta/acta2.html#BoassonCN73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Nain82">
<author>Philippe Nain</author>
<title>Partage de t&acirc;ches entre processeurs homogenes.</title>
<pages>449-466</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Nain82</url>
<abstract>Une méthode de partage de tâches entre deux processeurs homogènes interconnectés est proposée. Nous supposons que l'un des deux processeurs est plus rapide que l'autre et nous donnons un algorithme s'appuyant sur une modélisation du système, permettant de diminuer les temps d'exécution des tâches du processeur le plus lent en les sous-traitant au processeur le plus rapide. L'algorithme proposé tient compte à la fois de la charge du processeur le plus rapide et des temps de transmission. L'efficacité de l'algorithme est montré à travers une étude théorique et une étude expérimentale mettant en æuvre un PDP 11/03 et un PDP 11/34.A method for task scheduling between two homogeneous interconnected processors is proposed. We assume that one of the processors is faster than the other and we develop an algorithm based on a model of the system, which minimizes the execution delay of tasks arriving to the slow processor by taking into account the load of the fastest processor and the transmission delay. The performance of the algorithm is investigated experimentally using a PDP 11/03 connected to a PDP 11/34.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289580</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LangenhopW89">
<author>Carl Langenhop</author>
<author>William E. Wright</author>
<title>A Model of the Dynamic Behavior of B-Trees.</title>
<pages>41-59</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta27.html#LangenhopW89</url>
<abstract>We present a practical and efficient model for the estimation of average performance measures of B-trees under dynamic conditions of insertions and deletions. Performance measures computed are average storage utilization, average path length, and average tree height. The model introduces a data structure, called a lineage tree, which permits a highly compact representation of B-trees while still retaining information needed to compute the above performance measures. The model then involves a Markov chain in which the states are “lineages” obtained from the lineage tree. Probabilities, based on the number of B-tree structures corresponding to each lineage, are derived for the transition from one lineage to another under certain dynamic conditions. Results are given for tree orders ranging from 5 up to 401, and for numbers of keys up to 140000. Computer requirements are shown to be small to moderate.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263500</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeveneL91">
<author>Mark Levene</author>
<author>George Loizou</author>
<title>Correction to Null Values in Nested Relational Databases by Mark A. Roth, H. F. Korth, and A. Silberschatz.</title>
<pages>603-605</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#LeveneL91</url>
<abstract>We show that the extended projection of a nested relation in Partitioned Normal Form (PNF) is not a precise generalization of standard projection with respect to unnesting and PNF possibility functionPOSS.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463948</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Soisalon-SoininenU79">
<author>Eljas Soisalon-Soininen</author>
<author>Esko Ukkonen</author>
<title>A Method for Transforming Grammars into LL(k) Form.</title>
<pages>339-369</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Soisalon-SoininenU79</url>
<abstract>A new method for transforming grammars into equivalent LL(k) grammars is studied. The applicability of the transformation is characterized by defining a subclass of LR(k) grammars, called predictive LR(k) grammars, with the property that a grammar is predictive LR(k) if and only if the corresponding transformed grammar is LL(k). Furthermore, it is shown that deterministic bottom-up parsing of a predictive LR(k) grammar can be done by the LL(k) parser of the transformed grammar. This parsing method is possible since the transformed grammar always ‘left-to-right covers’ the original grammar. The class of predictive LR(k) grammars strictly includes the class of LC(k) grammars (the grammars that can be parsed deterministically in the left-corner manner). Thus our transformation is more powerful than the one previously available, which transforms LC(k) grammars into LL(k) form.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268320</ee>
</article>
<article mdate="2010-12-28" key="journals/acta/Epstein10">
<author>Leah Epstein</author>
<title>Equilibria for two parallel links: the strong price of anarchy versus the price of anarchy.</title>
<pages>375-389</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>We consider a job scheduling game with two uniformly related parallel machines (or links). Jobs are atomic players, and the delay of a job is the completion time of the machine running it. The private goal of each job is to minimize its own delay and the social goal is to minimize the maximum delay of any job, that is, to minimize the makespan. We consider the well known price of anarchy as well as the strong price of anarchy, and show that for a wide range of speed ratios these two measures are very different whereas for other speed ratios these two measures give the exact same bound. We extend all our results for models of restricted assignment, where a machine may have an initial load resulting from jobs that can only be assigned to this machine, and show tight results for all variants.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0124-5</ee>
<url>db/journals/acta/acta47.html#Epstein10</url>
</article>
<article mdate="2005-11-14" key="journals/acta/SchmittS05">
<author>Ingo Schmitt</author>
<author>Gunter Saake</author>
<title>A comprehensive database schema integration method based on the theory of formal concepts.</title>
<pages>475-524</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Integrating heterogeneous database schemata is a major task in federated database design where preexisting and heterogeneous database systems need to be integrated virtually by providing a homogenization database interface. Most proposed schema integration methods suffer from very complex result schemata and insufficient handling of extensional relations, i.e. in the way how redundant data of the input systems are dealt with. Redundancy among the input systems may thus remain undetected and, hence, remains uncontrolled.Our GIM (Generic Integration Model) method is based on the elegant and mathematically founded theory of formal concept analysis (FCA). The main idea is to integrate schemata into one formal context which is a binary relation between a set of attributes and a set of base extensions (set of potential objects). From that context we apply an FCA-algorithm to semi-automatically derive a concept lattice which we interpret as an inheritance hierarchy of classes for a homogenized schema. Thus, the integration task following our method can be supported by tools.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0166-2</ee>
<url>db/journals/acta/acta41.html#SchmittS05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KrivanekM86">
<author>Mirko Kriv&aacute;nek</author>
<author>Jaroslav Mor&aacute;vek</author>
<title><i> NP </i> -Hard Problems in Hierarchical-Tree Clustering.</title>
<pages>311-323</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#KrivanekM86</url>
<abstract>We consider a class of optimization problems of hierarchical-tree clustering and prove that these problems are NP-hard. The sequence of polynomial reductions and/or transformations used in our proof is based on relatively laborious graph-theoretical constructions and starts in the NP-complete problem of 3-dimensional matching. Using our main result we establish the NP-completeness of a problem of the best approximation of a symmetric relation on a finite set by an equivalence relation, thus answering in the negative a question proposed implicitly by C.T. Zahn.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289116</ee>
</article>
<article mdate="2009-06-22" key="journals/acta/Engelfriet09">
<author>Joost Engelfriet</author>
<title>The time complexity of typechecking tree-walking tree transducers.</title>
<pages>139-154</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Tree-walking tree transducers can be typechecked in double exponential time. More generally, compositions of k tree-walking tree transducers can be typechecked in (k + 1)-fold exponential time. Consequently k-pebble tree transducers, which form a model of XML transformations and XML queries, can be typechecked in (k + 2)-fold exponential time. The results hold for both ranked and unranked trees.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0087-y</ee>
<url>db/journals/acta/acta46.html#Engelfriet09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/He83">
<author>Jifeng He</author>
<title>General Predicate Transformer and the Semantics of a Programming Language With Go To Statement.</title>
<pages>35-57</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#He83</url>
<abstract>Dijkstra's predicate transformer for specifying the semantics of guarded commands set and proving the total correcness of a program is generalized to a programming language with the go to statement. The concept of general predicate transformer and its properties are introduced. We explore the approach of proving the correctness — preserving property of some common program transformations that are used in the compiling process.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264294</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Langmaack71"> 
<author>Hans Langmaack</author>
<title>Application of Regular Canonical Systems to Grammars Translatable from Left to Right.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>111-114</pages>
<url>db/journals/acta/acta1.html#Langmaack71</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289518</ee>
</article>

<article mdate="2013-12-03" key="journals/acta/EckerR74"> 
<author>Klaus Ecker</author>
<author>Helmut Ratschek</author>
<title>Eigenschaften der von linearen Automaten erkennbaren Worte.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>365-383</pages>
<url>db/journals/acta/acta3.html#EckerR74</url>
<abstract>The paper investigates the set of words accepted by a linear sequential machine M and the algebraic structure of this set. If M is nonsingular a strong relationship exists between this set and the transition group of the accepting automaton. Thus the algebraic structure of this group is used to describe some properties of the set of accepted words. If M is nilpotent, in addition, an algorithm is given which in a direct way generates just the words accepted by M.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263590</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/CoffmanG72"> 
<author>Edward G. Coffman Jr.</author>
<author>Ronald L. Graham</author>
<title>Optimal Scheduling for Two-Processor Systems.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>200-213</pages>
<url>db/journals/acta/acta1.html#CoffmanG72</url>
<abstract>Despite the recognized potential of multiprocessing little is known concerning the general problem of finding efficient algorithms which compute minimallength schedules for given computations and m≧2 processors. In this paper we formulate a general model of computation structures and exhibit an efficient algorithm for finding optimal nonpreemptive schedules for these structures on two-processor systems. We prove that the algorithm gives optimal solutions and discuss its application to preemptive scheduling disciplines.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288685</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/IgarashiLL74"> 
<author>Shigeru Igarashi</author>
<author>Ralph L. London</author>
<author>David C. Luckham</author>
<title>Automatic Program Verification I: A Logical Basis and its Implementation.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>145-182</pages>
<url>db/journals/acta/acta4.html#IgarashiLL74</url>
<abstract>Defining the semantics of programming languages by axioms and rules of inference yields a deduction system within which proofs may be given that programs satisfy specifications. The deduction system herein is shown to be consistent and also deduction complete with respect to Hoare's system. A subgoaler for the deduction system is described whose input is a significant subset of Pascal programs plus inductive assertions. The output is a set of verification conditions or lemmas to be proved. Several non-trivial arithmetic and sorting programs have been shown to satisfy specifications by using an interactive theorem prover to automatically generate proofs of the verification conditions. Additional components for a more powerful verification system are under construction.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288746</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Helman89">
<author>Paul Helman</author>
<title>A Family of NP-Complete Data Aggregation Problems.</title>
<pages>485-499</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#Helman89</url>
<abstract>We consider a family of general aggregation problems and prove each of its members to be NP-complete in the strong sense. These problems require that we partition a set of objects into “aggregates”. The goal is to minimize the expected cost of satisfying an anticipated collection of requests for subsets of the objects, where the cost of satisfying a request includes both the number and the sizes of the aggregates which must be retrieved. The aggregation problems are viewed as very basic versions of important database optimization problems, including: the partitioning of data items into record types, the clustering of records into physical blocks of storage, and the partitioning of a database into granules to support locking. The NP-completeness results demonstrate that such optimization problems are intractable, even when simplified to the extreme. The fact that the problems are NP-complete in the strong sense also rules out pseudopolynomial time solutions, unless P = NP.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289148</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BerardP00">
<author>B&eacute;atrice B&eacute;rard</author>
<author>Claudine Picaronny</author>
<title>Accepting Zeno words: a way toward timed refinements.</title>
<pages>45-81</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037001/00370045.htm</ee>
<url>db/journals/acta/acta37.html#BerardP00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BoxmaK81">
<author>Onno J. Boxma</author>
<author>Alan G. Konheim</author>
<title>Approximate Analysis of Exponential Queueing Systems with Blocking.</title>
<pages>19-66</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#BoxmaK81</url>
<abstract>A network of service stations Q 0 Q 1,...,QM is studied. Requests arrive at the centers according to independent Poisson processes; they travel through (part of) the network demanding amounts of service, with independent and negative exponentially distributed lengths, from those centers which they enter, and finally depart from the network. The waiting rooms or buffers at each service station in this exponential service system are finite. When the capacity at Q i is reached, service at all nodes which are currently processing a request destined next for Q i is instantaneously interrupted. The interruption lasts until the service of the request in the saturated node Q i is. completed. This blocking phenomenon makes an exact analysis intractable and a numerical solution computationally infeasible for most exponential systems. We introduce an approximation procedure for a class of exponential systems with blocking and show that it leads to accurate approximations for the marginal equilibrium queue length distributions. The applicability of the approximation method may not be limited to blocking systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00269808</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Maxson78">
<author>Carlton J. Maxson</author>
<title>Linear Regular Sets.</title>
<pages>203-208</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Maxson78</url>
<abstract>The purpose of this paper is to give a characterization of the sets of words accepted by finite linear automata. Since every linear automaton is isomorphic to a parallel product of a nilpotent linear automaton and a nonsingular linear automaton, our characterization is presented for these two classes of automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289156</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PurdomB81">
<author>Paul Walton Purdom Jr.</author>
<author>Cynthia A. Brown</author>
<title>Parsing Extended <i> LR(k) </i> Grammars.</title>
<pages>115-127</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#PurdomB81</url>
<abstract>An extended LR(k) (ELR(k)) grammar is a context free grammar in which the right sides of the productions are regular expressions and which can be parsed from left to right with k symbol look-ahead. We present a practical algorithm for producing small fast parsers directly from certain ELR(k) grammars, and an algorithm for converting the remaining ELR(k) grammars into a form that can be processed by the first algorithm. This method, when combined with previously developed methods for improving the efficiency of LR(k) parsers, usually produces parsers that are significantly smaller and faster than those produced by previous LR(k) and ELR(k) algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288959</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Devroye93">
<author>Luc Devroye</author>
<title>On the Expected Height of Fringe-Balanced Trees.</title>
<pages>459-466</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#Devroye93</url>
<abstract>We study the effect of a well-known balancing heuristic on the expected height of a random binary search tree. After insertion of an element, if any node on the insertion path has a subtree of size precisely 2t+1 for a fixed integert, then the subtree rooted at that node is destroyed and replaced by a new subtree in which the median of the 2t+1 elements is the new root. IfH n denotes the height of the resulting random tree, we show thatH n /logn →c(t) in probability for some functionc(t). In particular,c(0)=4.31107... (the ordinary binary search tree),c(1)=3.192570 ...,c(3)=2.555539 ...,c(10)=2.049289 ... andc(100)=1.623695 ....</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210596</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Hsieh97">
<author>C. Samuel Hsieh</author>
<title>A Fine-Grained Data-Flow Analysis Framework.</title>
<pages>653-665</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<url>db/journals/acta/acta34.html#Hsieh97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034009/70340653.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SilberschatzJ78">
<author>Abraham Silberschatz</author>
<author>Brian Johnson</author>
<title>Remarks on "Some Comments on Concurrent Readers and Writers" by Reidar Conradi.</title>
<pages>57-60</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#SilberschatzJ78</url>
<abstract>The Synchronization primitive P * was introduced by Conradi in order to present a more compact and efficient algorithm for synchronization of concurrent readers and writers. Unfortunately, Conradi's solutions fail when the conventional definitions of semaphores are used in conjunction with this primitive. This paper proposes a definition of the semaphore operations P, V and P * that make Conradi's readers-writers solutions correct. This definition is compatible with the definition given by Dijkstra.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264599</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hesselink96">
<author>Wim H. Hesselink</author>
<title>Bounded Delay for a Free Address.</title>
<pages>233-254</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta33.html#Hesselink96</url>
<abstract>The problem is to let n processes concurrently and repeatedly search for free addresses in a range of m addresses. The search must be wait-free: a searching process finds an address in a bounded number of steps. Three solutions are presented. The first one has large atomic actions. The second one is only correct if m ≧ (r + 1) · n where r is the maximum number of used addresses. The third solution is always partially correct. It is wait-free if m > r + 2 · n. This solution has a worst-case waiting time quadratic in n and an amortized waiting time linear in n, even linear in the number of active processes.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050042</ee>
</article>
<article mdate="2013-05-10" key="journals/acta/BilottaGPP13">
<author>Stefano Bilotta</author>
<author>Elisabetta Grazzini</author>
<author>Elisa Pergola</author>
<author>Renzo Pinzani</author>
<title>Avoiding cross-bifix-free binary words.</title>
<pages>157-173</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>In this paper we study the construction and the enumeration of binary words in \(\{0,1\}^*\) having more 1’s than 0’s and avoiding a set of cross-bifix-free patterns. We give a particular succession rule, called jumping and marked succession rule, which describes the growth of such words according to their number of ones. Moreover, the problem of associating a word to a path in the generating tree obtained by the succession rule is solved by introducing an algorithm which constructs all binary words having more 1’s than 0’s and then kills those containing the forbidden patterns. Finally, we give the generating function of such words according to the number of ones.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0176-4</ee>
<url>db/journals/acta/acta50.html#BilottaGPP13</url>
</article>
<article mdate="2015-08-18" key="journals/acta/DrewesH15">
<author>Frank Drewes</author>
<author>Berthold Hoffmann</author>
<title>Contextual hyperedge replacement.</title>
<pages>497-524</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>Contextual hyperedge-replacement grammars (contextual grammars, for short) are an extension of hyperedge replacement grammars. They have recently been proposed as a grammatical method for capturing the structure of object-oriented programs, thus serving as an alternative to the use of meta-models like uml class diagrams in model-driven software design. In this paper, we study the properties of contextual grammars. Even though these grammars are not context-free, one can show that they inherit several of the nice properties of hyperedge replacement grammars. In particular, they possess useful normal forms and their membership problem is in NP.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0223-4</ee>
<url>db/journals/acta/acta52.html#DrewesH15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Moller85">
<author>Bernhard M&ouml;ller</author>
<title>On the Algebraic Specification of Infinite Objects - Ordered and Continuous Models of Algebraic Types.</title>
<pages>537-578</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta22.html#Moller85</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00267044</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MoritaNYZ97">
<author>Kenichi Morita</author>
<author>Noritaka Nishihara</author>
<author>Yasunori Yamamoto</author>
<author>Zhiguo Zhang</author>
<title>A Hierarchy of Uniquely Parsable Grammar Classes and Deterministic Acceptors.</title>
<pages>389-410</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta34.html#MoritaNYZ97</url>
<abstract>We introduce a new class of grammars called uniquely parsable grammars (UPGs). A UPG is a kind of phrase structure grammar having a restricted type of rewriting rules, where parsing can be performed without backtracking. We show that, in spite of such restriction to the rules, UPGs are universal in their generating ability. We then define three subclasses of UPGs. They are M-UPGs (monotonic UPGs), RC-UPGs (UPGs with right-terminating and context-free-like rules), and REG-UPGs (regular UPGs). It is proved that the generating abilities of the classes of M-UPGs, RC-UPGs, and REG-UPGs are exactly characterized by the classes of deterministic linear-bounded automata, deterministic pushdown automata, and deterministic finite automata, respectively. Especially, the class of RC-UPGs gives a very simple grammatical characterization of the class of deterministic context-free languages. Thus, these four classes form a deterministic counterpart of the classical Chomsky hierarchy.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050091</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ONeil92">
<author>Patrick E. O'Neil</author>
<title>The SB-Tree: An Index-Sequential Structure for High-Performance Sequential Access.</title>
<pages>241-265</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta29.html#ONeil92</url>
<abstract>A variant of aB-tree known as anSB-tree is introduced, with the object of offering high-performance sequential disk access for long range retrievals. The key to this efficiency is a structure that supports multi-page reads (or writes) during sequential access to any node level below the root, even following significant node splitting. In addition, theSB-tree will support a policy to ‘stripe’ successive multi-page blocks on multiple disks to achieve maximum parallelism. Compared to traditionalB-tree structures,SB-tree performance characteristics are less subject to degradation resulting from modifications entailed in growing and shrinking;SB-trees are therefore more appropriate for use in situations where frequent reorganization is not possible. A performance analysis reveals the strengths of theSB-tree by comparing its performance under various circumstances to theB +-tree and the bounded disorder (BD) file of [11]. The performance analysis formulates a new useful concept, the ‘effective depth’ of anSB- orB +-tree, defined as the expected number of pages read from disk to perform a random retrieval search given standard buffering behavior. A graph of effective depth against tree size is shown to have a scalloped appearance, reflecting the changing effectiveness of incremental additions to buffer space.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185680</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MiliDM87">
<author>Ali Mili</author>
<author>Jules Desharnais</author>
<author>Fatma Mili</author>
<title>Relational Heuristics for the Design of Deterministic Programs.</title>
<pages>239-276</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta24.html#MiliDM87</url>
<abstract>It has been shown that the design of deterministic programs can be formulated as the resolution of relational equations. Because relational calculi are not sufficiently structured, there are no algorithmic solutions to relational equations. In this paper, we formulate some heuristic solutions to these equations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265990</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/OvermarsL82">
<author>Mark H. Overmars</author>
<author>Jan van Leeuwen</author>
<title>Dynamic Multi-Dimensional Data Structures Based on Quad- and <i> K - D </i> Trees.</title>
<pages>267-285</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#OvermarsL82</url>
<abstract>Quad-trees and k—d trees have been noted for their lack of dynamic properties as data structures for multi-dimensional point sets. We describe a method to insert points in a quad-tree while keeping the tree balanced that achieves an average time complexity of O(log2 N) per insertion, where N is the number of updates performed on the quad-tree. We define a structure similar to a quad-tree, called a pseudo quad-tree, and show how it can be used to handle both insertions and deletions in O(log2 N) average time. We also discuss how quad-trees and pseudo quadtrees can be extended for use in configurations of points in which more than one point may have a same value in some equal coordinate, without altering the earlier time bounds for insertions, deletions and queries. Similar algorithms are given for k—d trees and the same average time bounds for insertion and deletion are achieved.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264354</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Dijkstra76">
<author>Edsger W. Dijkstra</author>
<title>On a Gauntlet Thrown by David Gries.</title>
<pages>357-359</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Dijkstra76</url>
<abstract>It is requested to design a program that will generate the N! permutations of the values from 0 through N — 1 in such an order that the transition from one permutation to the next is always performed by exactly one swap of two neighbours.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268136</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Iwama83">
<author>Kazuo Iwama</author>
<title>The Universe Problem for Unrestricted Flow Languages.</title>
<pages>85-96</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Iwama83</url>
<abstract>Unrestricted flow languages (UFL's) are denoted by unrestricted flow expressions, namely regular expressions extended with the shuffle operator and its closure. It is shown that the universe problem for UFL's over a binary alphabet is unsolvable. “Over a binary alphabet” should be emphasized since the shuffle operator prevents us from careless application of the usual coding technique. To develop a way of mapping arbitrary unrestricted flow expressions into those over a binary alphabet while preserving as many characteristics as possible is another main purpose of this paper.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263929</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kemp89">
<author>Rainer Kemp</author>
<title>The Expected Additive Weight of Trees.</title>
<pages>711-740</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#Kemp89</url>
<abstract>We consider a general additive weight of random trees which depends on the structure of the subtrees, on weight functions defined on the number of internal and external nodes and on the degrees of the nodes appearing in the tree and its subtrees. Choosing particular weight functions, the corresponding weight is an important parameter appearing in the analysis of sorting and searching algorithms. For a simply generated family of rooted planar trees ℱ, we shall derive a general approach to the computation of the average weight of a tree Tεℱ with n nodes and m leaves for arbitrary weight functions. This general result implies exact and asymptotic expressions for many types of average weights of a tree Tεℱ with n nodes if the weight functions are arbitrary polynomials in the number of nodes and leaves with coefficients depending on the node degrees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289158</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MontangeroPST78">
<author>Carlo Montangero</author>
<author>Giuliano Pacini</author>
<author>Maria Simi</author>
<author>Franco Turini</author>
<title>Information Management in Context Trees.</title>
<pages>85-94</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#MontangeroPST78</url>
<abstract>Information management in context trees involves three principal problems: retrieval, updating and garbage collection. These problems are discussed in the paper, and solutions are proposed and motivated. A list organization and relative algorithms to implement context trees are presented. Finally, experimental results are reported about the behaviour of a system which exploits context trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260926</ee>
</article>
<article mdate="2006-05-10" key="journals/acta/EpsteinT06">
<author>Leah Epstein</author>
<author>Tamir Tassa</author>
<title>Vector assignment schemes for asymmetric settings.</title>
<pages>501-514</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>We consider off-line vector assignment problems. The goal is to assign input vectors to machines so that a given target function is minimized. The target function usually gives some measure of the quality of the distribution of input vectors among machines. In a previous study (Epstein and Tassa, J. Algorithms 48, 360–384 (2003)) we dealt with this problem where the cost function is symmetric; namely, all machines are identical. The dynamic programming techniques that we used in our previous study do not extend to asymmetric settings. Here, we deal with an asymmetric setting where the cost functions per machine may be different for different machines. Using graph-based techniques, we design a polynomial time approximation scheme for a wide class of asymmetric target functions. Other than a significant extension of the class of cost functions to which our current scheme applies, the present PTAS is much simpler the previous one. It should be noted that asymmetric cost functions appear very naturally in the so called line-up problem that motivated our study.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-005-0003-7</ee>
<url>db/journals/acta/acta42.html#EpsteinT06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Schott72"> 
<author>Gerda Schott</author>
<title>Automatic Analysis of Inflectional Morphems in German Nouns.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>360-374</pages>
<url>db/journals/acta/acta1.html#Schott72</url>
<abstract>Nouns first of all must be considered to be the key words for automatic indexing as they contain the most relevant information of all parts of speech, and as they have statistically the greatest frequency.Since in German we use capital letters for every noun we are able to distinguish homographs of parts of speech to a large extent.The correct analysis of every German noun including foreign words, loan words and exceptions.Automatic recognition of inflected and non-inflected noun homographs.The impossibility of wrong analyses.The algorithm works with a minimum of dictionary operations.The dictionary can be relatively small according to the number of special terms which the specialist considers necessary for his field or for his special task.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289515</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Heilbrunner96">
<author>Stephan Heilbrunner</author>
<title>A Direct Complement Construction for LR(1) Grammars.</title>
<pages>781-797</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta33.html#Heilbrunner96</url>
<abstract>The traditional complement construction for \(LR(1)\) grammars is long and tedious and causes all of the structure of the original grammar to be lost. A new construction method is introduced which produces a complement grammar that is closely related to the original grammar and therefore amenable to further analysis. The method is demonstrated by means of a nontrivial example.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050070</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GargT97">
<author>Vijay K. Garg</author>
<author>Alexander I. Tomlinson</author>
<title>Using the Causal Domain to Specify and verify Distributed Programs.</title>
<pages>667-686</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<url>db/journals/acta/acta34.html#GargT97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034009/70340667.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Janicki87">
<author>Ryszard Janicki</author>
<title>A Formal Semantics for Concurrent Systems with a Priority Relation.</title>
<pages>33-55</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#Janicki87</url>
<abstract>A formal semantics for the COSY path expressions with a priority relation is proposed. It turns out that in the general case the full aspects of behaviours of systems specified by such expressions cannot be modeled by vector firing sequences (a standard semantics for the case without priorities), although vector firing sequences (but without interpretation as causality relations) can correctly be extended for expressions with priorities, and some (but not all) aspects of behaviours, like deadlockfreeness and adaquacy properties, can be defined in terms of vector firing sequences. To describe the behaviours of the COSY priority path expressions entirely, a new semantics, called the multiple firing sequence semantics, is introduced and some its properties are proved.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290705</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FayolleGLB74"> 
<author>Guy Fayolle</author>
<author>Erol Gelenbe</author>
<author>Jacques Labetoulle</author>
<author>D. Bastin</author>
<title>The Stability Problem of Broadcast Packet Switching Computer Networks.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>49-53</pages>
<url>db/journals/acta/acta4.html#FayolleGLB74</url>
<abstract>Certain computer networks have been implemented using a radio broadcast frequency over which a large set of terminals are allowed to transmit packets of bits; one such example is the ALOHA computer network [1]. In such systems, a basic problem is that of the blocking of terminals whose transmission of a packet has overlapped in time with transmission by some other terminal. In this paper we consider a “slotted ALOHA” packet transmission scheme with an infinite set of terminals each transmitting at an infinitesimally small rate. We present a probabilistic model of such a system to show that the slotted ALOHA system with an infinite population is inherently unstable. This paper confirms the simulations and results of Kleinrock and Lam [8].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288935</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Wharton76">
<author>R. M. Wharton</author>
<title>Resolution of Ambiguity in Parsing.</title>
<pages>387-395</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Wharton76</url>
<abstract>The use of context-free grammars to define the syntax of programming languages is complicated by the phenomenon of ambiguity. Ambiguity can be resolved by the specification of a unique canonical parse. A set of rules is given which defines a canonical bottom-up parse, and these rules are implemented in a left-to-right bottom-up parsing algorithm. A second set of rules is given which defines a canonical top-down parse, and these rules are similarly implemented in a left-to-right top-down parsing algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268139</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/IndermarkN06">
<author>Klaus Indermark</author>
<author>Thomas Noll</author>
<title>Algebraic Correctness Proofs for Compiling Recursive Function Definitions with Strictness Information.</title>
<pages>1-43</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Adding appropriate strictness information to recursive function definitions we achieve a uniform treatment of lazy and eager evaluation strategies. By restriction to first-order functions over basic types we develop a pure stack implementation that avoids a heap even for lazy arguments. We present algebraic definitions of denotational, operational, and stack-machine semantics and prove their equivalence by means of structural induction.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0013-0</ee>
<url>db/journals/acta/acta43.html#IndermarkN06</url>
</article>
<article mdate="2010-02-16" key="journals/acta/JaghooriSMKM10">
<author>Mohammad Mahdi Jaghoori</author>
<author>Marjan Sirjani</author>
<author>Mohammad Reza Mousavi</author>
<author>Ehsan Khamespanah</author>
<author>Ali Movaghar</author>
<title>Symmetry and partial order reduction techniques in model checking Rebeca.</title>
<pages>33-66</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Rebeca is an actor-based language with formal semantics which is suitable for modeling concurrent and distributed systems and protocols. Due to its object model, partial order and symmetry detection and reduction techniques can be efficiently applied to dynamic Rebeca models. We present two approaches for detecting symmetry in Rebeca models: One that detects symmetry in the topology of inter-connections among objects and another one which exploits specific data structures to reflect internal symmetry in the internal structure of an object. The former approach is novel in that it does not require any input from the modeler and can deal with the dynamic changes of topology. This approach is potentially applicable to a wide range of modeling languages for distributed and reactive systems. We have also developed a model checking tool that implements all of the above-mentioned techniques. The evaluation results show significant improvements in model size and model-checking time.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0111-x</ee>
<url>db/journals/acta/acta47.html#JaghooriSMKM10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SchlumbergerV73"> 
<author>Maurice Schlumberger</author>
<author>Jean Vuillemin</author>
<title>Optimal Disk Merge Patterns.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>25-35</pages>
<url>db/journals/acta/acta3.html#SchlumbergerV73</url>
<abstract>Our purpose is to study the optimal way to merge n initially sorted runs, stored on a disk like device, into a unique sorted file. This problem is equivalent to finding a tree with n leaves which minimizes a certain cost function (see Knuth [1]).We shall study some properties of those optimal trees, in the hope of finding efficient ways for constructing them.In particular, if all the initial runs have the same length, an algorithm for constructing the best merge pattern is described ; its running time is proportional to n 2 and it requires space proportional to n.A special case is also analyzed in which the problem is solved in time and space proportional to n, and which provides some insight into the asymptotic behaviour of optimal merge trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288649</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/KumarP93">
<author>K. Narayan Kumar</author>
<author>Paritosh K. Pandya</author>
<title>Infinitary Parallelism without Unbounded Nondeterminism in CSP.</title>
<pages>467-487</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#KumarP93</url>
<abstract>The theory of CSP is extended to include an infinitary parallel composition operator. The presence of such an operator allows us to write programs where infinitely many agents compute concurrently. We show that this operator can be modelled within the failures-divergences model of Brookes and Roscoe. The operator is continuous in each of its arguments, and in fact preserves the limits of almost all chains in the infinitary product c.p.o. We also demonstrate that this operator adds to the expressive power of CSP. A comparison of this operator with that defined by Barrett [1] is also provided.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210597</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rosenberg86">
<author>Catherine Rosenberg</author>
<title>Files d'attente exponentielles ayant des parametres non-stationnaires dans le temps.</title>
<pages>177-192</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#Rosenberg86</url>
<abstract>There exist a large number of Queueing Systems having a non-stationary behavior. We call non-stationarity, random time-variations of some parameters of the system (i.e. the input or service rates). A typical example is a reliability system which corresponds to the unpredictable breakdown or failure of the server. Random intensity models are natural for describing such phenomena.We introduce a model with randomly changing service rate. It does not obey a certain independence assumption often made in Queueing Theory. A complete analysis of the model is carried out, explicit results and performance curves are given. Jury's criteria are used to find Necessary and Sufficient Conditions for Stability. These criteria are easy to use and allow us to find the conditions of stability which were not obtained in many previous studies.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289497</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Ellis80">
<author>Carla Schlatter Ellis</author>
<title>Concurrent Search and Insertion in 2-3 Trees.</title>
<pages>63-86</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Ellis80</url>
<abstract>The problem being addressed is to allow a number of processes to search and insert concurrently in a 2–3 tree without causing deadlock and without destroying the integrity of the data or structure. We present two solutions which allow more concurrency than do previous solutions. Several techniques for introducing parallelism are illustrated. Finally, simulation results used to evaluate the parallel performance of these algorithms are summarized.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289064</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KastensW91">
<author>Uwe Kastens</author>
<author>William M. Waite</author>
<title>An Abstract Data Type for Name Analysis.</title>
<pages>539-558</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#KastensW91</url>
<abstract>This paper defines an abstract data type on which a solution to the name analysis subproblem of a compiler can be based. (Name analysis uses the scope rules of a language to associate uses of identifiers with their definitions.) We give a state model for the ADT, and show how to implement that model efficiently. The implementation is independent of any particular name analysis, so it is possible to create a library module that can be used in any compiler. Such a library module has been incorporated into the Eli compiler construction system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463944</ee>
</article>
<article mdate="2005-11-14" key="journals/acta/Ying05">
<author>Mingsheng Ying</author>
<title>pi-calculus with noisy channels.</title>
<pages>525-593</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>It is assumed in the π-calculus that communication channels are always noiseless. But it is usually not the case in the mobile systems that developers are faced with in the real life. In this paper, we introduce an extension of π, called πN, in which noisy channels may be present. A probabilistic transitional semantics of πN is given. The notions of approximate (strong) bisimilarity and equivalence between agents in πN are proposed, and various algebraic laws for them are established. In particular, we introduce the notion of stratified bisimulation which is suited to describe behavior equivalence between infinite probabilistic processes. Some useful techniques for reasoning about approximate bisimilarity and equivalence are developed. We also introduce a notion of reliability in order to compare different behaviors of an agent in π and πN. It is shown that reliability is preserved by the basic combinators in π. A link between reliability and bisimulation is given. This provides us with a uniform framework in which we can reason about both correctness properties and reliability of mobile systems. Also, a potential way of combing value-passing process algebras and Shannon’s information theory is pointed out.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0168-0</ee>
<url>db/journals/acta/acta41.html#Ying05</url>
</article>
<article mdate="2012-01-27" key="journals/acta/WangJ12">
<author>Yunhe Wang</author>
<author>Li Jiao</author>
<title>Using transition set sequences to partition behaviors of petri nets.</title>
<pages>15-28</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The transition set semantics (Wang and Jiao, LNCS 6128:84–103, 2010) partitions the Petri net behaviors in a canonical way such that behaviors in an equivalence class have the same canonical transition set sequence. This article extends the semantics in two ways: firstly, the semantics is parameterized by the basic relation on the structural transitions to define different variants; secondly, the semantics for the infinite firing sequences of the net is defined. We prove that these extensions still preserve the well-definedness, soundness and completeness of the semantics. Furthermore, we show how to recognize some infinite sequences called back-loops in the view of this new semantics.</abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0147-6</ee>
<url>db/journals/acta/acta49.html#WangJ12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MonienS85">
<author>Burkhard Monien</author>
<author>Ewald Speckenmeyer</author>
<title>Ramsey Numbers and an Approximation Algorithm for the Vertex Cover Problem.</title>
<pages>115-123</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#MonienS85</url>
<abstract>We show two results. First we derive an upper bound for the special Ramsey numbers r k(q) where r k(q) is the largest number of nodes a graph without odd cycles of length bounded by 2k+1 and without an independent set of size q+1 can have. We prove \(r_k (q) \leqq \frac{k}{{k + {\text{1}}}}q^{\frac{{k + {\text{1}}}}{k}} + \frac{{k + {\text{2}}}}{{k + {\text{1}}}}q\) The proof is constructive and yields an algorithm for computing an independent set of that size. Using this algorithm we secondly describe an O(¦V¦·¦E¦) time bounded approximation algorithm for the vertex cover problem, whose worst case ratio is \(\Delta \leqq {\text{2 - }}\frac{{\text{1}}}{{k + {\text{1}}}}\), for all graphs with at most (2k+3) k (2k+2) nodes (e.g. Δ≦1.8, if ¦V¦≦146000).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290149</ee>
</article>
<article mdate="2010-02-16" key="journals/acta/LoosMM10">
<author>Remco Loos</author>
<author>Florin Manea</author>
<author>Victor Mitrana</author>
<title>Small universal accepting hybrid networks of evolutionary processors.</title>
<pages>133-146</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>In this paper, we improve some results regarding the size complexity of accepting hybrid networks of evolutionary processors (AHNEPs). We show that there are universal AHNEPs of size 6, by devising a method for simulating 2-tag systems. This result improves the best upper bound for the size of universal AHNEPs which was 7. We also propose a computationally and descriptionally efficient simulation of nondeterministic Turing machines with AHNEPs. More precisely, we prove that AHNEPs with ten nodes can simulate any nondeterministic Turing machine of time complexity f (n) in time O(f (n)). This result significantly improves the best known upper bound for the number of nodes in a network simulating in linear time an arbitrary Turing machine, namely 24.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0113-8</ee>
<url>db/journals/acta/acta47.html#LoosMM10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HuangL89">
<author>Bing-Chao Huang</author>
<author>Michael A. Langston</author>
<title>Stable Duplicate-Key Extraction with Optimal Time and Space Bounds.</title>
<pages>473-484</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#HuangL89</url>
<abstract>We consider the problem of transforming a list L of records sorted on some key into two sublists L 1 and L 2 where, for each distinct key in L, L 1 contains the first record of L that possesses the key and L 2 contains all records of L with duplicate keys. We desire that our duplicate-key extraction algorithm perform the transformation in place and be stable (that is, records within each sublist must obey the original order given by L). This operation is useful in database and related file processing environments whenever only distinct keys need be considered. Moreover, stability in extraction insures that L can be efficiently restored at a later time with a stable merge of L 1 and L 2. Any procedure for performing duplicate-key extraction on a list of size n must require at least O(n) time and O(1) extra space, although the obvious algorithm for achieving either bound alone violates the other bound. We design a stable algorithm, using block-rearrangement techniques, and show that it is optimal in the theoretical sense that it achieves both lower bounds simultaneously. We also prove that its worst-case number of key comparisons and record exchanges sum to no more than 6 n, suggesting that the algorithm has practical application as well.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289147</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HorwitzDT87">
<author>Susan Horwitz</author>
<author>Alan J. Demers</author>
<author>Tim Teitelbaum</author>
<title>An Efficient General Iterative Algorithm for Dataflow Analysis.</title>
<pages>679-694</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta24.html#HorwitzDT87</url>
<abstract>Existing iterative algorithms for global dataflow analysis have demonstrable shortcomings; either they can be used only for a limited class of problems or they are needlessly inefficient in some cases. We review several algorithms, pointing out weaknesses and develop a new algorithm that can be used for a wide class of problems and has a runtime that compares favorably ro runtimes of existing algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00282621</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KintalaW80">
<author>Chandra M. R. Kintala</author>
<author>Detlef Wotschke</author>
<title>Amounts of Nondeterminism in Finite Automata.</title>
<pages>199-204</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#KintalaW80</url>
<abstract>The amount of nondeterminism in a nondeterministic finite automaton (NFA) is measured by counting the minimal number of “guessing points” a string w has to pass through on its way to an accepting state. NFA's with more nondeterminism can achieve greater savings in the number of states over their deterministic counterparts than NFA's with less nondeterminism. On the other hand, for some nontrivial infinite regular languages a deterministic finite automaton (DFA) can already be quite succinct in the sense that NFA's need as many states (and even context-free grammars need as many nonterminals) as the minimal DFA has states.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263994</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HansenB78">
<author>Wilfred J. Hansen</author>
<author>Hendrik Boom</author>
<title>The Report on the Standard Hardware Representation for ALGOL 68.</title>
<pages>105-119</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#HansenB78</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289072</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Eichner78">
<author>Lutz Eichner</author>
<title>The Semigroups of Linearly Realizable Finite Automata I.</title>
<pages>341-367</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Eichner78</url>
<abstract>First the problem is solved how one can decide whether an arbitrary finite semigroup H is linearly A-realizable, i.e., whether there exists a linearly realizable finite automaton having a semigroup isomorphic to H. This leads to a question about the existence of certain generating subsets of H. The determination of these subsets is rather complicated in case H-HH=Ø and very simple in case H-HH#Ø. But in the first case we are able to clear up completely the structure of the semigroups which are linearly A-realizable: These are exactly the finite right groups which have maximal subgroups of the type described by Ecker in [4]. In the second case we get only necessary structure conditions. Among other things we shall see: If a semigroup H is linearly A-realizable one can define a congruence relation ρ on it having the property, that H is isomorphic to a semigroup of a strongly connected and linearly realizable automaton iff the so-called index of H equals the index of H/ρ. Developing these results about semigroups we obtain at the same time many structure theorems about linearly realizable automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265678</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Celentano78">
<author>Augusto Celentano</author>
<title>Incremental LR Parers.</title>
<pages>307-321</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Celentano78</url>
<abstract>The concept of incremental parsing is briefly introduced. An algorithm which augments an LR parser with the capability of reanalyzing a limited part of a modified program is illustrated. The algorithm operates on a sequence of configurations representing the parse of the old input and finds the smallest part of the sequence which must be recomputed to obtain the parse of the new input.The implementation is discussed: a suitable data structure and a version of the algorithm which operates upon it are introduced; finally the problem of realizing efficient incremental parsers is faced, showing a modification to the basic algorithm which enable the reanalysis to be performed in linear time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265676</ee>
</article>
<article mdate="2012-08-13" key="journals/acta/KatzRW12">
<author>Bastian Katz</author>
<author>Ignaz Rutter</author>
<author>Gerhard J. Woeginger</author>
<title>An algorithmic study of switch graphs.</title>
<pages>295-312</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We derive a variety of results on the algorithmics of switch graphs. On the negative side we prove hardness of the following problems: Given a switch graph, does it possess a bipartite/planar/triangle-free/Eulerian configuration? On the positive side we design fast algorithms for several connectivity problems in undirected switch graphs, and for recognizing acyclic configurations in directed switch graphs.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0160-4</ee>
<url>db/journals/acta/acta49.html#KatzRW12</url>
</article>
<article mdate="2009-03-05" key="journals/acta/Barany09">
<author>Vince B&aacute;r&aacute;ny</author>
<title>Semi-synchronous transductions.</title>
<pages>29-42</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Semi-synchronously rational relations generalise synchronised rational relations in a natural way. We discuss here some of their basic properties, among them a “Cobham–Semenov-like” dichotomy theorem. Our main result is a characterisation of bijective semi-synchronously rational transductions as those bijections mapping regular relations to regular ones and non-regular relations to non-regular ones.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0083-2</ee>
<url>db/journals/acta/acta46.html#Barany09</url>
</article>
<article mdate="2015-01-08" key="journals/acta/AbolhassanKP99">
<author>Ferri Abolhassan</author>
<author>J&ouml;rg Keller 0001</author>
<author>Wolfgang J. Paul</author>
<title>On the Cost-Effectiveness of PRAMs.</title>
<pages>463-487</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036006/90360463.htm</ee>
<url>db/journals/acta/acta36.html#AbolhassanKP99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Engelfriet91">
<author>Joost Engelfriet</author>
<title>Branching Processes of Petri Nets.</title>
<pages>575-591</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#Engelfriet91</url>
<abstract>The notion of a branching process is introduced, as a formalization of an initial part of a run of a Petri net, including nondeterministic choices. This generalizes the notion of a process in a natural way. It is shown that the set of branching processes of a Petri net is a complete lattice, with respect to the natural notion of partial order. The largest element of this lattice is the unfolding of the Petri net.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463946</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/AguechLM06">
<author>Rafik Aguech</author>
<author>Nabil Lasmar</author>
<author>Hosam M. Mahmoud</author>
<title>Distances in random digital search trees.</title>
<pages>243-264</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Distances between nodes in random trees is a popular topic, and several classes of trees have recently been investigated. We look into this matter in digital search trees. By analytic techniques, such as the Mellin Transform and poissonization, we describe a program to determine the moments of these distances. The program is illustrated on the mean and variance. One encounters delayed Mellin transform equations, which we solve by inspection. In addition to various asymptotics, we give an exact expression for the mean and for the variance in the unbiased case. Interestingly, the unbiased case gives a bounded variance, whereas the biased case gives a variance growing with the number of keys. It is therefore possible in the biased case to show that an appropriately normalized version of the distance converges to a limit. The complexity of moment calculation increases substantially with each higher moment; it is prudent to seek a shortcut to the limit via a method that avoids the computation of all moments. Toward this end, we utilize the contraction method to show that in biased digital search trees the distribution of a suitably normalized version of the distances approaches a limit that is the fixed-point solution of a distributional equation (distances being measured in the Wasserstein metric space). An explicit solution to the fixed-point equation is readily demonstrated to be Gaussian.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0019-7</ee>
<url>db/journals/acta/acta43.html#AguechLM06</url>
</article>
<article mdate="2005-12-14" key="journals/acta/HennessyRY05">
<author>Matthew Hennessy</author>
<author>Julian Rathke</author>
<author>Nobuko Yoshida</author>
<title>safeDpi: a language for controlling mobile code.</title>
<pages>227-290</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>safeDpi is a distributed version of the Picalculus, in which processes are located at dynamically created sites. Parametrised code may be sent between sites using so-called ports, which are essentially higher-order versions of Picalculus communication channels. A host location may protect itself by only accepting code which conforms to a given type associated to the incoming port.We define a sophisticated static type system for these ports, which restrict the capabilities and access rights of any processes launched by incoming code. Dependent and existential types are used to add flexibility, allowing the behaviour of these launched processes, encoded as process types, to depend on the host's instantiation of the incoming code.We also show that a natural contextually defined behavioural equivalence can be characterised coinductively, using bisimulations based on typed actions. The characterisation is based on the idea of knowledge acquisition by a testing environment and makes explicit some of the subtleties of determining equivalence in this language of highly constrained distributed code.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0178-y</ee>
<url>db/journals/acta/acta42.html#HennessyRY05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LiuLL82">
<author>C. L. Liu</author>
<author>Jane W.-S. Liu</author>
<author>Arthur L. Liestman</author>
<title>Scheduling with Slack Time.</title>
<pages>31-41</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#LiuLL82</url>
<abstract>We consider a scheduling problem concerning a set of jobs {J 1, J 2,..., J n } in which the job J i requests C i units of computation time every T i units of time periodically. These jobs are to be executed by a timeshared single-processor computing system. It is assumed that the requests for each job arrive at the system at the beginning of the request periods and that deadline for completion of the requested computation in each period coincides with the beginning of the next period. For a set of jobs that is schedulable by a certain algorithm, the time span between the completion of a request and its deadline is referred to as the slack time of the request. It is shown here that when the set of jobs is scheduled according to the rate monotonic algorithm, the slack time of the first request of any job is no larger than the slack time of any subsequent request of that job. This result enables us to determine lower bounds to slack times of all requests.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262974</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kemp79">
<author>Rainer Kemp</author>
<title>The Average Number of Registers Needed to Evaluate a Binary Tree Optimally.</title>
<pages>363-372</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Kemp79</url>
<abstract>In this paper we determine the number of binary trees with n leaves which can be evaluated optimally with less than or equal to k registers. Furthermore we obtain the result that this number is equal to the number of the binary trees with n leaves, using for traversal a maximum size of stack less than or equal to 2k+1−1. This fact is only a connection between the numbers of the trees and not between the sets of the trees. We compute also the average number ¯R(n) of registers needed to evaluate a binary tree optimally. We get for all ɛ>0: \(\bar R(n + 1) = 1d(\sqrt {n)} + C + F(n) + O(n^{ - 0.5 + \varepsilon } )\)where C = 0.82574... is a constant and F(n) is a function with F(n) = F(4n) for all n>0 and −0.574<F(n)< −0.492.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289094</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DeganoMM96">
<author>Pierpaolo Degano</author>
<author>Jos&eacute; Meseguer</author>
<author>Ugo Montanari</author>
<title>Axiomatizing the Algebra of Net Computations and Processes.</title>
<pages>641-667</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#DeganoMM96</url>
<abstract>Descriptions of concurrent behaviors in terms of partial orderings (callednonsequential processes or simplyprocesses in Petri net theory) have been recognized as superior when information about distribution in space, about causal dependency or about fairness must be provided. However, at least in the general case of Place/Transition (P/T) nets, the proposed models lack a suitable, general notion ofsequential composition.In this paper, a new algebraic axiomatization is proposed, where, given a netN, a term algebraP[N] with two operations of parallel and sequential composition is defined. The congruence classes generated by a few simple axioms are proved isomorphic to a slight refinement of classical processes.Actually,P[N] is a symmetric strict monoidal category1, parallel composition is the monoidal operation on morphisms and sequential composition is morphism composition. BesidesP[N], we introduce a categorys[N] containing the classical occurrence and step sequences. The term algebras ofP[N] and ofs[N] are in general incomparable, thus we introduce two more categoriesK[N] and ℐ[N] providing an upper and a lower bound, respectively. A simple axiom expressing the functoriality of parallel composition mapsK[N] toP[N] ands[N] to ℐ[N], while commutativity of parallel composition mapsK[N] tos[N] andP[N] to ℐ[N] (see Fig. 4).Morphisms ofK[N] constitute a new notion of concrete net computation, while the strictly symmetric strict monoidal category ℐ[N] was introduced previously by two of the authors as a new algebraic foundation for P/T nets [22]. In the context of the present paper, the morphisms of ℐ[N] are proved isomorphic to the processes defined in terms of the “swap” transformation by Best and Devillers [5]. Thus the diamond of the four categories gives a full account in algebraic terms of the relations between interleaving and partial ordering observations of P/T net computations.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036469</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BielaB96">
<author>Andrzej Biela</author>
<author>Jakub Borowczyk</author>
<title>RETRPROV, A System that Looks for Axioms.</title>
<pages>759-780</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta33.html#BielaB96</url>
<abstract> In this paper we shall describe a formal system which enables us to prove theorems within propositional calculus, logic of quantifiers and first order theories, including theorems containing programs. Its main feature relies on generating an additional set of assumptions needed to prove a considered formula. Thus we are able to consider expressions which can become theorems by looking for a special set of assumptions (axioms) and then adding it to the standard set of axioms. Using this system the correctness and equivalence of programs can be determined. In the end we present some experimental results.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050069</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BurriezaG03">
<author>Alfredo Burrieza</author>
<author>Inman P. de Guzm&aacute;n</author>
<title>A functional approach for temporal &#215; modal logics.</title>
<pages>71-96</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/3039002/30390071.htm</ee>
<url>db/journals/acta/acta39.html#BurriezaG03</url>
</article>
<article mdate="2008-05-21" key="journals/acta/Bozapalidis08">
<author>Symeon Bozapalidis</author>
<title>Picture deformation.</title>
<pages>1-31</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Algebraic picture generation based on a pixel deformation theory is presented. The main tool used is the deformation monoid which simulates the algebraic structure of pictures viewed as rectangular arrays with operations the horizontal and vertical concatenation. Picture languages generated by grammatical systems are considered and a Chomsky-like normal form as well as an iteration lemma are established. Infinite pictures are obtained as the ω-completion of the set of finite pictures ordered by picture refinement. Regular fractal pictures (such as the Sierpinski Carpet, the Cantor dust, etc.) are defined as the components of the least solution of systems whose right hand side members are finite pictures. They constitute the least class of pictures containing the finite pictures and closed under substitution and the self similarity operation. Solving non deterministic picture program schemes we get the so called ∞-refinement languages which consist of finite and infinite pictures. For such languages the emptiness and finiteness problems are decidable.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0059-7</ee>
<url>db/journals/acta/acta45.html#Bozapalidis08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AnderssonIKO90">
<author>Arne Andersson</author>
<author>Christian Icking</author>
<author>Rolf Klein</author>
<author>Thomas Ottmann</author>
<title>Binary Search Trees of Almost Optimal Height.</title>
<pages>165-178</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta28.html#AnderssonIKO90</url>
<abstract>First we present a generalization of symmetric binary B-trees, SBB(k)-trees. The obtained structure has a height of only\(\left[ {\left( {1 + \frac{1}{k}} \right)\log (n + 1)} \right]^1 \), wherek may be chosen to be any positive integer. The maintenance algorithms require only a constant number of rotations per updating operation in the worst case. These properties together with the fact that the structure is relatively simple to implement makes it a useful alternative to other search trees in practical applications.Then, by using an SBB(k)-tree with a varyingk we achieve a structure with a logarithmic amortized cost per update and a height of logn+o(logn). This result is an improvement of the upper bound on the height of a dynamic binary search tree. By maintaining two trees simultaneously the amortized cost is transformed into a worst-case cost. Thus, we have improved the worst-case complexity of the dictionary problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01237235</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Seidl89">
<author>Helmut Seidl</author>
<title>On the Finite Degree of Ambiguity of Finite Tree Automata.</title>
<pages>527-542</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta26.html#Seidl89</url>
<abstract>The degree of ambiguity of a finite tree automaton A, da(A), is the maximal number of different accepting computations of A for any possible input tree. We show: it can be decided in polynomial time whether or not da(A)<∞. We give two criteria characterizing an infinite degree of ambiguity and derive the following fundamental properties of an finite tree automaton A with n states and rank L>1 having a finite degree of ambiguity: for every input tree t there is a input tree t 1 of depth less than 22n·n! having the same number of accepting computations; the degree of ambiguity of A is bounded by 22 2·log(L+1)·n.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263578</ee>
</article>
<article mdate="2008-01-15" key="journals/acta/NishimuraRS07">
<author>Naomi Nishimura</author>
<author>Prabhakar Ragde</author>
<author>Stefan Szeider</author>
<title>Solving #SAT using vertex covers.</title>
<pages>509-523</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>We propose an exact algorithm for counting the models of propositional formulas in conjunctive normal form. Our algorithm is based on the detection of strong backdoor sets of bounded size; each instantiation of the variables of a strong backdoor set puts the given formula into a class of formulas for which models can be counted in polynomial time. For the backdoor set detection we utilize an efficient vertex cover algorithm applied to a certain “obstruction graph” that we associate with the given formula. This approach gives rise to a new hardness index for formulas, the clustering-width. Our algorithm runs in uniform polynomial time on formulas with bounded clustering-width. It is known that the number of models of formulas with bounded clique-width, bounded treewidth, or bounded branchwidth can be computed in polynomial time; these graph parameters are applied to formulas via certain (hyper)graphs associated with formulas. We show that clustering-width and the other parameters mentioned are incomparable: there are formulas with bounded clustering-width and arbitrarily large clique-width, treewidth, and branchwidth. Conversely, there are formulas with arbitrarily large clustering-width and bounded clique-width, treewidth, and branchwidth.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0056-x</ee>
<url>db/journals/acta/acta44.html#NishimuraRS07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Seiferas77"> 
<author>Joel I. Seiferas</author>
<title>Iterative Arrays with Direct Central Control.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>177-192</pages>
<url>db/journals/acta/acta8.html#Seiferas77</url>
<abstract>A generalized iterative array model in which the next state of each finite-state computing element may depend on the signs of its location's coordinates and the current state of the computing element at the array origin (“direct central control”) is shown to be no more powerful for on-line time-bounded operation than the standard model of Cole. Applications include a simple iterative array simulation of multihead Turing machines of the same dimension, a simulation without time loss of a further generalized iterative array model with multiple “array heads” which may be shifted locally in the array or reset instantaneously to each other's locations, and simplified versions of several published iterative array algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289248</ee>
</article>

<article mdate="2007-06-13" key="journals/acta/DaiL07">
<author>Tian-Shyr Dai</author>
<author>Yuh-Dauh Lyuu</author>
<title>An exact subexponential-time lattice algorithm for Asian options.</title>
<pages>23-39</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Asian options are popular financial derivative securities. Unfortunately, no exact pricing formulas exist for their price under continuous-time models. Asian options can also be priced on the lattice, which is a discretized version of the continuous- time model. But only exponential-time algorithms exist if the options are priced on the lattice without approximations. Although efficient approximation methods are available, they lack accuracy guarantees in general. This paper proposes a novel lattice structure for pricing Asian options. The resulting pricing algorithm is exact (i.e., without approximations), converges to the value under the continuous-time model, and runs in subexponential time. This is the first exact, convergent lattice algorithm to break the long-standing exponential-time barrier.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0033-9</ee>
<url>db/journals/acta/acta44.html#DaiL07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Becker87">
<author>Bernd Becker</author>
<title>An Easily Testable Optimal-Time VLSI-Multiplier.</title>
<pages>363-380</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#Becker87</url>
<abstract>We consider the design of a ‘tree-multiplier’, which is a modified version of a Wallace tree-multiplier [16] made suitable for VLSI design by Luk and Vuillemin [12]. It is shown that 4 log(n) + 3 test patterns suffice to exhaustively test the multiplier with respect to the ‘cellular fault model’ (which includes tests for all single stuck at faults). Some slight modifications of the multiplier prove, that these tests can be applied without increasing the number of input ports substantially.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292108</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Habermann73"> 
<author>A. Nico Habermann</author>
<title>Critical Comments on the Programming Language Pascal.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>47-57</pages>
<url>db/journals/acta/acta3.html#Habermann73</url>
<abstract>The programming language Pascal is claimed to be more suitable than other languages for “teaching programming as a systematic discipline”. However, an investigation of the Reports on the Pascal language reveals that it suffers as much from ill-defined constructs as many of the languages to which it is supposed to offer an alternative. Problems with the language are caused primarily by the confusion of ranges, types and structures and by the phenomena associated with goto statements.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288652</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Reps88">
<author>Thomas W. Reps</author>
<title>Incremental Evaluation for Attribute Grammars with Unrestricted Movement Between Tree Modifications.</title>
<pages>155-178</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta25.html#Reps88</url>
<abstract>This paper concerns the design of editors that perform checks on a language's context-dependent constraints. Our particular concern is the design of an efficient, incremental analysis algorithm for systems based on the attribute-grammar model of editing. With previous incremental evaluation algorithms for arbitrary noncircular attribute grammars, the editing model required there to be a restriction on the operation that moves the editing cursor: moving the cursor was limited to just a single step in the tree — either to the parent node or to one of the child nodes of the current cursor location. This paper describes a new updating algorithm that can be used when an arbitrary movement of the cursor in the tree is permitted. After an operation that restructures the tree, the tree's attributes can be updated with a cost of 0 ((1+¦AFFECTED¦)·√m), where m is the size of the tree and AFFECTED is the subset of the tree's attributes that require new values, when the cost is amortized over a sequence of tree modifications. the editing cursor may be moved from its current location to any other node of the tree in a single, unit-cost operation. CR Categories and Subject Descriptors: D.2.3 [Software Engineering]: Coding — program editors; D.2.6 [Software Engineering]: Programming Environments; D.3.1 [Programming Languages]: Formal Definitions and Theory — semantics, syntax D.3.4 [Programming Languages]: Processors — translator writing systems and compiler generators F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages — denotational semantics.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263583</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Berry81">
<author>Daniel M. Berry</author>
<title>Remarks on R. D. Tennent's Language Design Methods Based on Semantic Principles: Algol 68, A Language Designed Using Semantic Principles.</title>
<pages>83-98</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Berry81</url>
<abstract>This note observes that Tennent's proposed language design method is that used by Algol 68's designers and points out how his proposed extensions to Pascal bring it closer to Algol 68. Some implications of his proposal are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00269810</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Ehrich73"> 
<author>Hans-Dieter Ehrich</author>
<title>Minimale und m-minimale Variablenmengen f&uuml;r partielle Boole'sche Funktionen</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>172-179</pages>
<url>db/journals/acta/acta2.html#Ehrich73</url>
</article>


<article mdate="2013-11-28" key="journals/acta/Schonhage71"> 
<author>Arnold Sch&ouml;nhage</author>
<title>Schnelle Berechnung von Kettenbruchentwicklungen.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>139-144</pages>
<url>db/journals/acta/acta1.html#Schonhage71</url>
<abstract>Ein von D. E. Knuth angegebenes Verfahren, für ganze Zahlen u, v den größten gemeinsamen Teiler und den Kettenbruch für u/v zu berechnen, wird so modifiziert, daß für n-stellige Zahlen nur O(n(lg n)2 (lglg n)) elementare Schritte gebraucht werden.A method, given by D. E. Knuth for the computation of the greatest common divisor of two integers u, v and of the continued fraction for u/v is modified in such a way that only O(n(lg n)2(lglg n)) elementary steps are used for u,v<.2 n.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289520</ee>
</article>

<article mdate="2008-11-18" key="journals/acta/FanHS08">
<author>Chen-Ming Fan</author>
<author>Cheng-Chih Huang</author>
<author>Huei-Jan Shyr</author>
<title>Regular autodense languages.</title>
<pages>467-477</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>A regular component is either autodense or anti-autodense. Characterizations of a regular component being a pure autodense language and being a pure autodense code are obtained. A relationship between intercodes and anti-autodense languages is that for an intercode L of index m, L n is an anti-autodense language for every n > m.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0078-z</ee>
<url>db/journals/acta/acta45.html#FanHS08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Olderog81">
<author>Ernst-R&uuml;diger Olderog</author>
<title>Sound and Complete Hoare-like Calculi Based on Copy Rules.</title>
<pages>161-197</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Olderog81</url>
<abstract>This paper presents a uniform approach to known and new results on relative completeness of Hoare-like calculi for languages of ALGOL-like programs with procedures as procedure parameters. First the notion of a copy rule is introduced. It provides a uniform framework for dealing with different variants of semantics reaching from dynamic to static scope. Then for each copy rule ℒ a Hoare-like calculus ℋ(ℒ) is presented, the soundness of which is shown by using an approximating semantics. The key to the completeness results lies in a general completeness theorem on the calculi ℋ(ℒ) which has these results as corollaries. Finally, a new type of theorem on Hoare-like calculi is proved by which the notion of formal provability in ℋ(ℒ) is completely characterized. This characterization theorem is the main result of the paper. It covers both soundness and completeness of the calculi ℋ(ℒ) and additionally gives an idea of what the limits of presently known Hoare-like proof techniques for programming languages with procedures are.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261258</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NielsenRT92">
<author>Mogens Nielsen</author>
<author>Grzegorz Rozenberg</author>
<author>P. S. Thiagarajan</author>
<title>Elementary Transition Systems and Refinement.</title>
<pages>555-578</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#NielsenRT92</url>
<abstract>Elementary transition systems are-in a strong categorical sense-the transition system version of a basic system model of net theory called elementary net systems. The structural notion of a region associated with elementary transition systems captures the intuitive idea of a local state as modelled by the conditions of an elementary net system. In this paper we equip elementary transition systems with a refinement operation over the local states (regions). We then show our operation satisfies a number of interesting properties. In particular, this operation supports compositional reasoning. It is very hard if not impossible to define a corresponding operation at the level of nets which enjoys similar properties. This is due to the concrete choice of conditions used to enforce intended behaviour. Thus our results show that the more abstract-but essentially equivalent-model of elementary transition systems is the appropriate framework for theoretical studies concerning refinement operations for elementary net systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185561</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schnorr76"> 
<author>Claus-Peter Schnorr</author>
<title>The Network Complexity and the Turing Machine Complexity of Finite Functions.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>95-107</pages>
<url>db/journals/acta/acta7.html#Schnorr76</url>
<abstract>Let L(f) be the network complexity of a Boolean function L(f). For any n-ary Boolean function L(f) let \(TC(f) = min\{ T_p^{\bar A} (n){\text{ (}}\parallel p\parallel + 1gS_p^{\bar A} {\text{(}}n{\text{):}}res_p^{\bar A} {\text{(}}n{\text{) = }}f\} \). Hereby p ranges over all relative Turing programs and Ā ranges over all oracles such that given the oracle Ā, the restriction of p to inputs of length n is a program for L(f). ∥p∥ is the number of instructions of p. T p Ā (n) is the time bound and S p Ā of the program p relative to the oracle Ā on inputs of length n. Our main results are (1) L(f) ≦ O(TC(L(f))), (2) TC(f) ≦ O(L(f) 2 2+ɛ) for every ɛ ⋙ O.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265223</ee>
</article>

<article mdate="2008-08-08" key="journals/acta/GodlinS08">
<author>Benny Godlin</author>
<author>Ofer Strichman</author>
<title>Inference rules for proving the equivalence of recursive procedures.</title>
<pages>403-439</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>Inspired by Hoare’s rule for recursive procedures, we present three proof rules for the equivalence between recursive programs. The first rule can be used for proving partial equivalence of programs; the second can be used for proving their mutual termination; the third rule can be used for proving the equivalence of reactive programs. There are various applications to such rules, such as proving equivalence of programs after refactoring and proving backward compatibility.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0075-2</ee>
<url>db/journals/acta/acta45.html#GodlinS08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Eichner78a">
<author>Lutz Eichner</author>
<title>The Semigroups of Linearly Realizable Finite Automata II.</title>
<pages>369-390</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Eichner78a</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265679</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/LesleyF03">
<author>Nicole Lesley</author>
<author>Alan Fekete</author>
<title>Providing view synchrony for group communication services.</title>
<pages>159-210</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Building applications in a distributed computing environment is a complex process involving reasoning about message ordering, system failures, link failures etc. Group communication services attempt to make this task easier by providing building blocks to be used in assembling such systems and by defining properties that are guaranteed by these services. One such property is VS (view synchrony) which imposes restrictions on when messages can be delivered, guaranteeing that processors who share the same view of the distributed environment receive either the same set of messages or prefixes of the set received by one processor. This paper provides a precise description of an algorithm (based on ideas of Cristian and Schmuck) and a proof that this algorithm provides VS. The contributions of this paper are to show that VS is implementable and to provide an actual algorithm to implement it. We also show conditional timing properties of the algorithm, giving timebounds for group formation under certain stability conditions.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0129-4</ee>
<url>db/journals/acta/acta40.html#LesleyF03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Josephs92">
<author>Mark B. Josephs</author>
<title>Receptive Process Theory.</title>
<pages>17-31</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta29.html#Josephs92</url>
<abstract>An algebraic theory of receptive processes is presented. A receptive process models the interaction by input events and output events between a system and its environment. Input from the environment and output to the environment are never blocked; but if a system is not ready to receive a particular input, its subsequent behaviour is undefined.In essence, this paper reworks Hoare's theory of Communicating Sequential Processes under the above assumption about communication. The resulting model is more attractive than the failures-divergences model of CSP because the refusal sets of the latter are simplified out of existence. Like CSP, receptive process theory is equipped with a sound and complete set of algebraic laws.Applications of the theory include the design of asynchronous circuits and the study of data flow networks. As an example, this paper verifies algebraically the design of a Muller C-element from a majority-element.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178564</ee>
</article>
<article mdate="2015-02-04" key="journals/acta/Olderog15">
<author>Ernst-R&uuml;diger Olderog</author>
<title>Letter from the Managing Editor.</title>
<pages>1-2</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0212-z</ee>
<url>db/journals/acta/acta52.html#Olderog15</url>
</article>
<article mdate="2012-09-23" key="journals/acta/LauerC77"> 
<author>Peter E. Lauer</author>
<author>Roy H. Campbell</author>
<title>Addenda and Corrigenda: Formal Semantics of a Class of High-Level Primitives for Coordinating Concurrent Processes</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>325</pages>
<url>db/journals/acta/acta7.html#LauerC77</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290341</ee>
<note>see: Acta Informatika 5: 297-332 (1975)</note>
</article>

<article mdate="2008-11-18" key="journals/acta/Link08">
<author>Sebastian Link</author>
<title>Charting the completeness frontier of inference systems for multivalued dependencies.</title>
<pages>565-591</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The implication of multivalued dependencies in relational databases has originally been defined in the context of some fixed finite universe. While axiomatisability and implication problems have been intensely studied with respect to this notion almost no research has been devoted towards the alternative notion of implication in which the underlying universe of attributes is left undetermined. Based on a set of common inference rules we establish all axiomatisations in undetermined universes, and all axiomatisations in fixed universes that indicate the role of the complementation rule as a means of database normalisation. This characterises the expressiveness of several incomplete sets of inference rules. We also establish relationships between axiomatisations in fixed and undetermined universes, and study the time complexity of the implication problem in undetermined universes. The results of this paper establish a foundation for reasoning about multivalued dependencies without the assumption of a fixed underlying universe.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0080-5</ee>
<url>db/journals/acta/acta45.html#Link08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hromkovic83">
<author>Juraj Hromkovic</author>
<title>On-Way Multihead Deterministic Finite Automata.</title>
<pages>377-384</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Hromkovic83</url>
<abstract>It is shown that the family of languages recognized by one-way k head deterministic finite state automata ℒ(1 DFA(k)) and the family of languages recognized by one-way k head deterministic sensing finite state automata ℒ(1DSeFA(k)) are not closed under concatenation, Kleene star and reversal for k≧2. These results are obtained as consequences of a theorem giving a sufficient condition for a language L in order not to be in ℒ(1DSeFA(k)). Several further results above the classes ℒ(1DFA(k)) and ℒ(1DSeFA(k)) are simple consequences of this theorem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290734</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Baeza-Yates89a">
<author>Ricardo A. Baeza-Yates</author>
<title>The Expected Behaviour of B+-Trees.</title>
<pages>439-471</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#Baeza-Yates89a</url>
<abstract>Fringe analysis is used to study the behaviour of B+-trees (B-trees where all the records are stored in the leaves) under random insertions. We obtain bounds for the expected memory utilization and the expected number of accesses to secondary memory per insertion of trees built using the usual insertion algorithm, the B* overflow handling technique, and other techniques derived from the latter. Several other performance measures are also derived, such as bounds for the number of index nodes, the expected height, the expected number of splits per insertion, and the probabilities of 0, 1 and 2 or more splits per insertion. Special emphasis is placed on 2–3 trees. A technique for concurrency in B+-trees is also analyzed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289146</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GlabbeekG01">
<author>Rob J. van Glabbeek</author>
<author>Ursula Goltz</author>
<title>Refinement of actions and equivalence notions for concurrent systems.</title>
<pages>229-327</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>4/5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037004/10370229.htm</ee>
<url>db/journals/acta/acta37.html#GlabbeekG01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Wyrostek86">
<author>Piotr Wyrostek</author>
<title>Precedence Technique is not Worse than SLR(1).</title>
<pages>361-392</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta23.html#Wyrostek86</url>
<abstract>The paper describes a transformation which converts SLR(1) grammars to grammars which are (1, 0) or (1, 1) mixed strategy precedence grammars and which have the correct prefix property. The transformation is first of all practical. The increase of a grammar size caused by the transformation is so moderate that often a smaller parser can be obtained as the final result.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00267864</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BergstraT83">
<author>Jan A. Bergstra</author>
<author>J. Terlouw</author>
<title>Standard Model Semantics for DSL A Data Type Specification Language.</title>
<pages>97-113</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#BergstraT83</url>
<abstract>We discuss a data type specification language DSL(∑) which is obtained from the first order language L(∑) for a given signature ∑ by augmenting it with schemes.A specification is a pair (∑, \(\mathbb{F}\)) with \(\mathbb{F}\) a finite set of axioms in DSL(∑). As semantics of such specifications we propose: standard model semantics, SMS.We investigate DSL/SMS as a specification mechanism for data types and compare it with both first order and algebraic specifications. A concise theory of parametrized data types is developed in this context.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263930</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TaubnerV89">
<author>Dirk Taubner</author>
<author>Walter Vogler</author>
<title>Step Failures Semantics and a Complete Proof System.</title>
<pages>125-156</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta27.html#TaubnerV89</url>
<abstract>The (linear) failures semantics is a well-known model for the theoretical version of Hoare's CSP. We generalize this semantics by taking steps (i.e. multisets of simultaneously occurring actions) instead of single actions as the basic execution unit. Hence opposed to the linear semantics — where parallelism is modelled as arbitrary interleaving in order to avoid technical complication — the step failures semantics models parallelism explicitly and is equally easy to manage. In particular a sound and complete proof system is given. Opposed to the linear model divergence is treated uniformly here. The relation to the linear semantics can be established using our newly introduced deparallelize operator.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265151</ee>
</article>
<article mdate="2005-12-14" key="journals/acta/BettiniVB05">
<author>Lorenzo Bettini</author>
<author>Betti Venneri</author>
<author>Viviana Bono</author>
<title>MOMI: a calculus for mobile mixins.</title>
<pages>143-190</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>MOMI (Mobile Mixins) is a coordination language for mobile processes that communicate and exchange object-oriented code in a distributed context. MOMI's key idea is structuring mobile object-oriented code by using mixin-based inheritance. Mobile code is compiled and typed locally, and can interact successfully with code present on foreign sites only if its type is subtyping-compliant with the type of what is expected by the receiving site. The key feature of the paper is the definition of this subtyping relation on classes and mixins that enables a significantly flexible, yet still simple, communication pattern. We show that communication by subtyping is type-safe in that exchanged code is merged into local code without requiring further type analysis and recompilation.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0176-0</ee>
<url>db/journals/acta/acta42.html#BettiniVB05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Doberkat82">
<author>Ernst-Erich Doberkat</author>
<title>Deleting the Root of a Heap.</title>
<pages>245-265</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Doberkat82</url>
<abstract>The average behavior of the familiar algorithm for root deletion is considered, when every heap has the same probability to occur. The analysis centers around the notion of a viable path in the tree representation, i.e. such a path the label which replaces the label of the root may be allowed to travel when the heap is reconstructed. In case the size of the heap is a power of 2 it is shown that both the expected number of comparisons and of interchanges are asymptotically equal to the respective numbers in the worst case.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264353</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BeauquierS98">
<author>Dani&egrave;le Beauquier</author>
<author>Anatol Slissenko</author>
<title>Polytime Model Checking for Timed Probabilistic Computation Tree Logic.</title>
<pages>645-664</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350645.htm</ee>
<url>db/journals/acta/acta35.html#BeauquierS98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DammJ83">
<author>Werner Damm</author>
<author>Bernhard Josko</author>
<title>A Sound and Relatively * Complete Hoare-Logic for a Language With Higher Type Procedures.</title>
<pages>59-101</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#DammJ83</url>
<abstract>Present day Hoare-like proof-systems are in general not capable of dealing with procedures with procedure parameters. Nevertheless, the fact, that the actual termination problem over finite interpretations is decidable for a language with procedures of finite modes and without global variables [15] indicates, that a relatively complete Hoare-style proof-system for such a language (Clarke's language L 4) should exist, which then necessarily has to incorporate new proof-techniques. This paper presents such a system (using a suitable oracle set) and thus essentially solves the conjecture raised by Langmaack and Olderog.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264295</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/JancarMP96">
<author>Petr Jancar</author>
<author>Frantisek Mr&aacute;z</author>
<author>Martin Pl&aacute;tek</author>
<title>Forgetting Automata and Context-Free Languages.</title>
<pages>409-420</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta33.html#JancarMP96</url>
<abstract>It is shown that context-free languages can be characterized by linear bounded automata with the following restriction: the head can either move right without rewriting or move left with erasing the current cell (i.e. rewriting it with a special, nonrewriteable, symbol). If, instead of erasing, we consider deleting (complete removing of the cell), the corresponding automata are less powerful.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050050</ee>
</article>
<article mdate="2015-06-08" key="journals/acta/Broy15">
<author>Manfred Broy</author>
<title>A life dedicated to informatics: an obituary for Prof. Friedrich L. Bauer.</title>
<pages>299-301</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0241-2</ee>
<url>db/journals/acta/acta52.html#Broy15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/PierreS89">
<author>Laurent Pierre</author>
<author>Sylviane R. Schwer</author>
<title>Rational Index of Vector Addition Systems Languages.</title>
<pages>503-525</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta26.html#PierreS89</url>
<abstract>The rational index ρL of a non-empty language L is a function of ℕ into ℕ, whose asymptotic behavior can be used to classify languages. We prove that the languages associated to Vector Addition System or Petri nets have rational indexes bounded by polynomials. This situation should be contrasted with the case of context-free languages. Indeed some context-free languages like the Greibach's languages have rational indexes bounded by polynomials. But some other context-free languages have rational indexes in exp Θ n and the generators of the rational cone of context-free languages have rational indexes in exp Θ n 2/ln n. We give an upper bound and a lower bound on the rational index of each term of an infinite sequence of V.A.S. languages, such that any V.A.S. language can be obtained as the image by a rational transduction of one of these languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263577</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nahapetian73"> 
<author>A. Nahapetian</author>
<title>Node Flows in Graphs with Conservative Flow.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>37-41</pages>
<url>db/journals/acta/acta3.html#Nahapetian73</url>
<abstract>In analyzing graphs with conservative flow where the node flows are of interest (e.g. algorithm flowcharts) the practice has been to measure or to analytically determine the flows in the independent edges, and to calculate all other edge flows using Kirchhoff's law of flow conservation. The node flows are then obtained as the sum of edge flows entering each node.This paper presents a transformation on such graphs whereby the transformed graph, if analyzed for its edge flows, will directly yield the node flows of the original graph.A proof is also given that the number of node flow measurements determined by the transformed graph never exceeds the number of edge flow measurements that would be required if the transformation were not applied.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288650</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/BijlsmaN98">
<author>Lex Bijlsma</author>
<author>Rob Nederpelt</author>
<title>Dijkstra-Scholten Predicate Calculus: Concepts and Misconceptions.</title>
<pages>1007-1036</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035012/80351007.htm</ee>
<url>db/journals/acta/acta35.html#BijlsmaN98</url>
</article>
<article mdate="2008-05-21" key="journals/acta/MagnaniM08">
<author>Matteo Magnani</author>
<author>Danilo Montesi</author>
<title>Management of interval probabilistic data.</title>
<pages>93-130</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>In this paper we present a data model for uncertain data, where uncertainty is represented using interval probabilities. The theory introduced in the paper can be applied to different specific data models, because the entire approach has been developed independently of the kind of manipulated objects, like XML documents, relational tuples, or other data types. As a consequence, our theory can be used to extend existing data models with the management of uncertainty. In particular, the data model we obtain as an application to XML data is the first proposal that combines XML, interval probabilities and a powerful query algebra with selection, projection, and cross product. The cross product operator is not based on assumptions of independence between XML trees from different collections. Being defined with a possible worlds semantics, our operators are proper extensions of their traditional counterparts, and reduce to them when there is no uncertainty. The main practical result of the paper is a set of equivalences that can be used to compare or rewrite algebraic queries on interval probabilistic data, in particular XML and relational.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0065-9</ee>
<url>db/journals/acta/acta45.html#MagnaniM08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Vasudevan82">
<author>Sridhar Vasudevan</author>
<title>Inner Loops in Flowgraphs and Code Optimization.</title>
<pages>143-155</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Vasudevan82</url>
<abstract>A criterion is developed to define a hierarchy of inner loops in a program which constitute sections of the program which take up large proportions of the execution time; this hierarchy lends a dynamic loop structure to the program. It is assumed that the program has been given a flowgraph representation in which each vertex corresponds to a statement or a set of statements and the flow in each edge corresponds to the frequency of passage of control from one statement or set of statements to another. While developing this criterion an attempt is made to guarantee that moving a loop invariant statement from an inner loop to a point outside of the loop would always yield a more optimal code.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288967</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Alblas89">
<author>Henk Alblas</author>
<title>Iteration of Transformation Passes over Attributed Program Trees.</title>
<pages>1-40</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta27.html#Alblas89</url>
<abstract>Transformations of attributed program trees form an essential part of compiler optimizations. A strategy of repeatedly applying alternate attribute evaluation and tree transformation phases is discussed. An attribute evaluation phase consists of a sequence of passes over the tree. A tree transformation phase consists of a single pass, which is never interrupted to carry out a re-evaluation. Both phases can be performed in parallel. This strategy requires a distinction between consistent (i.e., correct) and approximate attribute values. Tree transformations can be considered safe if they guarantee that the attribute values everywhere in the program tree will remain consistent or will become at least approximations of the consistent values, so that subsequent transformations can be applied correctly.This attribute evaluation and tree transformation strategy shows similarities with the evaluation methods for circular attribute grammars.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263499</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Goldschlager81">
<author>Leslie M. Goldschlager</author>
<title>Varepsilon-Productions in Context-Free Grammars.</title>
<pages>303-308</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Goldschlager81</url>
<abstract>The effect of ɛ-productions on the space complexity of various context-free language problems is investigated. It is shown that the removal of ɛ-productions from a context-free grammar can probably not be achieved with small storage space. This explains the apparent discrepancy between two different results in the literature on the membership problem. By way of contrast, it is shown that the space complexity of the emptiness and the finiteness problems are independent of the presence of ɛ-productions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289308</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Welch76"> 
<author>Peter D. Welch</author>
<title>On the Self Contained Modelling of DB/DC Systems.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>227-247</pages>
<url>db/journals/acta/acta7.html#Welch76</url>
<abstract>This paper discusses the modelling of DB/DC systems operating in a demand paging environment. As an extension of an earlier definition of Denning a class of systems is defined, those operating with “working set integrity”, for which one can obtain system response parameters solely from the resource requirements of the input processes when running in isolation. No external information such as a miss ratio curve from another systems environment is required. The interdependence between the resource requirements of processes when running in a systems environment and the system performance parameters is faced directly and expressed as a set of simultaneous equations. The emphasis is on the effect of the sharing of a common set of pages among the active set of processes. Both unrestricted shared usage and usage with locking are treated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265773</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Bucher83">
<author>Walter Bucher</author>
<title>Two-Symbol DOS Systems Generating Regular Languages.</title>
<pages>133-142</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Bucher83</url>
<abstract>We prove that it is decidable whether a two-symbol DOS system generates a regular language.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289411</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/MoreauD01">
<author>Luc Moreau</author>
<author>Jean Duprat</author>
<title>A construction of distributed reference counting.</title>
<pages>563-595</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037008/10370563.htm</ee>
<url>db/journals/acta/acta37.html#MoreauD01</url>
</article>
<article mdate="2007-06-13" key="journals/acta/Hesselink07">
<author>Wim H. Hesselink</author>
<title>A criterion for atomicity revisited.</title>
<pages>123-151</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Concurrent and reactive programs are specified by their behaviours in the presence of a nondeterministic environment. In a natural way, this gives a specification (ARW) of an atomic variable in the style of Abadi and Lamport. Several implementations of atomic variables by lower level primitives are known. A few years ago, we formulated a criterion to prove the correctness of such implementations. The proof of correctness of the criterion itself was based on Lynch’s definition of atomicity by serialization points. Here, this criterion is reformulated as a specification HRW in the formal sense. Simulations from HRW to ARW and vice versa are constructed. These now serve as a constructive proof of correctness of the criterion. Eternity variables are used in the simulation from HRW to ARW. We propose so-called gliding simulations to deal with the problems that appear when occasionally the concrete implementation needs fewer steps than the abstract specification.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0044-1</ee>
<url>db/journals/acta/acta44.html#Hesselink07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Betteridge74"> 
<author>T. Betteridge</author>
<title>An Analytic Storage Allocation Model.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>101-122</pages>
<url>db/journals/acta/acta3.html#Betteridge74</url>
<abstract>An analytical model of a simple computer storage allocation scheme is described, and its Markov nature established given certain conditions on its input and operation. Simple Markov theory is used to compute the expected storage utilisation in some example situations with small memory sizes. These are compared with the analytical closed-form results which are possible when storage relocation is allowed. Some current restrictions and possible future developments and uses of the model are outlined.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264032</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/WalzJ95"> 
<author>Janet A. Walz</author>
<author>Gregory F. Johnson</author>
<title>Inductive Attribute Grammars: A Basis for Incremental Program Execution.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>2</number>
<year>1995</year> 
<pages>117-144</pages>
<url>db/journals/acta/acta32.html#WalzJ95</url>
<abstract>Attribute grammars are traditionally constrained to be noncircular. In using attribute grammars to specify the semantics of programming languages, this noncircularity limitation has restricted attribute grammars to compile-time or static semantics. Inductive attribute grammars add a general form of circularity to this standard approach. Inductive attribute grammars have the expressiveness required to describe the full semantics of programming languages, while at the same time maintaining the declarative character of standard attribute grammars. This expanded view of attribute grammars proves to be useful in interactive language-based programming environments, as inductive attribute grammars allow the environment to provide an interpreter for incremental re-evaluation of programs after small changes to the code. The addition of run-time semantics via circular attribute grammars permits automatically generated environments to be complete, in that incremental static semantic checking and fast incremental execution are now available within a single framework.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177743</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Turski71"> 
<author>Wladyslaw M. Turski</author>
<title>A Model for Data Structures and Its Applications. I.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>26-34</pages>
<url>db/journals/acta/acta1.html#Turski71</url>
<abstract>This paper presents a constructive model for data structures description based on the concept of data space defined as the Cartesian product of a name space and a value space. The subsets of name space are ordered by an a priori given selector function. The model is used for classification of data structures into regular (array-like), semiregular (key-ordered list-like) and irregular (threaded list-like) data structures. The notion of data storage structures induced by addressing mechanism is introduced and storage mapping functions are described using this concept together with the data structure model. The first part of the paper contains also some of the model applications to regular and semiregular data structure problems and a brief comparison withAlgol 68 treatment of regular data structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264290</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/CoffmanR71"> 
<author>Edward G. Coffman Jr.</author>
<author>Brian Randell</author>
<title>Performance Predictions for Extended Paged Memories.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>1-13</pages>
<url>db/journals/acta/acta1.html#CoffmanR71</url>
<abstract>This paper concerns the problem of obtaining predictions of the extent to which additional core storage would improve the performance of a given paging system based on information that could be obtained from monitoring the system whilst running its normal workload.It is shown that for a large class of replacement algorithms there are efficient techniques for producing exact predictions of the performance improvement, and that for a further class of algorithms statistical predictions can be provided.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264288</ee>
</article>

<article mdate="2014-07-08" key="journals/acta/FahrenbergL14">
<author>Uli Fahrenberg</author>
<author>Axel Legay</author>
<title>General quantitative specification theories with modal transition systems.</title>
<pages>261-295</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>This paper proposes a new theory of quantitative specifications. It generalizes the notions of step-wise refinement and compositional design operations from the Boolean to an arbitrary quantitative setting. Using a great number of examples, it is shown that this general approach permits to unify many interesting quantitative approaches to system design.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0196-8</ee>
<url>db/journals/acta/acta51.html#FahrenbergL14</url>
</article>
<article mdate="2008-11-18" key="journals/acta/MedunaT08">
<author>Alexander Meduna</author>
<author>Jir&iacute; Techet</author>
<title>Scattered context grammars that erase nonterminals in a generalized <i>k</i> -limited way.</title>
<pages>593-608</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>A scattered context grammar erases nonterminals in a generalized k-limited way in a successful derivation, where k is a positive integer, if in every sentential form of a derivation, each of its substrings consisting of nonterminals from which the grammar derives empty strings is of length k or less. This paper demonstrates that if a scattered context grammar generates its sentences in this way, it can be converted to a scattered context grammar without erasing productions; in general, however, this is not possible.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0081-4</ee>
<url>db/journals/acta/acta45.html#MedunaT08</url>
</article>
<article mdate="2003-11-25" key="journals/acta/IwamotoTMI02">
<author>Chuzo Iwamoto</author>
<author>Katsuyuki Tateishi</author>
<author>Kenichi Morita</author>
<author>Katsunobu Imai</author>
<title>A quadratic speedup theorem for iterative arrays.</title>
<pages>847-858</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>11/12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038011/20380847.htm</ee>
<url>db/journals/acta/acta38.html#IwamotoTMI02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Gries79">
<author>David Gries</author>
<title>The Schorr-Waite Graph Marking Algorithm.</title>
<pages>223-232</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Gries79</url>
<abstract>An explanation is given of the Schorr-Waite algorithm for marking all nodes of a directed graph that are reachable from one given node, using the axiomatic method.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289068</ee>
</article>
<article mdate="2011-08-18" key="journals/acta/QiuLZMG11">
<author>Daowen Qiu</author>
<author>Lvzhou Li</author>
<author>Xiangfu Zou</author>
<author>Paulo Mateus</author>
<author>Jozef Gruska</author>
<title>Multi-letter quantum finite automata: decidability of the equivalence and minimization of states.</title>
<pages>271-290</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>Multi-letter quantum finite automata (QFAs) can be thought of quantum variants of the one-way multi-head finite automata (Hromkovič, Acta Informatica 19:377–384, 1983). It has been shown that this new one-way QFAs (multi-letter QFAs) can accept with no error some regular languages, for example (a + b)*b, that are not acceptable by QFAs of Moore and Crutchfield (Theor Comput Sci 237:275–306, 2000) as well as Kondacs and Watrous (66–75, 1997; Observe that 1-letter QFAs are exactly measure-once QFAs (MO-1QFAs) of Moore and Crutchfield (Theor Comput Sci 237:275–306, 2000)). In this paper, we study the decidability of the equivalence and minimization problems of multi-letter QFAs. Three new results presented in this paper are the following ones: (1) Given a k 1-letter QFA \({{\mathcal A}_1}\) and a k 2-letter QFA \({{\mathcal A}_2}\) over the same input alphabet Σ, they are equivalent if and only if they are (n 2 m k-1−m k-1 + k)-equivalent, where m = |Σ| is the cardinality of Σ, k = max(k 1,k 2), and n = n 1 + n 2, with n 1 and n 2 being numbers of states of \({{\mathcal A}_{1}}\) and \({{\mathcal A}_{2}}\) , respectively. When k = 1, this result implies the decidability of equivalence of measure-once QFAs (Moore and Crutchfield in Theor Comput Sci 237:275–306, 2000). (It is worth mentioning that our technical method is essentially different from the previous ones used in the literature.) (2) A polynomial-time O(m 2k-1 n 8 + km k n 6) algorithm is designed to determine the equivalence of any two multi-letter QFAs (see Theorems 2 and 3; Observe that if a brute force algorithm to determine equivalence would be used, as suggested by the decidability outcome of the point (1), the worst case time complexity would be exponential). Observe also that time complexity is expressed here in terms of the number of states of the multi-letter QFAs and k can be seen as a constant. (3) It is shown that the states minimization problem of multi-letter QFAs is solvable in EXPSPACE. This implies also that the state minimization problem of MO-1QFAs (see Moore and Crutchfield in Theor Comput Sci 237:275–306, 2000, page 304, Problem 5), an open problem stated in that paper, is also solvable in EXPSPACE.</abstract>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0139-6</ee>
<url>db/journals/acta/acta48.html#QiuLZMG11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KungP83">
<author>H. T. Kung</author>
<author>Christos H. Papadimitriou</author>
<title>An Optimality Theory of Concurrency Control for Databases.</title>
<pages>1-11</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#KungP83</url>
<abstract>A concurrency control mechanism (or a scheduler) is the component of a database system that safeguards the consistency of the database in the presence of interleaved accesses and update requests. We formally show that the performance of a scheduler, i.e., the amount of parallelism that it supports, depends explicitly upon the amount of information that is available to the scheduler. We point out that most previous work on concurrency control is simply concerned with specific points of this basic trade-off between performance and information. In fact, several of these approaches are shown to be optimal for the amount of information that they use.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263925</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TsudaS83">
<author>Takao Tsuda</author>
<author>Takashi Sato</author>
<title>Transposition of Large Tabular Data Structures with Applications to Physical Database Organization.</title>
<pages>13-33</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#TsudaS83</url>
<abstract>Tabular data structures of a relational database, placed in a paged virtual space or in some two-level storage, are discussed. To rearrange, or transpose, those data stored attributewise to those stored tuplewise, and vice versa, an algorithm is devised that causes a minimal amount of page fetches. The algorithm is near best possible, since it is a generalization of Floyd's algorithm on matrix transposition, shown as the best possible for the case of idealized two-level storage. With a view to practical applications in relational databases, a class of algorithms are specified in detail, so that the exact evaluations of the number of required page fetches can be done. Partial transposition that is important in actual database manipulations is also discussed. Finally the transposition algorithm is extended to cover the case that data lengths may differ between distinct attributes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263926</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Simon89">
<author>Hans-Ulrich Simon</author>
<title>Continuous Reductions Among Combinatorial Optimization Problems.</title>
<pages>771-785</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#Simon89</url>
<abstract>Many reductions among combinatorial problems are known in the context of NP-completeness. These reductions preserve the optimality of solutions. However, they may change the “relative error” of approximative solutions dramatically. In this paper, we apply a new type of reductions, called continuous reductions. When one problem is continuously reduced to another, any approximation algorithm for the latter problem can be transformed into an approximation algorithm for the former. Moreover, the performance ratio is preserved up to a constant factor. We relate the problem “Minimum Number of Inverters in CMOS-Circuits”, which arises in the context of logic synthesis, to several “classical” combinatorial problems such as “Maximum Independent Set” and “Deletion of a Minimum Number of Vertices (Edges) in Order to Obtain a Bipartite (Partial) Subgraph”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289161</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RheeL95"> 
<author>Chongkye Rhee</author>
<author>Y. Daniel Liang</author>
<title>Finding a Maximum Matching in a Permutation Graph.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>8</number>
<year>1995</year> 
<pages>779-792</pages>
<url>db/journals/acta/acta32.html#RheeL95</url>
<abstract>We present anO(n log logn) time algorithm for finding a maximum matching in a permutation graph withn vertices, assuming that the input graph is represented by a permutation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178659</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Miyano82">
<author>Satoru Miyano</author>
<title>A Hierarchy Theorem for Multihead Stack-Counter Automata.</title>
<pages>63-67</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Miyano82</url>
<abstract>Let L b = {w 1 *...* w 2b ¦w i is in {0,1}* and w i = w 2b+1−i for 1≦i≦2b for b≧1. We show that the language L b is not recognizable by any nondeterministic one-way k-head stack-counter automata if \(b > \left( {\begin{array}{*{20}c} k \\ 2 \\ \end{array} } \right)\). As a corollary, we show that k+1 heads are better than k for one-way multihead stack-counter automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262976</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Ying03">
<author>Mingsheng Ying</author>
<title>Reasoning about probabilistic sequential programs in a probabilistic logic.</title>
<pages>315-389</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We introduce a notion of strong monotonicity of probabilistic predicate transformers. This notion enables us to establish a normal form theorem for monotone probabilistic predicate transformers. Three other healthiness conditions, namely, conjunctivity, disjunctivity and continuity for probabilistic predicate transformers are also examined, and they are linked to strong monotonicity. A notion of probabilistic refinement index is proposed, and it provides us with a continuous strength spectrum of refinement relations which may be used to describe more flexible refinement between probabilistic programs. A notion of probabilistic correctness is introduced too. We give a probabilistic weakest-precondition, choice and game semantics to the contract language, and present a probabilistic generalization of the winning strategy theorem.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0113-z</ee>
<url>db/journals/acta/acta39.html#Ying03</url>
</article>
<article mdate="2013-06-06" key="journals/acta/ElmasryFI13">
<author>Amr Elmasry</author>
<author>Arash Farzan</author>
<author>John Iacono</author>
<title>On the hierarchy of distribution-sensitive properties for data structures.</title>
<pages>289-295</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>In this paper new dependencies are added to the hierarchy of the distribution-sensitive properties for data structures. Most remarkably, we prove that the working-set property is equivalent to the unified-bound property; a fact that had gone unnoticed since the introduction of such bounds in the Eighties by Sleator and Tarjan.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0180-8</ee>
<url>db/journals/acta/acta50.html#ElmasryFI13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FrancezP78">
<author>Nissim Francez</author>
<author>Amir Pnueli</author>
<title>A Proof Method for Cyclic Programs.</title>
<pages>133-157</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#FrancezP78</url>
<abstract>We consider the specification and verification of cyclic (sequential and concurrent) programs. The input-output based concept of correctness traditionally applied to functional programs is replaced by another, based on the concept of eventual behaviour. Various types of eventual behaviour are introduced. In the case of concurrency, the introduction of interface-predicates reduces the proof complexity and achieves greater readability. All specifications use explicitly the auxiliary variables of a location counter π and elapsing time t.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289074</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Igarashi77"> 
<author>Yoshihide Igarashi</author>
<title>General Properties of Derivational Complexity.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>267-283</pages>
<url>db/journals/acta/acta8.html#Igarashi77</url>
<abstract>The purpose of this paper is to establish a certain correspondence between shortest derivations of phrase structure grammars and Turing machine computations, and to show how to connect the derivational complexity introduced by Gladkij to Blum's axioms for partial recursive functions and their step-counting functions. It is shown that main theorems on Blum's axiomatic theory of computational complexity can be transfered to the case of derivational complexity.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264470</ee>
</article>

<article mdate="2013-11-22" key="journals/acta/Felice13">
<author>Clelia De Felice</author>
<title>A note on the factorization conjecture.</title>
<pages>381-402</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>We give partial results on the factorization conjecture on codes proposed by Schützenberger. We consider a family of finite maximal codes \(C\) over the alphabet \(A = \{a, b\}\) and we prove that the factorization conjecture holds for these codes. This family contains \((p,4)\)-codes, where a \((p,4)\)-code \(C\) is a finite maximal code over \(A\) such that each word in \(C\) has at most four occurrences of \(b\) and \(a^p \in C\), for a prime number \(p\). We also discuss the structure of these codes. The obtained results once again show relations between factorizations of finite maximal codes and factorizations of finite cyclic groups.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0187-1</ee>
<url>db/journals/acta/acta50.html#Felice13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KollaS91">
<author>Reiner Kolla</author>
<author>Bernd Serf</author>
<title>The Virtual Feedback Problem in Hierarchical Representations of Combinational Circuits.</title>
<pages>463-476</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#KollaS91</url>
<abstract>Orders of magnitude of space and time can be saved if hierarchical algorithms are used for automatic synthesis and analysis of regular VLSI circuits. When we tried to apply this technique to compiled simulation of large regular combinational circuits, we observed that hierarchical representations of acyclic circuits often contain cycles. In this paper we study the question of whether this undesired property is necessary or not. We prove, that there are combinational circuits, which have a succinct cyclic hierarchical representation, but where each acyclic hierarchical representation is large. This negative result may be weakened, if we allow the circuits structure to be changed but not its behavior. We also discuss the effect of these observations on hierarchical simulation techniques and the complexity of pragmatic approaches such as the construction of a smallest acyclic refinement of a hierarchical representation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178584</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Ruohonen83">
<author>Keijo Ruohonen</author>
<title>On Some Variants of Post's Correspondence Problem.</title>
<pages>357-367</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Ruohonen83</url>
<abstract>A variant of Post's Correspondence Problem is considered where two different index words are allowed provided that one of them can be obtained from the other by permuting a fixed number of subwords. It is shown that this variant is undecidable. Post's Correspondence Problem is also extended to circular words, doubly infinite words and doubly infinite powers of words, and shown to be undecidable in all these extensions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290732</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CharlierH95"> 
<author>Baudouin Le Charlier</author>
<author>Pascal Van Hentenryck</author>
<title>Reexecution in Abstract Interpretation of Prolog.</title>
<pages>209-270</pages>
<year>1995</year> 
<volume>32</volume> 
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta32.html#CharlierH95</url>
<abstract>Logic programming, because of referential transparency, enjoys the property that a literal may be reexecuted finitely often without affecting the meaning of the program. This property, although not interesting computationally in general, can be exploited in abstract interpretation to improve the accuracy of the analysis, as noted by Bruynooghe in [6].We study reexecution from its theoretical foundations to its experimental evaluation. We define a new abstract semantics for Prolog, which incorporates the notion of reexecution, and we study its correctness and precision properties. A fixpoint algorithm to compute the abstract semantics is then presented. The accuracy and efficiency of the algorithm is evaluated experimentally on two abstract domains, a simple and an elaborate one, and compared with conventional approaches.The experimental results indicate that (1) reexecution can provide significant gains in accuracy at a very reasonable computation cost and that (2) reexecution on a simple domain is a versatile alternative to the standard approach on a more sophisticated domain.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178260</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/DickKM90">
<author>Jeremy Dick</author>
<author>John Kalmus</author>
<author>Ursula Martin</author>
<title>Automating the Knuth Bendix Ordering.</title>
<pages>95-119</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta28.html#DickKM90</url>
<abstract>Knuth and Bendix proposed a very versatile technique for ordering terms, based upon assigning weights to operators and then to terms by adding up the weights of the operators they contain. Our purpose in this paper is as follows. First we give some examples to indicate the flexibility of the method. Then we give a simple and practical algorithm, based on solving systems of linear inequalities, for determining whether or not a set of rules can be ordered by a Knuth Bendix ordering. We also describe how this algorithm may be incorporated in a completion procedure which thus considers all possible choices of weights which orient a given equation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01237233</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Snyder82">
<author>Lawrence Snyder</author>
<title>Recognition and Selection of Idioms for Code Optimization.</title>
<pages>327-348</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Snyder82</url>
<abstract>Idioms are frequently occurring expressions that programmers use for logically primitive operations for which no primitive construct is available in the language. For example, in ALGOL-60 the expression abs(X − X ÷ 2 × 2) is idiomatic for parity of X. With optimization as a motive, two problems, idiom recognition and selection, are defined. Recognition is solved in O(n log n) time (worst case), O(n) time (average case) on a uniform cost RAM. Selection is solved in O(n) time. Ambiguity is solved in O(n 2) time and is related to resolution theorem proving.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264357</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Berztiss80">
<author>Alfs T. Berztiss</author>
<title>Depth-First K-Trees and Critical Path Analysis.</title>
<pages>325-346</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Berztiss80</url>
<abstract>K-trees are tree representations of digraphs, and depth-first K-trees are Tarjan's depth-first search trees made explicit. Algorithms are given for the construction of depth-first K-trees. The depth-first K-trees are then used as a basis for nonrecursive algorithms for the following: topological ordering of an acyclic digraph, critical path analysis of a scheduling network, determination of longest paths from a single source in an acyclic digraph, and determination of strong components of a digraph. The time complexity of each algorithm is O(m), where m is the number of arcs in the digraph. Storage structures for K-trees are defined, and the updating of a scheduling network is discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288768</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PhilippP80">
<author>Reiner Philipp</author>
<author>Ernst-J&uuml;rgen Prau&szlig;</author>
<title>&Uuml;ber Separatoren in planaren Graphen.</title>
<pages>87-106</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#PhilippP80</url>
<abstract>Hn is planar and has n nodesevery separator in the sense of Lipton, Rose and Tarjan [1] has at least \(\sqrt {\tfrac{7}{6}} \sqrt n\) nodes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289065</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Tokuda81">
<author>Takehiro Tokuda</author>
<title>Eliminating Unit Reductions from <i> LR(k) </i> Parsers Using Minimum Contexts.</title>
<pages>447-470</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Tokuda81</url>
<abstract>This paper presents a new approach to the design and the proof of bypassed LR(k) parsers; a bypassed LR(k) parser is an LR(k) parser which does not perform any reductions caused by insignificant unit productions. We show that bypassed LR(k) parsers having minimum set of reduction contexts always exist for Knuth LR(k) parsers, but do not necessarily exist for SLR(k) and LALR(k) parsers. As byproducts of our approach, we naturally derive Anderson, Eve and Homing's algorithm [5] and a sufficient condition for the existence of bypassed SLR(1) parsers.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264538</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AsveldE79">
<author>Peter R. J. Asveld</author>
<author>Joost Engelfriet</author>
<title>Extended Linear Macro Grammars, Iteration Grammars, and Register Programs.</title>
<pages>259-285</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#AsveldE79</url>
<abstract>Extended macro grammars (of the linear basic type only) are introduced as a generalization of those in [5], and it is shown that they have the same language generating power as (parallel) iteration grammars. In particular the IO and OI versions of extended macro grammars correspond to the deterministic and the (usual) nondeterministic iteration grammars respectively. Hence iterated substitution can be formulated using extended macro grammars.A nondeterministic register program without tests may be viewed as a macro grammar. IO-extension of this macro grammar corresponds to the use of nonrecursive function procedures in the register program. OI-extended macro grammars correspond to register programs which compute on sets. Hence these features of register programs can be investigated by means of (extended) parallel rewriting systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289071</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RozenbergW80">
<author>Grzegorz Rozenberg</author>
<author>Derick Wood</author>
<title>Context-Free Grammars With Selective Rewriting.</title>
<pages>257-268</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#RozenbergW80</url>
<abstract>Selective substitution grammars first introduced by Rozenberg are further investigated. In particular we study ‘context-free grammars’ with selection, since the original model is too general in its generative power. It is shown how the families of context-free, EOL and ETOL languages can be characterized by selective context-free grammars. Further the effect of linguistic restrictions on the family of selection languages is investigated. Finally, the notion of a universal grammar is investigated in this framework, demonstrating the existence of selection universal grammars under weak conditions on the selection family.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288645</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Book78">
<author>Ronald V. Book</author>
<title>On the Complexity of Formal Grammars.</title>
<pages>171-181</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Book78</url>
<abstract>The time and space complexity of the class of languages generated in linear time by context-sensitive grammars is investigated. Among other results it is shown that the membership question for languages in the class is NP-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289076</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RusP97">
<author>Teodor Rus</author>
<author>Sriram V. Pemmaraju</author>
<title>Using Graph Coloring in an Algebraic Compiler.</title>
<pages>191-209</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta34.html#RusP97</url>
<abstract>An algebraic compiler allows incremental development of the source program and builds its target image by composing the target images of the program components. In this paper we describe the general structure of an algebraic compiler focusing on compositional code generation. We show that the mathematical model for register management by an algebraic compiler is a graph coloring problem in which an optimally colored graph is obtained by composing optimally colored subgraphs. More precisely, we define the clique-composition of graphs \(G_1\) and \(G_2\) as the graph obtained by joining all the vertices in a clique in \(G_1\) with all the vertices in a clique in \(G_2\) and show that optimal register management by an algebraic compiler is achieved by performing clique-composition operations. Thus, an algebraic compiler provides automatically adequate clique separation of the global register management graph. We present a linear-time algorithm that takes as input optimally colored graphs \(G_1\) and \(G_2\) and constructs an optimal coloring of any clique-composition of \(G_1\) and \(G_2\). Motivated by the operation of clique-composition, we define the class of clique-composable graphs as those graphs that can be iteratively built from single vertices using the clique-composition operation. We show that the class of clique-composable graphs coincides with the well-known class of chordal graphs.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050079</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Buckle93">
<author>John Buckle</author>
<title>A Characterisation of Meet and Join Respecting Pre-Orders and Congruences on Finite Lattices.</title>
<pages>773-785</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta30.html#Buckle93</url>
<abstract>A connection between pre-orders that respect the operations of the lattice and sets of join-irreducibles closed under a relation ≈ between joinirreducibles is demonstrated. It is shown that any lattice pre-order determines two sets of join-irreducibles closed under the relation ≈ and that elements of the lattice are related by the pre-order if and only if the subsets of joinirreducibles which they are greater than are comparable. The above connection is extended to congruences and the set of join-irreducibles that determine congruences that produce distributive quotient lattices are characterised. Finally it is shown that the quotient lattice of an arbitrary congruence is isomorphic to the lattice of decreasing subsets of join-irreducibles that determine the congruence.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191811</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Majster77"> 
<author>Mila E. Majster-Cederbaum</author>
<title>Extended Directed Graphs, a Formalism for Structured Data and Data Structures.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>37-59</pages>
<url>db/journals/acta/acta8.html#Majster77</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276183</ee>
</article>

<article mdate="2007-02-07" key="journals/acta/AsarinDG07">
<author>Eugene Asarin</author>
<author>Thao Dang</author>
<author>Antoine Girard</author>
<title>Hybridization methods for the analysis of nonlinear systems.</title>
<pages>451-476</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>In this article, we describe some recent results on the hybridization methods for the analysis of nonlinear systems. The main idea of our hybridization approach is to apply the hybrid systems methodology as a systematic approximation method. More concretely, we partition the state space of a complex system into regions that only intersect on their boundaries, and then approximate its dynamics in each region by a simpler one. Then, the resulting hybrid system, which we call a hybridization, is used to yield approximate analysis results for the original system. We also prove important properties of the hybridization, and propose two effective hybridization construction methods, which allow approximating the original nonlinear system with a good convergence rate.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0035-7</ee>
<url>db/journals/acta/acta43.html#AsarinDG07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtR90">
<author>Andrzej Ehrenfeucht</author>
<author>Grzegorz Rozenberg</author>
<title>A Characterization of Set Representable Labeled Partial 2-Structures Through Decompositions.</title>
<pages>83-94</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta28.html#EhrenfeuchtR90</url>
<abstract>The notion of the product of (initialized) labeled partial 2-structures is introduced, and then set representable (initialized) labeled partial 2-structures are characterized in terms of products of binary switches which are “very simple” (initialized) labeled partial 2-structures.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02983375</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChanH88">
<author>Edward P. F. Chan</author>
<author>H&eacute;ctor J. Hern&aacute;ndez</author>
<title>On Generating Database Schemes Bounded or Constant-time-maintainable by Extensibility.</title>
<pages>475-496</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta25.html#ChanH88</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00279950</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/LiuV02">
<author>Jixue Liu</author>
<author>Millist W. Vincent</author>
<title>Containment and disjointedness in partitioned normal form relations.</title>
<pages>325-342</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038005/20380325.htm</ee>
<url>db/journals/acta/acta38.html#LiuV02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/McKellarW72"> 
<author>A. C. McKellar</author>
<author>C. K. Wong</author>
<title>Bounds on Algorithms for String Generation.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>311-319</pages>
<url>db/journals/acta/acta1.html#McKellarW72</url>
<abstract>The well-known lower bound of log2 n! on the number of comparisons required to sort n items is extended to cover algorithms, such as replacement selection, which produce a sorted string whose length is a random variable. The case of algorithms which produce several strings is also discussed and these results are then applied to obtain an upper bound on the length of strings produced by a class of string generation algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289511</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Esparza97">
<author>Javier Esparza</author>
<title>Decidability of Model Checking for Infinite-State Concurrent Systems.</title>
<pages>85-107</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta34.html#Esparza97</url>
<abstract>We study the decidability of the model checking problem for linear and branching time logics, and two models of concurrent computation, namely Petri nets and Basic Parallel Processes.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050074</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Duggan02">
<author>Dominic Duggan</author>
<title>Object type constructors.</title>
<pages>367-408</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038006/20380367.htm</ee>
<url>db/journals/acta/acta38.html#Duggan02</url>
</article>
<article mdate="2014-10-13" key="journals/acta/CazzolaV14">
<author>Walter Cazzola</author>
<author>Edoardo Vacchi</author>
<title>On the incremental growth and shrinkage of LR goto-graphs.</title>
<pages>419-447</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>The LR(0) goto-graph is the basis for the construction of parsers for several interesting grammar classes such as LALR and GLR. Early work has shown that even when a grammar is an extension to another, the goto-graph of the first is not necessarily a subgraph of the second. Some authors presented algorithms to grow and shrink these graphs incrementally, but the formal proof of the existence of a particular relation between a given goto-graph and a grown or shrunk counterpart seems to be still missing in literature as of today. In this paper we use the recursive projection of paths of limited length to prove the existence of one such relation, when the sets of productions are in a subset relation. We also use this relation to present two algorithms (Grow and Shrink) that transform the goto-graph of a given grammar into the goto-graph of an extension or a restriction to that grammar. We implemented these algorithms in a dynamically updatable LALR parser generator called DEXTER (the Dynamically EXTEnsible Recognizer) that we are now shipping with our current implementation of the Neverlang framework for programming language development.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0201-2</ee>
<url>db/journals/acta/acta51.html#CazzolaV14</url>
</article>
<article mdate="2011-02-16" key="journals/acta/Blanchet-SadriMSW11">
<author>Francine Blanchet-Sadri</author>
<author>Robert Mercas</author>
<author>Sean Simmons</author>
<author>Eric Weissenstein</author>
<title>Avoidable binary patterns in partial words.</title>
<pages>25-41</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The problem of classifying all the avoidable binary patterns in (full) words has been completely solved (see Chap. 3 of M. Lothaire, Algebraic Combinatorics on Words, Cambridge University Press, 2002). In this paper, we classify all the avoidable binary patterns in partial words, or sequences that may have some undefined positions called holes. In particular we show that, if we do not substitute any variable of the pattern by a partial word consisting of only one hole, the avoidability index of the pattern remains the same as in the full word case.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0129-0</ee>
<url>db/journals/acta/acta48.html#Blanchet-SadriMSW11</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Honkala00">
<author>Juha Honkala</author>
<title>On Slender 0L Languages over the Binary Alphabet.</title>
<pages>805-815</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360805.htm</ee>
<url>db/journals/acta/acta36.html#Honkala00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AmeurFHH96">
<author>Foued Ameur</author>
<author>Paul Fischer</author>
<author>Klaus-Uwe H&ouml;ffgen</author>
<author>Friedhelm Meyer auf der Heide</author>
<title>Trial and Error. A New Approach to Space-Bounded Learning.</title>
<pages>621-630</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#AmeurFHH96</url>
<abstract>A pac-learning algorithm isd-space bounded, if it stores at mostd examples from the sample at any time. We characterize thed-space learnable concept classes. For this purpose we introduce the compression parameter of a concept classb and design our Trial and Error Learning Algorithm. We show:b isd-space learnable if and only if the compression parameter ofb is at mostd. This learning algorithm does not produce a hypothesis consistent with the whole sample as previous approaches e.g. by Floyd, who presents consistent space bounded learning algorithms, but has to restrict herself to very special concept classes. On the other hand our algorithm needs large samples; the compression parameter appears as exponent in the sample size.- all intersection closed concept classes with finite VC-dimension.- convexn-gons in ℝ2.- halfspaces in ℝn.- unions of triangles in ℝ2.We further relate the compression parameter to the VC-dimension, and discuss variants of this parameter.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036467</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Cassaigne93">
<author>Julien Cassaigne</author>
<title>Unavoidable Binary Patterns.</title>
<pages>385-395</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta30.html#Cassaigne93</url>
<abstract>Peter Roth proved that there are no binary patterns of length six or more that are unavoidable on the two-letter alphabet. He gave an almost complete description of unavoidable binary patterns. In this paper we prove one of his conjectures: the pattern α2 β2 α is 2-avoidable. From this we deduce the complete classification of unavoidable binary patterns. We also study the concept of avoidability by iterated morphisms and prove that there are a few 2-avoidable patterns which are not avoided by any iterated morphism.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209712</ee>
</article>
<article mdate="2014-02-14" key="journals/acta/BozzelliS14">
<author>Laura Bozzelli</author>
<author>C&eacute;sar S&aacute;nchez</author>
<title>Visibly rational expressions.</title>
<pages>25-49</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>Regular expressions (RE) are an algebraic formalism for expressing regular languages, widely used in string search and as a specification language in verification. In this paper, we introduce and investigate visibly rational expressions (VRE), an extension of RE for the class of visibly pushdown languages (VPL). We show that VRE capture precisely the class of VPL. Moreover, we identify an equally expressive fragment of VRE which admits a quadratic time compositional translation into the automata acceptors of VPL. We also prove that, for this fragment, universality, inclusion and language equivalence are EXPTIME-complete. Finally, we provide an extension of VRE for VPL over infinite words.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0190-6</ee>
<url>db/journals/acta/acta51.html#BozzelliS14</url>
</article>
<article mdate="2004-03-03" key="journals/acta/Walther04">
<author>Andrea Walther</author>
<title>Program reversals for evolutions with non-uniform step costs.</title>
<pages>235-263</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>The reversal of a program execution can be helpful for several purposes. The reverse mode of automatic differentiation, parameter estimation, and debugging represent some of the tasks that may require the intermediate values of a calculation in reverse order. The recording of a complete execution log forms the simplest approach to providing the data required for the reversal. However, this “store-everything” method causes an enormous demand for memory. The generation of the execution log piece by piece offers the possibility to reduce the storage requirement. To that end the forward calculation is restarted from suitably placed checkpoints leading to a more or less complicated reversal schedule.This paper deals with the reversal of evaluation procedures that consist of a sequence of time steps with varying computational complexity. We present a new search algorithm for determining a reversal schedule that minimizes the runtime of the reversal process for a given number of checkpoints. By exploiting a certain monotonicity property, the search algorithm based on dynamic programming can be made to grow only quadratically with the number of time steps to be reverted. We report the runtime savings that can be achieved performing the reversal with an optimal, i.e. time-minimal, reversal schedule for a test problem based on Burgers’ equation.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0131-x</ee>
<url>db/journals/acta/acta40.html#Walther04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RaihaS82">
<author>Kari-Jouko R&auml;ih&auml;</author>
<author>Mikko Saarinen</author>
<title>Testing Attribute Grammars for Circularity.</title>
<pages>185-192</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#RaihaS82</url>
<abstract>The problem of deciding whether a given attribute grammar is noncircular is known to require exponential time for infinitely many grammars. Here the time requirement of a simple circularity test is analyzed. It is shown that the reason for the exponential time requirement is the number of graphs in a collection formed for every nonterminal. By practical experiments it is argued that for real grammars the number is very small. Therefore it is feasible to actually perform the circularity test in practice. Different techniques to improve the implementation of the circularity test are discussed, too.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288969</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ONeilCGO96">
<author>Patrick E. O'Neil</author>
<author>Edward Cheng</author>
<author>Dieter Gawlick</author>
<author>Elizabeth J. O'Neil</author>
<title>The Log-Structured Merge-Tree (LSM-Tree).</title>
<pages>351-385</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta33.html#ONeilCGO96</url>
<abstract>High-performance transaction system applications typically insert rows in a History table to provide an activity trace; at the same time the transaction system generates log records for purposes of system recovery. Both types of generated information can benefit from efficient indexing. An example in a well-known setting is the TPC-A benchmark application, modified to support efficient queries on the history for account activity for specific accounts. This requires an index by account-id on the fast-growing History table. Unfortunately, standard disk-based index structures such as the B-tree will effectively double the I/O cost of the transaction to maintain an index such as this in real time, increasing the total system cost up to fifty percent. Clearly a method for maintaining a real-time index at low cost is desirable. The log-structured mergetree (LSM-tree) is a disk-based data structure designed to provide low-cost indexing for a file experiencing a high rate of record inserts (and deletes) over an extended period. The LSM-tree uses an algorithm that defers and batches index changes, cascading the changes from a memory-based component through one or more disk components in an efficient manner reminiscent of merge sort. During this process all index values are continuously accessible to retrievals (aside from very short locking periods), either through the memory component or one of the disk components. The algorithm has greatly reduced disk arm movements compared to a traditional access methods such as B-trees, and will improve cost-performance in domains where disk arm costs for inserts with traditional access methods overwhelm storage media costs. The LSM-tree approach also generalizes to operations other than insert and delete. However, indexed finds requiring immediate response will lose I/O efficiency in some cases, so the LSM-tree is most useful in applications where index inserts are more common than finds that retrieve the entries. This seems to be a common property for history tables and log files, for example. The conclusions of Sect. 6 compare the hybrid use of memory and disk components in the LSM-tree access method with the commonly understood advantage of the hybrid method to buffer disk pages in memory.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050048</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Szwarcfiter84">
<author>Jayme Luiz Szwarcfiter</author>
<title>Optimal Multiway Search Trees for Variable Size Keys.</title>
<pages>47-60</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Szwarcfiter84</url>
<abstract>This paper considers the construction of optimal search trees for a sequence of n keys of varying sizes, under various cost measures. Constructing optimal search cost multiway trees is NP-hard, although it can be done in pseudo-polynomial time O 3 and space O 2, where L is the page size limit. An optimal space multiway search tree is obtained in O 3 time and O 2 space, while an optimal height tree in O(n 2 log2 n) time and O(n) space both having additionally minimal root sizes. The monotonicity principle does not hold for the above cases. Finding optimal search cost weak B-trees is NP-hard, but a weak B-tree of height 2 and minimal root size can be constructed in O(n log n) time. In addition, if its root is restricted to contain M keys then a different algorithm is applied, having time complexity O(nM log n). The latter solves a problem posed by McCreight.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289139</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HalbwachsLR92">
<author>Nicolas Halbwachs</author>
<author>Fabienne Lagnier</author>
<author>Christophe Ratel</author>
<title>An Experience in Proving Regular Networks of Processes by Modular Model Checking.</title>
<pages>523-543</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#HalbwachsLR92</url>
<abstract>This paper presents a complete example of the use of the synchronous declarative language LUSTRE for the specification, description and verification of a resource arbiter, which is a regular network of hardware devices. The fact that both programs and properties may be expressed in LUSTRE is used to perform an inductive verification. An invariant property of the network is found, and merged with the description program. Verification is performed by model checking.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185559</ee>
</article>
<article mdate="2009-09-28" key="journals/acta/BresolinMP09">
<author>Davide Bresolin</author>
<author>Angelo Montanari</author>
<author>Gabriele Puppis</author>
<title>A theory of ultimately periodic languages and automata with an application to time granularity.</title>
<pages>331-360</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>In this paper, we develop a theory of regular ω-languages that consist of ultimately periodic words only and we provide it with an automaton-based characterization. The resulting class of automata, called ultimately periodic automata (UPA), is a subclass of the class of Büchi automata and inherits some properties of automata over finite words (NFA). Taking advantage of the similarities among UPA, Büchi automata, and NFA, we devise efficient solutions to a number of basic problems for UPA, such as the inclusion, the equivalence, and the size optimization problems. The original motivation for developing a theory of ultimately periodic languages and automata was to represent and to reason about sets of time granularities in knowledge-based and database systems. In the last part of the paper, we show that UPA actually allow one to represent (possibly infinite) sets of granularities, instead of single ones, in a compact and suitable to algorithmic manipulation way. In particular, we describe an application of UPA to a concrete time granularity scenario taken from clinical medicine.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0094-7</ee>
<url>db/journals/acta/acta46.html#BresolinMP09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MeghiniT85">
<author>Carlo Meghini</author>
<author>Costantino Thanos</author>
<title>Querying Fragmented Relations in a Distributed Database.</title>
<pages>125-138</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#MeghiniT85</url>
<abstract>The paper discusses the query optimization problem in a distributed database system supporting a complex fragmentation schema, in which different fragments can share the same set of data. The fragmentation and the distribution of data are assumed to be transparent to the user, who queries the database in terms of the global relations. The optimization of queries stated on a single fragmented relation is considered, and a method for its solution is presented. The method is based on an algorithm which calculates a set of virtual fragments that can alternatively be used to answer the query.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264226</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ChakkaH01">
<author>Ram Chakka</author>
<author>Peter G. Harrison</author>
<title>A Markov modulated multi-server queue with negative customers - The MM CPP/GE/c/L G-queue.</title>
<pages>881-919</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>11-12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037011/10370881.htm</ee>
<url>db/journals/acta/acta37.html#ChakkaH01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EngelfrietF81">
<author>Joost Engelfriet</author>
<author>Gilberto Fil&eacute;</author>
<title>The Formal Power of One-Visit Attribute Grammars.</title>
<pages>275-302</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#EngelfrietF81</url>
<abstract>An attribute grammar is one-visit if the attributes can be evaluated by walking through the derivation tree in such a way that each subtree is visited at most once. One-visit (1V) attribute grammars are compared with one-pass left-to-right (L) attribute grammars and with attribute grammars having only one synthesized attribute (1S).Every 1S attribute grammar can be made one-visit. One-visit attribute grammars are simply permutations of L attribute grammars; thus the classes of output sets of 1V and L attribute grammars coincide, and similarly for 1S and L-1S attribute grammars. In case all attribute values are trees, the translation realized by a 1V attribute grammar is the composition of the translation realized by a 1S attribute grammar with a deterministic top-down tree transduction, and vice versa; thus, using a result of Duske e.a., the class of output languages of 1V (or L) attribute grammars is the image of the class of IO macro tree languages under all deterministic top-down tree transductions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289307</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RichardsS92">
<author>Dana S. Richards</author>
<author>Jeffrey S. Salowe</author>
<title>Stacks, Queues, and Deques with Order-Statistic Operations.</title>
<pages>395-414</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#RichardsS92</url>
<abstract>Anorder-statistic deque is a deque that also supports the operationfind(k, D), wherefind(k, D) returns the item inD with rankk. Assumingk is fixed, we show how to implement an order-statistic deque so thatinject(x, D), eject(D), push(x, D), andpop(D) take O(logk) amortized time andfind(k, D) takes worst-case constant time; the time bounds can be made worst case using a technique of Gajewska and Tarjan. We also show our implementations are optimal in the algebraic decision tree model of computation. This deque is applied to three problems: computing order-statistic filters, finding a smallest area convex quadrilateral in the plane, and computing “batched” order statistics.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193574</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BozapalidisR94">
<author>Symeon Bozapalidis</author>
<author>George Rahonis</author>
<title>On two Families of Forests.</title>
<pages>235-260</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta31.html#BozapalidisR94</url>
<abstract>An alphabetic cone is a family of forests stable under alphabetic tree transductions, whereas we call REC-closed each family of forests closed under the operations of union, top-catenation,a-product anda-star; the sheaves are families having both the above properties.For a given sheaf of forests ℱ, both the families of languages (ℱ) and yield (ℱ) (of branches and yields of ℱ respectively) constitute full AFL's.Further we show that the familyK-REC of forests supporting recognizable formal power series on trees is a sheaf and so is the family OCF of behaviors of one counter treeautomata.On the contrary, restricted one counter forests (ROCF) constitute an alphabetic cone which fails to be a sheaf; ROCF N (restricted one counter forests over alphabets with degree ≦N) is alphabetically principal generated by the Lukasiewicz forest of rankN.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01218405</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GelenbeM76"> 
<author>Erol Gelenbe</author>
<author>Richard R. Muntz</author>
<title>Probabilistic Models of Computer Systems - Part I (Exact Results).</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>35-60</pages>
<url>db/journals/acta/acta7.html#GelenbeM76</url>
<abstract>This paper is a survey of certain known results concerning networks of queues. The choice of the topics presented has been made with special emphasis on mathematical results which can be applied to the analysis and synthesis of mathematical or simulation models of complex computer systems in which an ensemble of resources is shared among a set of user programs. The subjects covered include the Jackson, and Gordon and Newell theorems; the work-rate theorems of Chang, Lavenberg and Traiger; the Baskett, Chandy, Muntz, Palacios results. We also discuss in a unified manner problems related to Poisson processes in queueing networks. Companion papers (Parts II, III) will present results concerning approximations to queueing networks and some of their applications to computer system performance evaluation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265220</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Ruhl94">
<author>Astrid R. R&uuml;hl</author>
<title>On Bounds of Response Time Performance Achievable by Multiclass Single-Server Queues.</title>
<pages>629-650</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta31.html#Ruhl94</url>
<abstract>MulticlassM/G/1 systems in steady-state with work-conserving scheduling strategies are studied. Restricting a system's scheduling strategy to making no direct use of the required service times, every time the server becomes idle its memory is cleared, and service may only be interrupted by newly arriving customers, a conservation law is developed by means of inequalities. The conservation law states that if a response time vector composed of the expected response times of the different classes of a system in steady-state is achievable, then it must belong to a well-defined convex polytope (a set bounded by hyperplanes). Furthermore, on each hyperplane bounding the relevant polytope there lies at least one vertex of the convex set of achievable response time vectors. Therefore, this polytope is the least one including the set of all achievable response time vectors.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177549</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nishimura79">
<author>Hirokazu Nishimura</author>
<title>Sequential Method in Propositional Dynamic Logic.</title>
<pages>377-400</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Nishimura79</url>
<abstract>Recently prepositional modal logic of programs, called ‘prepositional dynamic logic’, has been developed by many authors, following the ideas of Fisher and Ladner [1] and Pratt [12]. The main purpose of this paper is to present a Gentzen-type sequential formulation of this logic and to establish its semantical completeness with due regard to sequential formulation as such. In a sense our sequential formulation might be regarded as a powerful tool to establish the completeness theorem of already familiar axiomatizations of prepositional dynamic logic such as seen in Harel [4], Parikh [11] or Segerberg [15]. Indeed our method is powerful enough in completeness proof to yield a desired structure directly without making a detour through such intermediate constructs as a ‘pseudomodel’ or a ‘nonstandard structure’, which can be seen in Parikh [11]. We also show that our sequential system of prepositional dynamic logic does not enjoy the so-called cut-elimination theorem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268322</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Yellin93">
<author>Daniel M. Yellin</author>
<title>Speeding up Dynamic Transitive Closure for Bounded Degree Graphs.</title>
<pages>369-384</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta30.html#Yellin93</url>
<abstract>In this paper we present an algorithm for solving two problems in dynamically maintaining the transitive closure of a digraph: In the first problem a sequence of edge insertions is performed on an initially empty graph, interspersed withp transitive closure queries of the form: “is there a path froma tob in the graph”. Our algorithm solves this problem in timeO (dm *+p), whered is the maximum outdegree of the resulting graphG andm * is the number of edges in the transitive closure ofG. In the second problem, a sequence of edge deletions is performed on anacyclic graph, interspersed withp transitive closure queries. Once again we solve this problem in timeO (dm *+p), whered is the maximum outdegree of the initial graphG andm * is the number of edges in the transitive closure ofG. For bounded degree graphs, this improves upon previous results. Our algorithms also work when insertions and deletions to the graph are intermixed. Finally, we show how to implement the operation findpath (x, y) which retrieves some path fromx toy in time proportional to the length of the path.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209711</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CoffmanFK93">
<author>Edward G. Coffman Jr.</author>
<author>Leopold Flatto</author>
<author>Alexander Y. Kreinin</author>
<title>Scheduling Saves in Fault-Tolerant Computations.</title>
<pages>409-423</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#CoffmanFK93</url>
<abstract>Computer users with very long computations run the risk of losing work because of machine failures. Such losses can often be reduced by scheduling saves on secure storage devices of work successfully done. In the model studied here, the user leaves the computation unattended for extended periods of time, after which he or she returns to check whether a machine failure occurs. When a check reveals a failure, the user resets the computation so that it resumes from the point of the last successful save.Saves are themselves time consuming, so that any strategy for scheduling saves must strike a balance between the computing time lost during saves and the computing time that is occasionally lost, because of a failure since the last successful save.For a given time to the next check and given constant save times, this paper computes schedules that maximize the expected amount of work successfully done before the next check, under the uniform and exponential failure laws. Explicit formulas are obtained for the uniform law. A recurrence leads to routine numerical calculations for the more difficult system with an exponential failure law.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210593</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AnderaaB81">
<author>Stal O. Anderaa</author>
<author>Egon B&ouml;rger</author>
<title>The Equivalence of Horn and Network Complexity for Boolean Functions.</title>
<pages>303-307</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#AnderaaB81</url>
<abstract>We propose in this paper a logical complexity measure — Horn complexity — for Boolean functions which measures the minimal length of quasi-Horn definitions of such functions by propositional formulae. The interest for this complexity measure comes on the one hand from the observation that the satisfiability problem for Horn formulae is in P, on the other hand from a strong connection to Cook's problem. We show the proposed Horn complexity to be polynomially equivalent to network complexity and therefore to Turing complexity for Boolean functions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289267</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/DangM15">
<author>Han-Hing Dang</author>
<author>Bernhard M&ouml;ller</author>
<title>Modal algebra and Petri nets.</title>
<pages>109-132</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>We use the by now well established setting of modal semirings to derive a modal algebra for Petri nets. It is based on a relation-algebraic calculus for separation logic that enables calculations of properties in a pointfree fashion and at an abstract level. Basically, we start from an earlier logical approach to Petri nets that in particular uses modal box and diamond operators for stating properties about the state space of such a net. We provide relational translations of the logical formulas which further allow the characterisation of general behaviour of transitions in an algebraic fashion. From the relational structure an algebra for frequently used properties of Petri nets is derived. In particular, we give connections to typical used assertion classes of separation logic. Moreover, we demonstrate applicability of the algebraic approach by calculations concerning a standard example of a mutex net.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0216-3</ee>
<url>db/journals/acta/acta52.html#DangM15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Vincent99">
<author>Millist W. Vincent</author>
<title>Semantic Foundations of 4NF in Relational Database Design.</title>
<pages>173-213</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036003/90360173.htm</ee>
<url>db/journals/acta/acta36.html#Vincent99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikR95"> 
<author>Karel Culik II</author>
<author>Peter Rajc&aacute;ni</author>
<title>Iterative Weighted Finite Transductions.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>7</number>
<year>1995</year> 
<pages>681-703</pages>
<url>db/journals/acta/acta32.html#CulikR95</url>
<abstract>We investigate 2-tape weighted finite automata called weighted finite transducers (WFT) and their applications to image processing. We show that probabilistic mutually recursive function systems (PMRFS) can be simulated by iterative weighted fimite transductions. We conjecture that iterative WFT are stronger than PMRFS and give examples of WFT that support this conjecture. We also show that the family of images defined by iterative WFT is closed under continuous invertible WFT relations which include invertible affine transformations as a special case. We give examples of iterative WFT which can compute mathematical functions given by a Taylor series with “regular” coefficients which cannot be computed by WFA. We discuss the implementation of an efficient image manipulation system which includes the implementation of efficient algorithms for the application of a WFT to an image in either pixel or WFA representation and for composition of WFT. The system also includes the Culik-Kari recursive WFA inference algorithm as a conversion from pixel representation to WFA representation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01186646</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/EngelfrietH92">
<author>Joost Engelfriet</author>
<author>Linda Heyker</author>
<title>Context-Free Hypergraph Grammars have the Same Term-Generating Power as Attribute Grammars.</title>
<pages>161-210</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta29.html#EngelfrietH92</url>
<abstract>Context-free hypergraph grammars and attribute grammars generate the same class of term languages. Extending the context-free hypergraph grammar with a context-free grammar and a semantic domain, a syntax-directed translation device is obtained that is equivalent to the attribute grammar.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178504</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Doberkat03">
<author>Ernst-Erich Doberkat</author>
<title>Pipelines: Modelling a software architecture through relations.</title>
<pages>37-79</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>A pipeline is a popular architecture which connects computational components (filters) through connectors (pipes) so that computations are performed in a stream like fashion. The data are transported through the pipes between filters, gradually transforming inputs to outputs. This kind of stream processing has been made popular through UNIX pipes that serially connect independent components for performing a sequence of tasks. We show in this paper how to formalize this architecture in terms of monads, hereby including relational specifications as special cases. The system is given through a directed acyclic graph the nodes of which carry the computational structure by being labelled with morphisms from the monad, and the edges provide the data for these operations. It is shown how fundamental compositional operations like combining pipes and filters, and refining a system by replacing simple parts through more elaborate ones, are supported through this construction.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0121-z</ee>
<url>db/journals/acta/acta40.html#Doberkat03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KratochvilK93">
<author>Jan Kratochv&iacute;l</author>
<author>Mirko Kriv&aacute;nek</author>
<title>Satisfiability of Co-Nested Formulas.</title>
<pages>397-403</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta30.html#KratochvilK93</url>
<abstract>As a notion dual to Knuth's nested formulas [4], we call a boolean formula\(\Phi = \mathop \wedge \limits_{i = 1}^n c_i \) in conjunctive normal formco-nested if its clauses can be linearly ordered (sayC={c i ;i=1,2, ...,n})so that the graphG Φ cl =(X∪C, {xc i ;x∈c i or ¬x∈c i } ∪ {c i c i+1;i=1, 2, ...,n}) allows a noncrossing drawing in the plane so that the circlec 1,c 2, ...,c n bounds the outerface. Our main result is that maximum satisfiability of co-nested formulas can be decided in linear time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209713</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RozenbergW86">
<author>Grzegorz Rozenberg</author>
<author>Emo Welzl</author>
<title>Graph Theoretic Closure Properties of the Family of Boundary NLC Graph Languages.</title>
<pages>289-309</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#RozenbergW86</url>
<abstract>Node label controlled (NLC) grammars are graph grammars (operating on node labeled undirected graphs) which rewrite single nodes only and establish connections between the embedded graph and the neighbors of the rewritten node on the basis of the labels of the involved nodes only. They define (possibly infinite) languages of undirected node labeled graphs (or, if we just omit the labels, languages of unlabeled graphs). Boundary NLC (BNLC) grammars are NLC grammars with the property that whenever — in a graph already generated — two nodes may be rewritten, then these nodes are not adjacent. The graph languages generated by this type of grammars are called BNLC languages.The present paper continues the investigations of basic properties of BNLC grammars and languages where the central question is the following: “If L is a BNLC language and P is a graph theoretic property, is the set of all graphs from L satisfying P again a BNLC language?” We demonstrate that the class of BNLC languages is very “stable” in the sense that for almost all properties we consider the resulting languages are BNLC. In particular, the above question gets an affirmative answer, if the property P is: being k-colorable, being connected, having a subgraph homeomorphic to a given graph, and being nonplanar.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289115</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/GlabbeekH15">
<author>Rob J. van Glabbeek</author>
<author>Peter H&ouml;fner</author>
<title>CCS: It's not fair! - Fair schedulers cannot be implemented in CCS-like languages even under progress and certain fairness assumptions.</title>
<pages>175-205</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>In the process algebra community it is sometimes suggested that, on some level of abstraction, any distributed system can be modelled in standard process-algebraic specification formalisms like CCS. This sentiment is strengthened by results testifying that CCS, like many similar formalisms, is Turing powerful and provides a mechanism for interaction. This paper counters that sentiment by presenting a simple fair scheduler—one that in suitable variations occurs in many distributed systems—of which no implementation can be expressed in CCS, unless CCS is enriched with a fairness assumption. Since Dekker’s and Peterson’s mutual exclusion protocols implement fair schedulers, it follows that these protocols cannot be rendered correctly in CCS without imposing a fairness assumption. Peterson expressed this algorithm correctly in pseudocode without resorting to a fairness assumption, so it furthermore follows that CCS lacks the expressive power to accurately capture such pseudocode.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0221-6</ee>
<url>db/journals/acta/acta52.html#GlabbeekH15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Szpankowski87">
<author>Wojciech Szpankowski</author>
<title>An Analysis of a Contention Resolution Algorithm: Another Approach.</title>
<pages>173-190</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#Szpankowski87</url>
<abstract>A single multiaccess channel is studied with the outcome of a transmission being either ‘idle’, ‘success’, or ‘collision’ (ternary channel). Packets involved in a collision must be retransmitted, and an efficient way to solve a collision is known in the literature as Gallager-Tsybakov-Mikhailov algorithm. Performance analysis of the algorithm is quite hard. In fact, it bases on a numerical solution of some recurrence equations and on a numerical evaluation of some series. The obvious drawback of it is lack of insight into the behavior of the algorithm. We shall present a new approach of looking at the algorithm and discuss some attempts of analyzing its performance. In particular, expected lengths of a resolution interval and a conflict resolution interval as well as throughput of the algorithm will be discussed using asymptotic approximation and “a small input rate” approximation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264363</ee>
</article>
<article mdate="2011-05-16" key="journals/acta/MedunaZ11">
<author>Alexander Meduna</author>
<author>Petr Zemek</author>
<title>One-sided random context grammars.</title>
<pages>149-163</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>The notion of a one-sided random context grammar is defined as a context-free-based regulated grammar, in which a set of permitting symbols and a set of forbidding symbols are attached to every rule, and its set of rules is divided into the set of left random context rules and the set of right random context rules. A left random context rule can rewrite a nonterminal if each of its permitting symbols occurs to the left of the rewritten symbol in the current sentential form while each of its forbidding symbols does not occur there. A right random context rule is applied analogically except that the symbols are examined to the right of the rewritten symbol. The paper demonstrates that without erasing rules, one-sided random context grammars characterize the family of context-sensitive languages, and with erasing rules, these grammars characterize the family of recursively enumerable languages. In fact, these characterization results hold even if the set of left random context rules coincides with the set of right random context rules. Several special cases of these grammars are considered, and their generative power is established. In its conclusion, some important open problems are suggested to study in the future.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0134-y</ee>
<url>db/journals/acta/acta48.html#MedunaZ11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/IglehartS81">
<author>Donald L. Iglehart</author>
<author>Gerald S. Shedler</author>
<title>Regenerative Simulation of Response Times in Networks of Queues: Statistical Efficiency.</title>
<pages>347-363</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#IglehartS81</url>
<abstract>This paper deals with the statistical efficiency of estimation methods for “passage times” in closed, multiclass networks of queues with priorities. Informally, a passage time is the time for a job to traverse a portion of the network. Such quantities are important in computer and communication system models, and in this context, quantities other than mean values are of interest. We consider here the efficiencies of the “marked job method” for passage time simulation (based on the tracking of a distinguished job) and the “decomposition method” in which observed passage times for all of the jobs enter in the construction of point and interval estimates. We show that the decomposition method is superior in that, for simulations of equal length, it produces tighter confidence intervals. We also calculate theoretical values for variance constants entering into central limit theorems used to obtain confidence intervals for mean passage times. These results provide a means of quantifying the relative efficiency of the decomposition method.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264534</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BerstelB02">
<author>Jean Berstel</author>
<author>Luc Boasson</author>
<title>Formal properties of XML grammars and languages.</title>
<pages>649-671</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038009/20380649.htm</ee>
<url>db/journals/acta/acta38.html#BerstelB02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Monien77"> 
<author>Burkhard Monien</author>
<title>The LBA-Problem and the Deterministic Tape Complexity of Two-Way One-Counter Languages over a One-Letter Alphabet.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>371-382</pages>
<url>db/journals/acta/acta8.html#Monien77</url>
<abstract>It is shown, that NTAPE(n) is equal to TAPE(n) if and only if every language L⊂⊣{1}*⊢ which is acceptable by a nondeterministic two-way one-counter automaton whose counter length is bounded by the length of its input is contained in TAPE(log n).</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271345</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Warren78">
<author>Henry S. Warren Jr.</author>
<title>Static Main Storage Packing Problems.</title>
<pages>355-376</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Warren78</url>
<abstract>The instruction set of many computers permits referencing certain areas of main storage more efficiently than others. For example, “base-offset” addressing favors small offsets. This report discusses the problem of how to optimally assign data to storage on such a machine, subject to the restriction that the locations chosen are not to change with time. The emphasis is on truly optimal solutions, although many simplifying assumptions are made. Some of the results apply to the problem of optimally placing “read-only” files on auxiliary storage. Areas for further work are suggested.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289048</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Coppo83">
<author>Mario Coppo</author>
<title>On the Semantics of Polymorphism.</title>
<pages>159-170</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Coppo83</url>
<abstract>A semantic characterization is given of the terms of a simple applicative language which it can be assigned a (monomorphic or polymorphic) type. Moreover a strong completeness result is proved for a (nontrivial) subset of terms (corresponding to the normal forms of a lambda-calculus plus constants). Completeness does not hold in general.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289413</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GiannellaG02">
<author>Chris Giannella</author>
<author>Dirk Van Gucht</author>
<title>Adding a path connectedness operator to FO+poly (linear).</title>
<pages>621-648</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038009/20380621.htm</ee>
<url>db/journals/acta/acta38.html#GiannellaG02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AtzeniC91">
<author>Paolo Atzeni</author>
<author>Edward P. F. Chan</author>
<title>Independent Database Schemes under Functional and Inclusion Dependencies.</title>
<pages>777-779</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta28.html#AtzeniC91</url>
<abstract>In a context considering in a unique framework all the relations in a database, by means of the notion of global consistency, independent database schemes allow enforcement of constraints to be performed locally, thus providing independent updatability of the various relations. Independent schemes have hitherto been studied in the presence of functional and join dependencies. In this paper the definition is extended and some characterizations are given for schemes whose sets of constraints contain functional and inclusion dependencies.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01261656</ee>
</article>
<article mdate="2012-09-18" key="journals/acta/VasilePDP12">
<author>Cristian Ioan Vasile</author>
<author>Ana Br&acirc;ndusa Pavel</author>
<author>Ioan Dumitrache</author>
<author>Gheorghe Paun</author>
<title>On the power of enzymatic numerical P systems.</title>
<pages>395-412</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We study the computing power of a class of numerical P systems introduced in the framework of autonomous robot control, namely enzymatic numerical P systems. Three ways of using the evolution programs are investigated: sequential, all-parallel and one-parallel (with the same variable used in all programs or in only one, respectively); moreover, both deterministic and non-deterministic systems are considered. The Turing universality of some of the obtained classes of numerical P systems is proved (for polynomials with the smallest possible degree, one, also introducing a new proof technique in this area, namely starting the universality proof from the characterization of computable sets of numbers by means of register machines). The power of many other classes remains to be investigated.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0166-y</ee>
<url>db/journals/acta/acta49.html#VasilePDP12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Gold95"> 
<author>Robert Gold</author>
<title>A Compositional Dataflow Semantics for Petri Nets.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>7</number>
<year>1995</year> 
<pages>627-645</pages>
<url>db/journals/acta/acta32.html#Gold95</url>
<abstract>We give a semantics for place/transition nets, which describes the input/out-put behaviour using fixed point techniques. The semantics is shown to be compositional w.r.t. the net operators parallel composition, feedback and output merging. We prove consistency with the step sequence semantics and thus give an equivalent operational semantics.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01186644</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Rabinovitch98">
<author>Alexander Moshe Rabinovich</author>
<title>Modularity and Expressibility for Nets of Relations.</title>
<pages>293-327</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta35.html#Rabinovitch98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035004/80350293.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TuzhilinK96">
<author>Alexander Tuzhilin</author>
<author>Zvi M. Kedem</author>
<title>Modeling Data-Intensive Reactive Systems with Relational Transition Systems.</title>
<pages>203-231</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta33.html#TuzhilinK96</url>
<abstract>In this paper, the formalism of Relational Transition Systems (RTSes) is used to model data-intensive reactive systems, and four RTS models of reactive systems based on temporal logic programming, production systems, recurrence equations, and Petri nets are presented. The paper also describes different methods of comparison of the expressive powers of various RTSes in terms of the trajectories they can generate and carries out this comparison for the four RTS formalisms. It is shown that these formalisms have the same expressive power in the deterministic case. The paper also compares expressive powers of non-deterministic production systems and non-deterministic temporal logic programming systems. It is shown that, although the two formalisms are incomparable in the general case, their restricted versions are isomorphic to each other.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050041</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/EpsteinLS08">
<author>Leah Epstein</author>
<author>Asaf Levin</author>
<author>Rob van Stee</author>
<title>Two-dimensional packing with conflicts.</title>
<pages>155-175</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>We study the two-dimensional version of the bin packing problem with conflicts. We are given a set of (two-dimensional) squares V = {1, 2, . . . ,n} with sides \({s_1, s_2 \ldots ,s_n \in [0,1]}\) and a conflict graph G = (V, E). We seek to find a partition of the items into independent sets of G, where each independent set can be packed into a unit square bin, such that no two squares packed together in one bin overlap. The goal is to minimize the number of independent sets in the partition. This problem generalizes the square packing problem (in which we have \({E = \emptyset}\)) and the graph coloring problem (in which s i  = 0 for all i = 1,2, . . . , sn). It is well known that coloring problems on general graphs are hard to approximate. Following previous work on the one-dimensional problem, we study the problem on specific graph classes, namely, bipartite graphs and perfect graphs. We design a \({2+\varepsilon}\) -approximation for bipartite graphs, which is almost best possible (unless P = NP). For perfect graphs, we design a 3.2744-approximation.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0067-7</ee>
<url>db/journals/acta/acta45.html#EpsteinLS08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LuckhamS77"> 
<author>David C. Luckham</author>
<author>Norihisa Suzuki</author>
<title>Proof of Termination within a Weak Logic of Programs.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>21-36</pages>
<url>db/journals/acta/acta8.html#LuckhamS77</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276182</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Harris87">
<author>Lawrence A. Harris</author>
<title>SLR(1) and LALR(1) Parsing for Unrestricted Grammars.</title>
<pages>191-209</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#Harris87</url>
<abstract>Simple LR(1) and lookahead LR(1) phrase structure grammars are defined and corresponding deterministic two-pushdown automata which parse all sentences are given. These grammars include a wide variety of grammars for non context-free languages. A given phrase structure grammar is one of these types if the parse table for the associated automaton has no multiple entries. A technique for construction of this parse table is given which in the lookahead case involves elimination of inverses in a grammar for lookahead strings for LR(0) items and computation of first sets for strings of symbols in the given grammar.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264364</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/JanssenKB07">
<author>Wim Janssen</author>
<author>Alexandr Korlyukov</author>
<author>Jan Van den Bussche</author>
<title>On the tree-transformation power of XSLT.</title>
<pages>371-393</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>XSLT is a standard rule-based programming language for expressing transformations of XML data. The language is currently in transition from version 1.0 to 2.0. In order to understand the computational consequences of this transition, we restrict XSLT to its pure tree-transformation capabilities. Under this focus, we observe that XSLT 1.0 was not yet a computationally complete tree-transformation language: every 1.0 program can be implemented in exponential time, using a DAG representation of trees. A crucial new feature of version 2.0, however, which allows node sets over temporary trees, yields completeness. We provide a formal operational semantics for XSLT programs, and establish confluence for this semantics.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0026-8</ee>
<url>db/journals/acta/acta43.html#JanssenKB07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Schassberger81">
<author>Rolf Schassberger</author>
<title>On the Response Time Distribution in a Discrete Round-Robin Queue.</title>
<pages>57-62</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Schassberger81</url>
<abstract>A closed rational expression is derived for the generating function of the response time distribution in a certain discrete-time queuing model with Bernoulli input, general arithmetic service time distribution, and round-robin scheduling.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289590</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schmid76">
<author>Hans Albrecht Schmid</author>
<title>On the Efficient Implementation of Conditional Critical Regions and the Construction of Monitors.</title>
<pages>227-249</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Schmid76</url>
<abstract>A method is presented that allows the efficient implementation of conditional critical regions combined with scheduling of the waiting processes. It is based on the knowledge of static and invariant relations that exist among the conditional critical regions of a process system. Mathematical methods are applied in order to show the nature of these relations, and to determine them for practical applications.By collecting the conditional critical regions in a program module, a monitor is obtained. Its rather abstract user level allows clear and well structured programming style. It also shows some advantages in comparison to other monitor proposals on the implementation level.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288656</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schurfeld83">
<author>Ute Sch&uuml;rfeld</author>
<title>New Lower Bounds on the Formula Size of Boolean Functions.</title>
<pages>183-194</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Schurfeld83</url>
<abstract>In this paper we investigate the method of Nechiporuk [3] for deriving lower bounds on the formula size of Boolean functions. At first we prove non-linear lower bounds for functions which are related to the existence of a k-clique or a k-circle in a graph. Furthermore we determine the formula size of the “disjoint disjunction” of the outputs of the Boolean matrix product. Finally we show how useful the method may be in the case of monotone functions if the length of the prime implicants is bounded.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264475</ee>
</article>
<article mdate="2010-10-24" key="journals/acta/YingF10">
<author>Mingsheng Ying</author>
<author>Yuan Feng</author>
<title>Quantum loop programs.</title>
<pages>221-250</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Loop is a powerful program construct in classical computation, but its power is still not exploited fully in quantum computation. The exploitation of such power definitely requires a deep understanding of the mechanism of quantum loop programs. In this paper, we introduce a general scheme of quantum loops and describe its computational process. The function computed by a quantum loop is defined, and a denotational semantics and a weakest precondition semantics of a quantum loop are given. The notions of termination and almost termination are proposed for quantum loops. This paper only consider the case of finite-dimensional state spaces. Necessary and sufficient conditions for termination and almost termination of a general quantum loop on any mixed input state are presented. A quantum loop is said to be (almost) terminating if it (almost) terminates on any input state. We show that a quantum loop is almost terminating if and only if it is uniformly almost terminating. It is observed that a small disturbance either on the unitary transformation in the loop body or on the measurement in the loop guard can make any quantum loop (almost) terminating, provided that some dimension restriction is satisfied. Moreover, a representation of the function computed by a quantum loop is given in terms of finite summations of matrices. To illustrate the notions and results obtained in this paper, two simple classes of quantum loop programs, one qubit quantum loops, and two qubit quantum loops defined by controlled gates, are carefully examined, and to show their expressive power, quantum loops are applied in describing quantum walks.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0117-4</ee>
<url>db/journals/acta/acta47.html#YingF10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HuetL78">
<author>G&eacute;rard P. Huet</author>
<author>Bernard Lang</author>
<title>Proving and Applying Program Transformations Expressed with Second-Order Patterns.</title>
<pages>31-55</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#HuetL78</url>
<abstract>We propose a program transformation method based on rewriting-rules composed of second-order schemas. A complete second-order matching algorithm is presented that allows effective use of these rules. We show how to formally prove the correctness of the rules using a denotational semantics for the programming language. We establish the correctness of the transformation method itself, and give techniques pertaining to its actual implementation. The paper is illustrated with recursion removal examples.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264598</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Pohlmann83">
<author>Werner Pohlmann</author>
<title>LR Parsing for Affix Grammars.</title>
<pages>283-300</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Pohlmann83</url>
<abstract>The principal tools in LR theory, viz. item grammars and their corresponding automata, are adapted for use with affix grammars. The items (and automata states) are furnished with attributes that serve as pointers into the parsing stack and thus determine the inherited affixes needed in a reduction step. This attribute mechanism can be tested for ambiguity. If unambiguous and consistent in the sense of LR theory, the attributed automaton defines a deterministec bottom-up parser for the affix grammar in question.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264275</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikK89">
<author>Karel Culik II</author>
<author>Juhani Karhum&auml;ki</author>
<title>HDTOL Matching of Computations of Multitape Automata.</title>
<pages>179-191</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta27.html#CulikK89</url>
<abstract>We discuss the technique for testing the equivalence of two deterministic automata by constructing a language that matches the computations of two equivalent automata on the same input word. Specifically, we propose to use HDTOL languages that are powerful enough to match computations of many equivalent deterministic multitape automata, and at the same time, have nice decidable properties. Using this new technique of HDTOL matching, we show that the inclusion problem between an arbitrary deterministic multitape automaton and a simple one is decidable in both directions. Further, we show that the equivalence for a restricted class of transducers based on deterministic multitape automata is decidable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265153</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CarlssonC92">
<author>Svante Carlsson</author>
<author>Jingsen Chen</author>
<title>On Partitions and Presortedness of Sequences.</title>
<pages>267-280</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta29.html#CarlssonC92</url>
<abstract>To take advantage of existing order in a sequence when sorting, we evaluate the quantity of this information by the minimal size of decomposition of the input sequence, particularly the minimal size of chain and of monotonic partitions. Some sorting strategies that are optimal with respect to these measures of presortedness are presented. The relationships between these new measures of presortedness and other known measures have also been explored. As an application, we carry out the optimality of an adaptive sorting algorithm Skiena'sMelsort. For some special partitioning strategies, we present two sorting algorithms based on Dijkstra'sSmoothsort. Moreover, the optimalities of these two algorithms are demonstrated. By examining the optimalities of sorting algorithms with respect to certain measures of presortedness, we also propose some optimal sorting strategies for one class of measures. Finally, we discuss other types of sorting problems, such as sorting multisets and topological sorting. In particular, we derive an optimal algorithm for sorting multisets and for finding the multiset sizes as well.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185681</ee>
</article>
<article mdate="2012-01-27" key="journals/acta/Blanchet-SadriMSW12">
<author>Francine Blanchet-Sadri</author>
<author>Robert Mercas</author>
<author>Sean Simmons</author>
<author>Eric Weissenstein</author>
<title>Erratum to: Avoidable binary patterns in partial words.</title>
<pages>53-54</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract></abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0149-4</ee>
<url>db/journals/acta/acta49.html#Blanchet-SadriMSW12</url>
</article>
<article mdate="2013-11-22" key="journals/acta/SeoP13">
<author>Jeongbong Seo</author>
<author>Sungwoo Park</author>
<title>Judgmental subtyping systems with intersection types and modal types.</title>
<pages>359-380</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>We study how to extend modal type systems based on intuitionistic modal logic S4 or S5 with a subtyping system based on intersection types. In the presence of four type constructors \({\!}\!\rightarrow \!{\!},\,{\!}\wedge {\!},\,\square {}\), and \(\Diamond {}\), the traditional approach using a binary subtyping relation does not work well because of lack of orthogonality in subtyping rules and presence of a transitivity rule. We adopt the idea from the judgmental formulation of modal logic (Pfenning and Davies in Math Struct Comput Sci 11(4):511–540, 2001) and use subtyping judgments whose definitions express those notions internalized into type constructors directly at the level of judgments. The resultant judgmental subtyping systems admit cut rules similarly to a sequent calculus for intuitionistic logic and play a key role in designing and verifying the relational subtyping systems based on the binary subtyping relation. We use the proof assistant Coq to prove the admissibility of the cut rules and the equivalence between the two kinds of subtyping systems. The lesson from our study is that by using subtyping judgments instead of the binary subtyping relation, we can overcome the limitation usually associated with the syntactic approach to formulating subtyping systems.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0186-2</ee>
<url>db/journals/acta/acta50.html#SeoP13</url>
</article>
<article mdate="2006-05-10" key="journals/acta/EhrenfeuchtHR06">
<author>Andrzej Ehrenfeucht</author>
<author>Tero Harju</author>
<author>Grzegorz Rozenberg</author>
<title>Embedding linear orders in grids.</title>
<pages>419-428</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>A grid (or a mesh) is a two-dimensional permutation: an m× n-grid of size mn is an m× n-matrix where the entries run through the elements {1,2, …, mn}. We prove that if δ1 and δ2 are any two linear orders on {1,2, …, N}, then they can be simultaneously embedded (in a well defined sense) into a unique grid having the smallest size.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-005-0001-9</ee>
<url>db/journals/acta/acta42.html#EhrenfeuchtHR06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HehnerGM86">
<author>Eric C. R. Hehner</author>
<author>Lorene E. Gupta</author>
<author>Andrew J. Malton</author>
<title>Predicative Methodology.</title>
<pages>487-505</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#HehnerGM86</url>
<abstract>We introduce a predicative semantics of programs and show its use in programming. With it, logic errors can be detected and reported when they are made, just like syntax errors. Programming paradigms are stated precisely as theorems. The use of paradigms in larger programs is shown to be the same as the mathematician's use of theorems in the proof of larger theorems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288466</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Correl78">
<author>Claus H. Correl</author>
<title>Proving Programs Correct through Refinement.</title>
<pages>121-132</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Correl78</url>
<abstract>Program proving must be made applicable to all stages of program development. In particular, in the design phase, proving could prevent a program development based on erroneous or inconsistent design decisions, with its associated high cost of debugging. Furthermore, the proving activity itself would benefit from an early application in the development cycle of a program, because the proof of a program design seems to be simpler than the proof of the final, perhaps optimized, program. The Fisher-Galler algorithm will be used as an example for demonstrating the proof of a program design. An algebraic specification technique is used for describing the design. Details of the proof will be discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289073</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FrantaB80">
<author>William R. Franta</author>
<author>Mark Benedict Bilodeau</author>
<title>Analysis of a Prioritized CSMA Protocol Based on Staggered Delays.</title>
<pages>299-324</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#FrantaB80</url>
<abstract>Carrier sense multiple access (CSMA) protocols were originally conceived for use in digital radio communication. Such protocols are, however, quite applicable in a variety of distributed computing and local networking configurations based on a shared bus. The CSMA protocols are characterized by the fact that message collisions can occur only in a very small time window whose duration corresponds to the propagation delay of the bus. They are further characterized by the technique used to subsequently serialize the transmission of the colliding messages. In this paper we analyze the situation wherein colliding messages are serialized by using a set of staggered ‘retry’ delays which are associated with the sources that may generate the colliding messages. Our analysis produces both path throughput (utilization) curves and message delay curves, as a function of message generation rate. These curves show that the protocol is in a sense self stabalizing, serve to quantify its behaviour, and indicate loading levels which result in unacceptable message delays.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288767</ee>
</article>
<article mdate="2015-10-06" key="journals/acta/Engelfriet15">
<author>Joost Engelfriet</author>
<title>Two-way pebble transducers for partial functions and their composition.</title>
<pages>559-571</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Two-way finite state transducers are considered that use a finite number of pebbles, of which the life times must be nested. For every nondeterministic transducer that realizes a partial function, an equivalent deterministic transducer can be constructed. The composition of two deterministic transducers can be realized by one such transducer with a minimal number of pebbles.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0224-3</ee>
<url>db/journals/acta/acta52.html#Engelfriet15</url>
</article>
<article mdate="2011-11-25" key="journals/acta/DomosiM11">
<author>P&aacute;l D&ouml;m&ouml;si</author>
<author>Gy&ouml;rgy Mar&oacute;ti</author>
<title>On &#945; 2 - &#957; 2-products of automata.</title>
<pages>397-408</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Two equivalent sufficient conditions are given for the completeness of classes of finite automata with respect to the isomorphic simulation under the α 2 − ν 2-product. It is conjectured that these conditions are also necessary with respect to the isomorphic or homomorphic simulation too.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0143-x</ee>
<url>db/journals/acta/acta48.html#DomosiM11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Tennent77a"> 
<author>Robert D. Tennent</author>
<title>On a New Approach to Representation Independent Data Classes.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>315-324</pages>
<url>db/journals/acta/acta8.html#Tennent77a</url>
<abstract>An approach to definition of abstract data classes suggested by J.C. Reynolds is investigated in the context of a PASCAL-like language. The issues of inheritance and parameterization of classes are considered, and new design solutions proposed.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271340</ee>
</article>

<article mdate="2015-01-08" key="journals/acta/GelenbeH89">
<author>Erol Gelenbe</author>
<author>Marisela Hern&aacute;ndez</author>
<title>Optimum Checkpoints with Age Dependent Failures.</title>
<pages>519-531</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta27.html#GelenbeH89</url>
<abstract>This paper presents a method for obtaining the optimum checkpoint interval of a transaction processing computer system subject to time dependent failures. The system uses checkpointing to create a valid system state, and roll-back in order to recover from failures. Maximizing system availability we derive the optimum checkpoint interval as a function of the load of the system and of the time dependent failure rate. The results are illustrated numerically for the Weibull failure rate.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00277388</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GrafS86">
<author>Susanne Graf</author>
<author>Joseph Sifakis</author>
<title>A Logic for the Specification and Proof of Regular Controllable Processes of CCS.</title>
<pages>507-527</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#GrafS86</url>
<abstract>This work has been motivated by the following general problem: find logics for the specification and proof of programs, described by terms of some algebra with given congruence relation. This relation is supposed to define a satisfactory concept for the behavioural comparison of programs. We require these logics to be adequate with respect to the term language, in the sense that two programs, behaviourally equivalent satisfy the same formulas and conversely. The term language considered is the subset of controllable, regular terms of CCS, on a vocabulary of actions A, with observational congruence. A term is said to be controllable if it is congruent to some term without occurrence of τ. We obtain an adequate logic whose language of formulas is obtained from constants true, false and ¦Nil¦ by using operators ∨, ∧, fixpoint operators, + and a for a∈A; the latter can be considered as extensions of the operators + and a for a∈A of CCS. As a result, controllable CCS terms can be considered as formulas of this logic and the problem of program verification is reduced to the proof of the validity of a formula.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288467</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Autebert79">
<author>Jean-Michel Autebert</author>
<title>Op&eacute;rations de Cylindre et applications s&eacute;quentielles gauches inverses.</title>
<pages>241-258</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Autebert79</url>
<abstract>Dans cet article, on étudie les rapports entre la principauté d'une famille de langages en tant que cylindre et en tant que famille fermée par application séquentielle gauche (gsm) inverse. Pour cela on considère les familles de langages closes pour les opérations de cylindre et les gsm inverses. On montre qu'une telle famille est principale en tant que cylindre seulement si elle est principale vis à vis des gsm inverses, mais que l'inverse n'est pas vrai. Cependant, si l'on se restreint aux familles de langages vérifiant une propriété de clôture que l'on explicite, on obtient cette réciproque.In this paper, the relations between the principality of a family of languages as a cylinder and its principality as family closed under inverse gsm mappings are studied. For that purpose, the families of languages closed under the operations of cylinder and under inverse gsm mappings are considered. It is shown that such a family is a principal cylinder only if it is principal through the operation of inverse gsm mapping, but that the converse is not true. However, the converse is true for the families satisfying a closure property given here.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289070</ee>
</article>
<article mdate="2015-06-08" key="journals/acta/AguadoMHF15">
<author>Joaquin Aguado</author>
<author>Michael Mendler</author>
<author>Reinhard von Hanxleden</author>
<author>Insa Fuhrmann</author>
<title>Denotational fixed-point semantics for constructive scheduling of synchronous concurrency.</title>
<pages>393-442</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>The synchronous model of concurrent computation (SMoCC) is well established for programming languages in the domain of safety-critical reactive and embedded systems. Translated into mainstream C/Java programming, the SMoCC corresponds to a cyclic execution model in which concurrent threads are synchronised on a logical clock that cuts system computation into a sequence of macro-steps. A causality analysis verifies the existence of a schedule on memory accesses to ensure each macro-step is deadlock-free and determinate. We introduce an abstract semantic domain \(I(\mathbb {D}, \mathbb {P})\) and an associated denotational fixed-point semantics for reasoning about concurrent and sequential variable accesses within a synchronous cycle-based model of computation. We use this domain for a new and extended behavioural definition of Berry’s causality analysis in terms of approximation intervals. The domain \(I(\mathbb {D}, \mathbb {P})\) extends the domain \(I(\mathbb {D})\) from our previous work and fixes a mistake in the treatment of initialisations. Based on this fixed-point semantics we propose the notion of Input Berry-constructiveness (IBC) for synchronous programs. This new IBC class lies properly between strong (SBC) and normal Berry-constructiveness (BC) defined in previous work. SBC and BC are two ways to interpret the standard constructive semantics of synchronous programming, as exemplified by imperative SMoCC languages such as Esterel or Quartz. SBC is often too restrictive as it requires all variables to be initialised by the program. BC can be too permissive because it initialises all variables to a fixed value, by default. Where the initialisation happens through the memory, e.g., when carrying values from one synchronous tick to the next, then IBC is more appropriate. IBC links two levels of execution, the macro-step level and the micro-step level. We prove that the denotational fixed-point analysis for IBC, and hence Berry’s causality analysis, is sound with respect to operational micro-level scheduling. The denotational model can thus be viewed as a compositional presentation of a synchronous scheduling strategy that ensures reactiveness and determinacy for imperative concurrent programming.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0238-x</ee>
<url>db/journals/acta/acta52.html#AguadoMHF15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ChenR85">
<author>Marina C. Chen</author>
<author>Martin Rem</author>
<title>Deadlock-Freedom in Resource Contentions.</title>
<pages>585-598</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#ChenR85</url>
<abstract>The paper establishes two necessary and sufficient conditions for the absence of deadlock in resource contentions under the expedient allocation policy. Their equivalence is proved. One of these was discovered independently by Ibaraki and Kameda. The conditions are essentially the condition of the König-Hall Theorem for the existence of a system of distinct representatives. If there are no multiple resources the conditions simplify to the condition for acyclicity of hypergraphs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289712</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schuler75"> 
<author>P. F. Schuler</author>
<title>A Note on Degrees of Context-Sensitivity.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>387-394</pages>
<url>db/journals/acta/acta5.html#Schuler75</url>
<abstract>Further insight into the relation: complexity of general context-sensitivity versus complexity of weak-context-sensitivity, is offered by the following result:The structure of deterministic 3-degrees of context-sensitivity is complex enough to allow an isomorphic embedding of any countable partial ordering.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264568</ee>
</article>

<article mdate="2013-11-22" key="journals/acta/Rosa-Velardo13">
<author>Fernando Rosa-Velardo</author>
<title>Petri nets with name creation for transient secure association.</title>
<pages>403-436</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Transient secure association has been widely accepted as a possible alternative to traditional authentication in the context of Ubiquitous Computing. Two components in a distributed system with transient secure association may share a master-slave relationship, which creates a hierarchical but dynamic structure of components. In this paper we develop several formal models for distributed systems with transient secure association, with incremental expressive power, all based on Petri nets. The first model, that we call transient secure association (TSA) systems, considers finitely many components. Then we consider a small extension of TSA systems, in which slaves are initialized whenever a master-slave relation is broken. Last, we define unbounded TSA (uTSA) systems, for which the number of components is not bounded. For each of the defined formalisms, we establish a link to a known class of Petri nets, thus inheriting the corresponding (un)decidability results from them.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0188-0</ee>
<url>db/journals/acta/acta50.html#Rosa-Velardo13</url>
</article>
<article mdate="2005-11-14" key="journals/acta/ChenS05">
<author>Yifeng Chen</author>
<author>Jeff W. Sanders</author>
<title>The weakest specifunction.</title>
<pages>383-414</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The weakest specifunction has been introduced to generalise the notions of weakest prespecification and weakest parallel environment. It calculates the weakest specification function whose value refines the target specification when applied to a given component; thus it forms the basis for compositional refinement, an essential ingredient in program derivation. But unlike those previous calculi it is able to deal with several unknown components simultaneously and hence has wider applicability. In this paper we extend the general theory of the weakest specifunction, identifying those spaces in which it behaves miraculously. The par-seq specifunction places an established component in parallel with a required component and the result in sequence with another required component to meet a given specification. We extend the study of the par-seq specifunction in the context of log s, an intermediate-level language for reactive computing in an abstraction of the PRAM and BSP models of computation, and provide a single complete law for its use in program derivation. The resulting calculus is applied to the derivation of a distributed algorithm for dynamic load balancing.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0163-5</ee>
<url>db/journals/acta/acta41.html#ChenS05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/File83">
<author>Gilberto Fil&eacute;</author>
<title>Interpretation and Reduction of Attribute Grammars.</title>
<pages>115-150</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#File83</url>
<abstract>An attribute grammar (AG) is in reduced form if in all its derivation trees every attribute contributes to the translation. We prove that, eventhough AG are generally not in reduced form, they can be reduced, i.e., put into reduced form, without modifying their translations. This is shown first for noncircular AG and then for arbitrary AG. In both cases the reduction consists of easy (almost syntactic) transformations which do not change the semantic domain of the AG. These easy transformations are formalized by introducing the notion of AG interpretation as an extension to AG of the concept of context-free grammar form. Finally we prove that any general algorithm for reducing even the simple class of L-AG needs exponential time (in the size of the input AG) infinitely often.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264472</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PudlakRS88">
<author>Pavel Pudl&aacute;k</author>
<author>Vojtech R&ouml;dl</author>
<author>Petr Savick&yacute;</author>
<title>Graph Complexity.</title>
<pages>515-535</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta25.html#PudlakRS88</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00279952</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Vorst88">
<author>Johannes G. G. van de Vorst</author>
<title>The Formal Development of a Parallel Program Performing LU-Decomposition.</title>
<pages>1-17</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#Vorst88</url>
<abstract>The development of a new parallel algorithm performing the LU-decomposition of a regular matrix is given. The algorithm is developed using formal techniques that rely on the use of invariants that express the properties of parallel processes (like in the Gries-Owicki approach) and ordered sets that define the communications between them. Special attention is given to the new notion of a parallel invariant: it is made clear that many invariants contain too many implicit sequential constraints, which makes them inferior to other ones. Also considered are the efficiency, both in communications and in computations, and the correctness. It is shown that the algorithm suggested in this paper has better efficiency than algorithms that use a partitioning of the matrix into rows, columns, or blocks. The programming techniques used are evaluated against the programming demands posed by the specific problem considered.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915443</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DiekertM94">
<author>Volker Diekert</author>
<author>Anca Muscholl</author>
<title>Deterministic Asynchronous Automata for Infinite Traces.</title>
<pages>379-397</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta31.html#DiekertM94</url>
<abstract>This paper shows the equivalence between the family of recognizable languages over infinite traces and the family of languages which are recognized by deterministic asynchronous cellular Muller automata. We thus give a proper generalization of McNaughton's Theorem from infinite words to infinite traces. Thereby we solve one of the main open problems in this field. As a special case we obtain that every closed (w.r.t. the independence relation) word language is accepted by someI-diamond deterministic Muller automaton.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178512</ee>
</article>
<article mdate="2015-10-07" key="journals/acta/BerniniBPSV15">
<author>Antonio Bernini</author>
<author>Stefano Bilotta</author>
<author>Renzo Pinzani</author>
<author>Ahmad Sabri</author>
<author>Vincent Vajnovszki</author>
<title>Gray code orders for q-ary words avoiding a given factor.</title>
<pages>573-592</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Based on order relations inspired by the binary reflected Gray code (BRGC) we define Gray codes and give a generating algorithm for \(q\)-ary words avoiding a prescribed factor. These generalize an early 2001 result and a very recent one published by some of the present authors, and can be seen as an alternative to those of Squire published in 1996. Among the involved tools, we make use of generalized BRGC order relations, ultimate periodicity of infinite words, and word matching techniques.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0225-2</ee>
<url>db/journals/acta/acta52.html#BerniniBPSV15</url>
</article>
<article mdate="2011-05-06" key="journals/acta/SommerhalderW83">
<author>Rudolph Sommerhalder</author>
<author>S. Christian van Westrhenen</author>
<title>Parallel Language Recognition in Constant Time by Cellular Automata.</title>
<pages>397-407</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#SommerhalderW83</url>
<abstract>It is proved that the set of all languages accepted within a fixed, language dependent number of steps by deterministic one dimensional cellular acceptors is a proper subset of the set of all regular languages.A combinatorial condition is stated which is necessary and sufficient for a language to be recognizable in constant time by a deterministic one dimensional cellular automaton.It is shown that the question of whether or not the language generated by a given context-sensitive grammar is recognizable in constant time is algorithmically unsolvable. The question becomes solvable if a regular grammar is given.Finally it is proved that the set of all languages that can be accepted by non-deterministic one dimensional cellular acceptors is equal to the set of all regular languages.In conclusion some generalizations to n-dimensional languages and array languages are mentioned.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290736</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BaetenV92">
<author>Jos C. M. Baeten</author>
<author>Frits W. Vaandrager</author>
<title>An Algebra for Process Creation.</title>
<pages>303-334</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta29.html#BaetenV92</url>
<abstract>In this paper, we study the issue of process creation from an algebraic perspective. The key to our approach, which is inspired by work of America and De Bakker, consists of giving a new interpretation to the operator symbol · (sequential composition) in the axiom system BPA of Bergstra and Klop. We present a number of other models for BPA and show how the new interpretation of · naturally generalises the usual interpretation in ACP. We give an operational semantics based on Plotkin style inductive rules for a simple language with process creation and communication, and give a complete finite axiomatisation of the associated bisimulation model.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178776</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Knuth90">
<author>Donald E. Knuth</author>
<title>Nested Satisfiability.</title>
<pages>1-6</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta28.html#Knuth90</url>
<abstract>A special case of the satisfiability problem, in which the clauses have a hierarchical structure, is shown to be solvable in linear time, assuming that the clauses have been represented in a convenient way.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02983372</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/CoffmanST03">
<author>Edward G. Coffman Jr.</author>
<author>Jay Sethuraman</author>
<author>Vadim G. Timkovsky</author>
<title>Ideal preemptive schedules on two processors.</title>
<pages>597-612</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>An ideal schedule minimizes both makespan and total flow time. It is known that the Coffman-Graham algorithm [Acta Informatica 1, 200-213, 1972] solves in polynomial time the problem of finding an ideal nonpreemptive schedule of unit-execution-time jobs with equal release dates and arbitrary precedence constraints on two identical parallel processors. This paper presents an extension of the algorithm that solves in polynomial time the preemptive counterpart of this problem. The complexity status of the preemptive problem of minimizing just the total flow time has been open.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0119-6</ee>
<url>db/journals/acta/acta39.html#CoffmanST03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtPR94">
<author>Andrzej Ehrenfeucht</author>
<author>Paulien ten Pas</author>
<author>Grzegorz Rozenberg</author>
<title>Context-free Text Grammars.</title>
<pages>161-206</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta31.html#EhrenfeuchtPR94</url>
<abstract>A text is a tripleτ=(λ,ρ 1,ρ 2) such that λ is a labeling function, andρ 1 andρ 2 are linear orders on the domain of λ; hence τ may be seen as a word (λ,ρ 1) together with an additional linear orderρ 2 on the domain of λ. The orderρ 2 is used to give to the word (λ,ρ 1) itsindividual hierarchical representation (syntactic structure) which may be a tree but it may be also more general than a tree. In this paper we introducecontext-free grammars for texts and investigate their basic properties. Since each text has its own individual structure, the role of such a grammar should be that of a definition of a pattern common to all individual texts. This leads to the notion of ashapely context-free text grammar also investigated in this paper.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01192159</ee>
</article>
<article mdate="2012-09-23" key="journals/acta/LauerC75"> 
<author>Peter E. Lauer</author>
<author>Roy H. Campbell</author>
<title>Formal Semantics of a Class of High-Level Primitives for Coordinating Concurrent Processes</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>297-332</pages>
<url>db/journals/acta/acta5.html#LauerC75</url>
<abstract>High level programs for generating systems of cooperating concurrent processes are classified according to syntactic criteria. Their semantic characterization by means of Petri Nets, a mathematical theory of system descriptions, induces a corresponding syntactic classification on the latter. This permits the transferal of intuitively important semantical results of Petri Net theory to their corresponding programs. As a consequence it becomes possible to determine a certain kind of semantic correctness of a programm merely by its syntactic classification. Alternate solutions to a well known synchronization problem are treated in this way.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264564</ee>
<note>Addenda and Corrigenda: Acta Informatica 7: 325 (1977)</note>
</article>

<article mdate="2011-01-11" key="journals/acta/Rao96">
<author>M. R. K. Krishna Rao</author>
<title>Relating Confluence, Innermost-Confluence and Outermost-Confluence Properties of Term Rewriting Systems.</title>
<pages>595-606</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#Rao96</url>
<abstract>Innermost-confluence is important in giving call-by-value and denotational semantics and outermost-confluence is important in giving call-by-need and lazy semantics of programs. In this paper, we give a few sets of sufficient conditions under which the properties of confluence, innermost-confluence and outermost-confluence coincide.Confluence and innermost-confluence coincide for weakly innermost normalizing overlay systems and confluence and outermost-confluence coincide for outermost normalizing left-linear overlay systems. In general, every weakly innermost (outermost) normalizingconfluent system isinnermost (outermost) confluent but the converse is not true.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036465</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GilliesL91">
<author>Donald W. Gillies</author>
<author>Jane W.-S. Liu</author>
<title>Greed in Resource Scheduling.</title>
<pages>755-775</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta28.html#GilliesL91</url>
<abstract>We examine the worst-case performance of a class of heuristic scheduling algorithms commonly referred to as priority-driven or list-scheduling algorithms. It is well known that these algorithms have anomalous, unpredictable performance when used to schedule nonpreemptive tasks with precedence constraints. We present a general method for deriving the worst-case performance of these algorithms. This method is easy to use, yet powerful enough to yield tight performance bounds for many classes of scheduling problems. We demonstrate the method for several problems to show it has wide applicability. We also present several task systems for which list-scheduling algorithms exhibit unavoidable worst-case performance and discuss the general characteristics of these task systems. These task systems are sometimes overlooked in simulation studies; consequently, the results of these studies may be overly optimistic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01261655</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CourtoisV76">
<author>Pierre-Jacques Courtois</author>
<author>Hendrik Vantilborgh</author>
<title>A Decomposable Model of Program Paging Behaviour.</title>
<pages>251-275</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#CourtoisV76</url>
<abstract>Existing models of program behaviour are shown to give an incomplete account of program locality. A model based on the distinction between short- and long-run equilibrium states in nearly completely decomposable systems is proposed to overcome this deficiency. This distinction leads to the combined use of a Markovian model of the transitions between localities and of separate models for the locality short-term behaviours. This combination is shown to give better estimations of the page fault rate and of the working set size distribution. The conditions under which this distribution is approximately normal and under which the assumptions of independent page references are valid are also clarified. The approach is illustrated by a numerical example, showing in particular that other models presented in the literature may have computer time and space requirements which are beyond practical possibilities.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288657</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ChanzyDZ01">
<author>Philippe Chanzy</author>
<author>Luc Devroye</author>
<author>Carlos Zamora-Cura</author>
<title>Analysis of range search for random k-d trees.</title>
<pages>355-383</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>4/5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037004/10370355.htm</ee>
<url>db/journals/acta/acta37.html#ChanzyDZ01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Bucher86">
<author>Walter Bucher</author>
<title>A Regularity Test for Dual Bordered <i> OS </i> Systems.</title>
<pages>245-253</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#Bucher86</url>
<abstract>A dual bordered OS system is a triple (∑, P, S) where ∑ is a finite alphabet, S a finite subset of ∑*, the set of axioms, and P a finite set of rules of the form a→a × a, where a ε ∑ and x ε ∑ *. Using well-quasi-order theory, we show that the regularity problem for such systems is decidable. Whether such a system generates a regular language essentially only depends on the set of rules but not on the axioms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289112</ee>
</article>
<article mdate="2007-06-13" key="journals/acta/VagnerM07">
<author>Ladislav Vagner</author>
<author>Borivoj Melichar</author>
<title>Parallel LL parsing.</title>
<pages>1-21</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>A deterministic parallel LL parsing algorithm is presented. The algorithm is based on a transformation from a parsing problem to parallel reduction. First, a nondeterministic version of a parallel LL parser is introduced. Then, it is transformed into the deterministic version—the LLP parser. The deterministic LLP(q,k) parser uses two kinds of information to select the next operation — a lookahead string of length up to k symbols and a lookback string of length up to q symbols. Deterministic parsing is available for LLP grammars, a subclass of LL grammars. Since the presented deterministic and nondeterministic parallel parsers are both based on parallel reduction, they are suitable for most parallel architectures.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0031-y</ee>
<url>db/journals/acta/acta44.html#VagnerM07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Vidyasankar87">
<author>K. Vidyasankar</author>
<title>Generalized Theory of Serializability.</title>
<pages>105-119</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#Vidyasankar87</url>
<abstract>An interleaved execution of transactions in a database system is serializable if the effect of the execution is equivalent to that of some serial execution of the transactions. Several notions of serializability have been defined in the literature. They differ with respect to whether the effect is equivalent regarding the values read by the transactions or the final database state, that is, the values read by the fictitious final transaction. We introduce a generalized notion called S-serializability, where the subset S of transactions read the same values as in some serial execution. We also introduce C-serializability where the final values for the subset C of data items are the same as in some serial execution. By combining these two notions, we get (S + C)-serializability. We give simple and intuitive characterizations for all these notions of serializability.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290709</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Baeza-YatesC92">
<author>Ricardo A. Baeza-Yates</author>
<author>Walter Cunto</author>
<title>Unbalanced Multiway Trees Improved by Partial Expansions.</title>
<pages>443-460</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#Baeza-YatesC92</url>
<abstract>Unbalanced multiway trees are generally impractical external data structures because of their poor space performance. In order to avoid this handicap, we have adapted the technique of partial expansions to these trees. Compared to partially expandedB +-trees in terms of average performance, the method proposed is faster, has more compact indexes, and shows the same almostoptimal asymptotic space performance at the data bucket level.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193577</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Xu92">
<author>J. Xu</author>
<title>On-Line Multiversion Database Concurrency Control.</title>
<pages>121-160</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta29.html#Xu92</url>
<abstract>This paper presents a new model for studying the concurrency vs. computation time tradeoffs involved in on-line multiversion database concurrency control. The basic problem that is studied in our model is the following:Given:a current database system state which includes information such as which transaction previously read a version from which other transaction; which transaction has written which versions into the database; and the ordering of versions previously written; anda set of read and write requests of requesting transactions.Question: Does there exist a new database system state in which the requesting transactions can be immediately put into execution (their read and write requests satisfied, or in the case of predeclared writeset transactions, write requests are guaranteed to be satisfied) while preserving consistency under a given set of additional constraints? (The amount of concurrency achieved is defined by the set of additional constraints).In this paper we derive “limits” of performance achievable by polynomial time concurrency control algorithms. Each limit is characterized by a minimal set of constraints that allow the on-line scheduling problem to be solved in polynomial time. If any one constraint in that minimal set is omitted, although it could increase the amount of concurrency, it would also have the dramatic negative effect of making the scheduling problem NP-complete; whereas if we do not omit any constraint in the minimal set, then the scheduling problem can be solved in polynomial time. With each of these limits, one can construct an efficient scheduling algorithm that achieves an optimal level of concurrency in polynomial computation time according to the constraints defined in the minimal set.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178503</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Francez83">
<author>Nissim Francez</author>
<title>Product Properties and Their Direct Verification.</title>
<pages>329-344</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Francez83</url>
<abstract>The paper presents a family of properties of programs, called product (and power) properties, for which the verification method of Floyd and Hoare are inconvenient. A (semantically) complete alternative method is proposed' The paper presents the method in both the endogenous and exogenous versions and applies them to examples. Semantic completeness and soundness are shown. The method is particularly useful for some second-order programs, having procedures as parameters.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264278</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/ElmasryJK08">
<author>Amr Elmasry</author>
<author>Claus Jensen</author>
<author>Jyrki Katajainen</author>
<title>Two-tier relaxed heaps.</title>
<pages>193-210</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>We introduce a data structure which provides efficient heap operations with respect to the number of element comparisons performed. Let n denote the size of the heap being manipulated. Our data structure guarantees the worst-case cost of O(1) for finding the minimum, inserting an element, extracting an (unspecified) element, and replacing an element with a smaller element; and the worst-case cost of O(lg n) with at most lg n + 3 lg lg n + O(1) element comparisons for deleting an element. We thereby improve the comparison complexity of heap operations known for run-relaxed heaps and other worst-case efficient heaps. Furthermore, our data structure supports melding of two heaps of size m and n at the worst-case cost of O(min {lg m, lg n}).</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0070-7</ee>
<url>db/journals/acta/acta45.html#ElmasryJK08</url>
</article>
<article mdate="2008-08-08" key="journals/acta/MeinickeH08">
<author>Larissa Meinicke</author>
<author>Ian J. Hayes</author>
<title>Algebraic reasoning for probabilistic action systems and while-loops.</title>
<pages>321-382</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Back and von Wright have developed algebraic laws for reasoning about loops in a total correctness framework using the refinement calculus. We extend their work to reasoning about probabilistic loops in the probabilistic refinement calculus. We apply our algebraic reasoning to derive transformation rules for probabilistic action systems and probabilistic while-loops. In particular we focus on developing data refinement rules for these two constructs. Our extension is interesting since some well known transformation rules that are applicable to standard programs are not applicable to probabilistic ones: we identify some of these important differences and we develop alternative rules where possible.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0073-4</ee>
<url>db/journals/acta/acta45.html#MeinickeH08</url>
</article>
<article mdate="2005-01-25" key="journals/acta/AlhazovPP04">
<author>Artiom Alhazov</author>
<author>Linqiang Pan</author>
<author>Gheorghe Paun</author>
<title>Trading polarizations for labels in P systems with active membranes.</title>
<pages>111-144</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>This paper addresses the problem of removing the polarization of membranes from P systems with active membranes - and this is achieved by allowing the change of membrane labels by means of communication rules or by membrane dividing rules. As consequences of these results, we obtain the universality of P systems with active membranes which are allowed to change the labels of membranes, but do not use polarizations. Universality results are easily obtained also by direct proofs. By direct constructions, we also prove that SAT can be solved in linear time by systems without polarizations and with label changing possibilities. If non-elementary membranes can be divided, then SAT can be solved in linear time without using polarizations and label changing. Several open problems are also formulated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0153-z</ee>
<url>db/journals/acta/acta41.html#AlhazovPP04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ChinH95"> 
<author>Wei-Ngan Chin</author>
<author>Masami Hagiya</author>
<title>A Transformation Method for Dynamic-Sized Tabulation.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>2</number>
<year>1995</year> 
<pages>93-115</pages>
<url>db/journals/acta/acta32.html#ChinH95</url>
<abstract>Tupling is a transformation tactic to obtain new functions, without redundant calls and/or multiple traversals of common inputs. It achieves this feat by allowing each set (tuple) of function calls to be computed recursively from its previous set. In previous works by Chin and Khoo [8,9], a safe (terminating) fold/unfold transformation algorithm was developed for some classes of functions which are guaranteed to be successfully tupled.However, these classes of functions currently usestatic-sized tables for eliminating the redundant calls. As shown by Richard Bird in [3], there are also other classes of programs whose redundant calls could only be eliminated by usingdynamic-sized tabulation. This paper proposes a new solution to dynamic-sized tabulation by an extension to the tupling tactic. Our extension useslambda abstractions which can be viewed as either dynamic-sized tables or applications of the higher-order generalisation technique to facilitate tupling. Significant speedups could be obtained after the transformed programs were vectorised, as confirmed by experiment.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177742</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/CasanovaB80">
<author>Marco A. Casanova</author>
<author>Philip A. Bernstein</author>
<title>General Purpose Schedulers for Database Systems.</title>
<pages>195-220</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#CasanovaB80</url>
<abstract>A family of simple models for database systems is defined, where a system is composed of a scheduler, a data manager and several user transactions. The basic correctness criterion for such systems is taken to be consistency preservation. The central notion of the paper is that of a general purpose scheduler, a database system scheduler that is blind to the semantics of transactions and integrity assertions. Consistency preservation of a database system is shown to be precisely equivalent to a restriction on the output of a general purpose scheduler GPS, called weak serializability. That is, any database system using GPS will preserve consistency iff the output of GPS is always weakly serializable. This establishes a tight connection between database system correctness and scheduler behavior. Also, aspects of restart facilities and predeclared data accesses are discussed. Finally, several examples of schedulers correct with respect to weak serializability are presented.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264253</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KouvatsosA89a">
<author>Demetres D. Kouvatsos</author>
<author>John Almond</author>
<title>Erratum: Maximum Entropy Two-Station Cyclic Queues with Multiple General Servers.</title>
<pages>787</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#KouvatsosA89a</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289162</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AndersonG91">
<author>James H. Anderson</author>
<author>Mohamed G. Gouda</author>
<title>A New Explanation of the Glitch Phenomenon.</title>
<pages>297-309</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta28.html#AndersonG91</url>
<abstract>We consider a discrete model for asynchronous circuits and show that, under very mild restrictions, this model excludes the existence of glitch-free arbiters. This result contradicts a long standing conjecture that the nonexistence of glitch-free arbiters is due to the continuous nature of such circuits.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01893884</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MadsenK76"> 
<author>Ole Lehrmann Madsen</author>
<author>Bent Bruun Kristensen</author>
<title>LR-Parsing of Extended Context Free Grammars.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>61-73</pages>
<url>db/journals/acta/acta7.html#MadsenK76</url>
<abstract>To improve the readability of a grammar it is common to use extended context free grammars (ECFGs) which are context free grammars (CFGs) extended with the repetition operator (*), the alternation operator (¦) and parentheses to express the right hand sides of the productions. The topic treated here is LR-parsing of ECFGs. The LR(k) concept is generalized to ECFGs, a set of LR-preserving transformations from ECFGs to CFGs is given and finally it is shown how to construct LR-parsers directly from ECFGs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265221</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Bernabeu-AubanAA91">
<author>Jos&eacute; M. Bernab&eacute;u-Aub&aacute;n</author>
<author>Mustaque Ahamad</author>
<author>Mostafa H. Ammar</author>
<title>Resource Finding in Store-and-Forward Networks.</title>
<pages>657-680</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#Bernabeu-AubanAA91</url>
<abstract>We present a model of searching for a resource in a distributed system whose nodes are connected through a store-and-forward network. Based on this model, we show a lower bound on the number of messages needed to find a resource when nothing is known about the nodes that have the current location of the resource. The model also helps us to establish results about the time complexity of determining a message optimal resource finding algorithm when the probability distribution for the location of the resource in the network is known. We show that the optimization problem is NP-hard for general networks. Finally we show that optimal resource finding algorithms can be determined in polynomial time for a class of tree networks and bidirectional rings. The polynomial algorithms can be used as a basis of heuristic algorithms for general networks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178681</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/CorradiniBV06">
<author>Flavio Corradini</author>
<author>Maria Rita Di Berardini</author>
<author>Walter Vogler</author>
<title>Fairness of Actions in System Computations.</title>
<pages>73-130</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>This paper contrasts two important features of parallel system computations: fairness and timing. The study is carried out at a specification system level by resorting to a well-known process description language. The language is extended with labels which allow to filter out those process executions that are not (weakly) fair [as in Costa and Stirling (Acta Inf. 21:417–441, 1984) and in Costa and Stirling (Inf. Comput. 73:207–244, 1987)], and with upper time bounds for the process activities (as in Corradini et al. Acta Inf. 38:735–792, 2002). We show that fairness and timing are closely related. Two main results are stated. First, we show that each everlasting (or non-Zeno) timed process execution is fair. Second, we provide a characterization for fair executions of untimed processes in terms of timed process executions. This results in a finite representation of fair executions using regular expressions.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0011-2</ee>
<url>db/journals/acta/acta43.html#CorradiniBV06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hromkovic85">
<author>Juraj Hromkovic</author>
<title>Fooling a Two-Way Nondeterministic Multihead Automaton with Reversal Number Restriction.</title>
<pages>589-594</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta22.html#Hromkovic85</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00267046</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ItaiR82">
<author>Alon Itai</author>
<author>Michael Rodeh</author>
<title>Representation of Graphs.</title>
<pages>215-219</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#ItaiR82</url>
<abstract>Given a formulation of a problem, a compact representation is required both for theoretical purposes — measuring the complexity of algorithms, and for practical purposes — data compression.The adjacency lists method for representing graphs is compared to the information theoretic lower bounds, and it is shown to be optimal in many instances. For n-vertex labeled planar graphs the adjacency lists method requires 3nlogn + O(n) bits, a linear algorithm is presented to obtain a 3/2nlogn + O(n) representation while nlogn + O(n) is shown to be the minimum.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288971</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Russmann97">
<author>Arnd Ru&szlig;mann</author>
<title>Dynamic LL(k) Parsing.</title>
<pages>267-289</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta34.html#Russmann97</url>
<abstract>A new class of context-free grammars, called dynamic context-free grammars, is introduced. These grammars have the ability to change the set of production rules dynamically during the derivation of some terminal string. The notion of LL(\(k\)) parsing is adapted to this grammar model. We show that dynamic LL(\(k\)) parsers are as powerful as LR(\(k\)) parsers, i.e. that they are capable to analyze every deterministic context-free language while using only one symbol of lookahead.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050085</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/KiepuszewskiHA03">
<author>Bartek Kiepuszewski</author>
<author>Arthur H. M. ter Hofstede</author>
<author>Wil M. P. van der Aalst</author>
<title>Fundamentals of control flow in workflows.</title>
<pages>143-209</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Abstract. Although workflow management emerged as a research area well over a decade ago, little consensus has been reached as to what should be essential ingredients of a workflow specification language. As a result, the market is flooded with workflow management systems, based on different paradigms and using a large variety of concepts. The goal of this paper is to establish a formal foundation for control-flow aspects of workflow specification languages, that assists in understanding fundamental properties of such languages, in particular their expressive power. Workflow languages can be fully characterized in terms of the evaluation strategy they use, the concepts they support, and the syntactic restrictions they impose. A number of results pertaining to this classification will be proven. This should not only aid those developing workflow specifications in practice, but also those developing new workflow engines.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-002-0105-4</ee>
<url>db/journals/acta/acta39.html#KiepuszewskiHA03</url>
</article>
<article mdate="2004-03-03" key="journals/acta/LayuanC03">
<author>Li Layuan</author>
<author>Li Chunlin</author>
<title>A distributed QoS-Aware multicast routing protocol.</title>
<pages>211-233</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>This paper discusses the multicast routing problem with QoS constraints, and describes a network model that is suitable to research such routing problem. The paper mainly presents a distributed QoS-aware multicast routing protocol (QMRP). The QMRP can operate on top of the unicast routing protocol. It only requires the local state information of the link (or the node), but does not require any global network state to be maintained. The QMRP can significantly reduce the overhead for constructing a multicast tree with QoS constraints. In QMRP, a multicast group member can join or leave the multicast session dynamically, which can support dynamic membership. The protocol can search multiple feasible tree branches, and select the optimal or near-optimal branch for connecting the new receiver to the multicast tree if it exists. In this paper, the proof of correctness and complexity analysis of the QMRP are given, and the performance measures of the protocol are evaluated using simulation. The study shows that QMRP provides an available approach to multicast routing with QoS constraints and dynamic membership support.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0123-x</ee>
<url>db/journals/acta/acta40.html#LayuanC03</url>
</article>
<article mdate="2014-05-14" key="journals/acta/ChatterjeeRR14">
<author>Krishnendu Chatterjee</author>
<author>Mickael Randour</author>
<author>Jean-Fran&ccedil;ois Raskin</author>
<title>Strategy synthesis for multi-dimensional quantitative objectives.</title>
<pages>129-163</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>Multi-dimensional mean-payoff and energy games provide the mathematical foundation for the quantitative study of reactive systems, and play a central role in the emerging quantitative theory of verification and synthesis. In this work, we study the strategy synthesis problem for games with such multi-dimensional objectives along with a parity condition, a canonical way to express \(\omega \)-regular conditions. While in general, the winning strategies in such games may require infinite memory, for synthesis the most relevant problem is the construction of a finite-memory winning strategy (if one exists). Our main contributions are as follows. First, we show a tight exponential bound (matching upper and lower bounds) on the memory required for finite-memory winning strategies in both multi-dimensional mean-payoff and energy games along with parity objectives. This significantly improves the triple exponential upper bound for multi energy games (without parity) that could be derived from results in literature for games on vector addition systems with states. Second, we present an optimal symbolic and incremental algorithm to compute a finite-memory winning strategy (if one exists) in such games. Finally, we give a complete characterization of when finite memory of strategies can be traded off for randomness. In particular, we show that for one-dimension mean-payoff parity games, randomized memoryless strategies are as powerful as their pure finite-memory counterparts.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0182-6</ee>
<url>db/journals/acta/acta51.html#ChatterjeeRR14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Plateau80">
<author>Brigitte Plateau</author>
<title>Evaluation des Performances d'un Algorithme de Controle de la Coh&eacute;rence d'une Base de Donn&eacute;es R&eacute;partie.</title>
<pages>39-62</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Plateau80</url>
<abstract>This article presents a performance evaluation of an algorithm preserving consistency in a duplicated data base. This algorithm was proposed by C.A. Ellis, and is representative of a class of solutions: Ring structured, priority use, fully duplicated copies,... Throughput, communication delay, number of messages are the performance criteria used.Cet article présente l'évaluation des performances d'un algorithme préservant la cohérence d'une base de données répartie. Cet algorithme a été proposé par C.A. Ellis et est représentatif d'une classe de solutions: utilisation d'un anneau virtuel, utilisation de priorité, copies totalement dupliquées... Débit, temps de communication, nombre de messages ont été les critères de performances retenus.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289063</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Baccelli81">
<author>Fran&ccedil;ois Baccelli</author>
<title>Analysis of a Service Facility with Periodic Checkpointing.</title>
<pages>67-81</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Baccelli81</url>
<abstract>This paper is an application of the theory of Markov renewal and semi regenerative processes into checkpointing problems. Its main practical contribution consists in the analytic expression of mean response time of systems under checkpointing and in the presence of intermittent failures (data bases, file systems ...).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00269809</ee>
</article>
<article mdate="2009-06-22" key="journals/acta/BestD09">
<author>Eike Best</author>
<author>Philippe Darondeau</author>
<title>A decomposition theorem for finite persistent transition systems.</title>
<pages>237-254</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>In this paper, we consider finite labelled transition systems. We show that if such transition systems are deterministic, persistent, and weakly periodic, then they can be decomposed in the following sense. There exists a finite set of label-disjoint cycles such that any other cycle is Parikh-equivalent to a multiset of cycles from this set.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0095-6</ee>
<url>db/journals/acta/acta46.html#BestD09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/WangZC97">
<author>Ke Wang</author>
<author>Weining Zhang</author>
<author>Siu-Cheung Chau</author>
<title>Weakly Independent Database Schemes.</title>
<pages>1-22</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta34.html#WangZC97</url>
<abstract>Independent database schemes are best known to have constraints enforced globally by enforcing them locally in individual relations, and therefore are highly desirable in an updates-busy and distributed environment. However, independence excludes all database schemes with interrelational functional dependencies and therefore is too strong a condition. In this paper, a natural generalization of independent schemes along this line, called weakly independent schemes, is defined. A database scheme is weakly independent with respect to a set of embedded functional dependencies if the constraints can be enforced globally by enforcing local as well as interrelational functional dependencies. (a) A characterization of the weak independence and an exponential time test (in the number of functional dependencies) are presented. (b) Two polynomial time conditions are also presented, one is necessary and the other is sufficient for a database scheme to be weakly independent. (c) It is shown that a certain acyclicity of the database scheme implies weak independence. Extension to the case of embedded functional dependencies plus the join dependency \(\Join{\bf R}\) is also considered.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050071</ee>
</article>
<article mdate="2009-06-22" key="journals/acta/CampeanuS09">
<author>Cezar C&acirc;mpeanu</author>
<author>Nicolae Santean</author>
<title>On the closure of pattern expressions languages under intersection with regular languages.</title>
<pages>193-207</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>In this paper we address a standing question on pattern expressions (PE), namely whether the family of PE languages is closed under the intersection with regular languages. Since this family is not closed under complement, but is closed under reversal, another natural question has frequently been raised in the recent years, on whether particular languages such as the mirror language and the language of palindromes are PE languages. We give answers to these and other related questions as well, thus providing an insight on their descriptional power.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0090-y</ee>
<url>db/journals/acta/acta46.html#CampeanuS09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LeungC82">
<author>Clement H. C. Leung</author>
<author>Qui Hoon Choo</author>
<title>The Effect of Fixed-Length Record Implementation on File System Response.</title>
<pages>399-409</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#LeungC82</url>
<abstract>Many file and database management systems are implemented using fixed-length physical records on movable head discs. Such implementation not only causes internal dependence among different components of the file access time, but also induces an external dependence of the overall access time on request input rate. Accordingly, conventional performance estimates are inaccurate here, and the error in using them typically ranges from 10% to 100+% for different loading conditions. This paper presents revised formulae for calculating the file response time, throughput and busy period for such a storage structure. The analysis makes use of the Takács process in queueing theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264159</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Stadel78">
<author>Manfred P. Stadel</author>
<title>Die Zeitkomplexit&auml;t des Normalisierungsproblems bei kontextsensitiven Grammatiken.</title>
<pages>309-329</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Stadel78</url>
<abstract>Sei G eine kontextsensitive Grammatik. Gc∫ bezeichne den kontextfreien Kern von G. In dieser Arbeit wird die Zeitkomplexität des folgenden Problems untersucht. Das NormalisierungsproblemSei τ ein Ableitungsbaum bezüglich Gc∫; ist τ auch ein Ableitungsbaum bezüglich G? Es wird gezeigt, daß im allgemeinen das Normalisierungs-problem NP-vollständig ist. Andererseits gibt es zu jeder kontextsensitiven Sprache L eine kontextsensitive Grammatik G, für welche das Normalisierungsproblem in Polynomzeit lösbar ist.Let G be a Contextsensitive grammar. G cf represents the context free core of G. In this paper the time complexity of the following problem will be discussed. The Normalization ProblemLet τ be a derivation tree with respect to Gc∫; is τ also a derivation tree with respect to G? It is shown that in general the normalization problem is NP-complete. On the other hand, for every context sensitive language L there is a corresponding context sensitive grammar G for which this normalization problem is solvable in polynomial time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289045</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wagner86">
<author>Klaus W. Wagner</author>
<title>The Complexity of Combinatorial Problems with Succinct Input Representation.</title>
<pages>325-356</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#Wagner86</url>
<abstract>Several languages for the succinct representation of the instances of combinatorial problems are investigated. These languages have been introduced in [20, 2] and [5] where it has been shown that describing the instances by these languages causes a blow-up of the complexities of some problems. In the present paper the descriptional power of these languages is compared by estimating the complexities of some combinatorial problems in terms of completeness in suitable classes of the “counting polynomial-time hierarchy” which is introduced here. It turns out that some of the languages are not comparable, unless P=NP Some problems left open in [2] are solved.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289117</ee>
</article>
<article mdate="2005-01-25" key="journals/acta/MahmoudT04">
<author>Hosam M. Mahmoud</author>
<author>Tatsuie Tsukiji</author>
<title>Limit laws for terminal nodes in random circuits with restricted fan-out: a family of graphs generalizing binary search trees.</title>
<pages>99-110</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>We introduce a family of graphs C(n,i,s,a) that generalizes the binary search tree. The graphs represent logic circuits with fan-in i, restricted fan-out s, and arising by n progressive additions of random gates to a starting circuit of a isolated nodes. We show via martingales that a suitably normalized version of the number of terminal nodes in binary circuits converges in distribution to a normal random variate.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0152-0</ee>
<url>db/journals/acta/acta41.html#MahmoudT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Lauesen73"> 
<author>S&oslash;ren Lauesen</author>
<title>Job Scheduling Guaranteeing Reasonable Turn-Around Times.</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>1-11</pages>
<url>db/journals/acta/acta2.html#Lauesen73</url>
<abstract>This report describes the algorithm for job scheduling and resource allocation used in the operating system Boss 2 for RC 4000. Most resources in the system are nonpreemptible, which causes the usual deadlock problems. The algorithm gives modest jobs a short turn-around time and more greedy jobs a correspondingly larger turn-around time. All jobs are guaranteed a finite turn-around time even if an infinite stream of other jobs is fed to the system (i.e. Holt's permanent blocking [7] is prevented). An estimate of the expected finishing time is computed when the job is enrolled. The estimate is updated continuously and is available from all terminals. The algorithm is a modification of the Banker's Algorithm described by Habermann [5]. It pays high attention to turnaround time and less attention to resource utilization.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00571460</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Burton79">
<author>Warren Burton</author>
<title>Generalized Recursive Data Structures.</title>
<pages>95-108</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Burton79</url>
<abstract>Recursive data types are data types which are defined in terms of themselves, such as lists and trees. There is a single access path to each component in a recursive data structure.Generalized recursive data structures may include multiple access paths to some parts of the data structure. Two way lists, threaded trees and circular lists are generalized recursive data types. The extra access paths in a generalized recursive data structure are uniquely determined by the type of the structure and the main paths through the structure.An extension to Pascal in which generalized recursive data structures may be defined is described.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00266046</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bengelloun86">
<author>S. A. Bengelloun</author>
<title>An Incremental Primal Sieve.</title>
<pages>119-125</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#Bengelloun86</url>
<abstract>A new algorithm is presented for finding all primes between 2 and an incrementally increasing value n. The algorithm executes in linear arithmetic time and space. An outline is given to show how previously developed techniques can be applied to improve the efficiency of the algorithm to O(n/loglogn) time and space.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289493</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Monien76">
<author>Burkhard Monien</author>
<title>Transformational Methods and their Application to Complexity Problems.</title>
<pages>95-108</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Monien76</url>
<abstract>NTAPE (log n)=TAPE (log n)⇔There exists a j such that every language accepted by a nondeterministic one-way one-counter automaton is contained in D j. (D j is the family of all languages accepted by deterministic j-head two-way finite automata.)NTAPE (n) =TAPE (n)⇔ There exists a j such that every language L ∉ {1}* accepted by a nondeterministic 5-head two-way finite automaton is contained in D j.\(\mathop U\limits_d\) TIME (n d=TAPE (log n)⇔ There exists a j such that every language accepted by a deterministic 1-head two-way pushdown automaton is contained in D j.f\(\mathop U\limits_d\) TIME (d n)=TAPE (n)⇔There exists a j such that every language L ⊂{1}* accepted by a deterministic 1-head two-way pushdown automaton is contained in D j.D j ≨ D j+1 for all j ε εN.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263746</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Scott94">
<author>Dana S. Scott</author>
<title>A. Nico Habermann 1932-1993.</title>
<pages>1-3</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta31.html#Scott94</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178919</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bird84">
<author>Richard S. Bird</author>
<title>Using Circular Programs to Eliminate Multiple Traversals of Data.</title>
<pages>239-250</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Bird84</url>
<abstract>This paper describes a technique for transforming functional programs that repeatedly traverse a data structure into more efficient alternatives that do not. The transformation makes essential use of lazy evaluation and local recursion (such as provided by letrec, or its equivalent) to build a circular program that, on one pass over the structure, determines the effects of the individual traversals and then combines them.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264249</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/RensinkW01">
<author>Arend Rensink</author>
<author>Heike Wehrheim</author>
<title>Process algebra with action dependencies.</title>
<pages>155-234</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038003/10380155.htm</ee>
<url>db/journals/acta/acta38.html#RensinkW01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BestV84">
<author>Eike Best</author>
<author>Klaus Voss</author>
<title>Free Choice Systems Have Home States.</title>
<pages>89-100</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BestV84</url>
<abstract>This paper contains a proof that live and safe free choice Petri nets have home states. Home states are ones which can be reached from every successor state of the initial state. Liveness means that all actions remain executable, and safeness means that all capacities are finite. The result is interesting because it may help in the analysis of behavioural properties of complex systems. The existence of home states is a strong property which (as we will also show) fails to hold for a slightly generalised class of nets.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289141</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HabelKV89">
<author>Annegret Habel</author>
<author>Hans-J&ouml;rg Kreowski</author>
<author>Walter Vogler</author>
<title>Metatheorems for Decision Problems on Hyperedge Replacement Graph Languages.</title>
<pages>657-677</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta26.html#HabelKV89</url>
<abstract>Is there a graph in the generated language having the property?Do all graphs in the generated language have the property?</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288976</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Mahmoud02">
<author>Hosam M. Mahmoud</author>
<title>The size of random bucket trees via urn models.</title>
<pages>813-838</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>11/12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038011/20380813.htm</ee>
<url>db/journals/acta/acta38.html#Mahmoud02</url>
</article>
<article mdate="2015-08-18" key="journals/acta/SanchezS15">
<author>Alejandro S&aacute;nchez</author>
<author>C&eacute;sar S&aacute;nchez</author>
<title>Parametrized invariance for infinite state processes.</title>
<pages>525-557</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We study the uniform verification problem for infinite state processes. This problem consists of proving that the parallel composition of an arbitrary number of processes running the same program (or a finite collection of programs) satisfies a temporal property. Our practical motivation is to build a general framework for the temporal verification of concurrent datatypes. In this paper we propose a general method for the verification of safety properties of parametrized programs that manipulate complex local and global data, including mutable state in the heap. Our method is based on a clear division between the following two dimensions of the problem: the interaction between executing threads—handled by novel parametrized invariance proof rules, and the data being manipulated—handled by specialized decision procedures. Our proof rules discharge automatically a finite collection of verification conditions. The size of this collection depends only on the size of the program and the specification, but not on the number of processes in any given instance or on the kind of data manipulated. Moreover, all verification conditions are quantifier free, which eases the development of decision procedures for complex data-types on top of off-the-shelf SMT solvers. We prove soundness of our proof rules and illustrate their application in the formal verification of (1) two infinite-state mutual exclusion protocols; (2) shape and functional correctness properties of several concurrent data-types, including fine-grained and non-blocking concurrent lists and queues. We report empirical results using a prototype implementation of the proof rules and decision procedures.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0222-5</ee>
<url>db/journals/acta/acta52.html#SanchezS15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Reps96">
<author>Thomas W. Reps</author>
<title>On the Sequential Nature of Interprocedural Program-Analysis Problems.</title>
<pages>739-757</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta33.html#Reps96</url>
<abstract>• Interprocedural slicing is log-space complete forP.• The problem of obtaining “meet-over-all-valid-paths” solutions to interprocedural versions of distributive dataflow-analysis problems isP-hard.• Obtaining “meet-over-all-valid-paths” solutions to interprocedural versions of distributive dataflow-analysis problems that involve finite sets of dataflow facts (such as the classical “gen/kill” problems) is log-space complete forP.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036473</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BechtoldPS85">
<author>Michael Bechtold</author>
<author>Guy Pujolle</author>
<author>Otto Spaniol</author>
<title>Throughput of a Satellite Channel Communication.</title>
<pages>1-14</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#BechtoldPS85</url>
<abstract>The throughput of a satellite channel communication is depending upon the link protocol. It is well known that the “classical” HDLC protocol is inadequate when applied to satellite links instead of short terrestrial links. Several modifications have been proposed to overcome this problem. The present paper gives an analysis and evaluation of a new class of protocols called “Virtual Subchannel schemes” which splits the satellite link into several components; these subchannels are assigned for transmission in cyclic order and are controlled independently of each other by the classical HDLC procedure.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290142</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GotliebT74"> 
<author>C. C. Gotlieb</author>
<author>Frank Wm. Tompa</author>
<title>Choosing a Storage Schema.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>297-319</pages>
<url>db/journals/acta/acta3.html#GotliebT74</url>
<abstract>In using a general-purpose language such as PL/I, a data base management system such as IMS, or a special-purpose language such as SNOBOL, program designers must decide on strategies for storing their data. This paper contains a description of an algorithm for choosing suitable data linking methods from a class of available storage schemata. Emphasis is placed on specifying the types of parameters which are involved in this choice, such as the volatility of the data, the density of the keys, and the amount of storage available.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263586</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Cremers73"> 
<author>Armin B. Cremers</author>
<title>Normal Forms for Context-Sensitive Grammars.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>59-73</pages>
<url>db/journals/acta/acta3.html#Cremers73</url>
<abstract>In this paper, we mainly study the relation between scattered context grammars, which are an example for regulated context-free rewriting devices, and context-sensitive grammars. Emphasis is laid upon both normal form characterizations of context-sensitive grammars and an argument in how far scattered context grammars are stronger, with respect to generative capacity than unordered scattered context grammars.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288653</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/YangG00">
<author>Bo-Ting Yang</author>
<author>Paul Gillard</author>
<title>The class Steiner minimal tree problem: a lower bound and test problem generation.</title>
<pages>193-211</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037003/00370193.htm</ee>
<url>db/journals/acta/acta37.html#YangG00</url>
</article>
<article mdate="2015-08-27" key="journals/acta/Neraud95"> 
<author>Jean N&eacute;raud</author>
<title>Detecting Morphic Images of a Word on the Rank of a Pattern.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>5</number>
<year>1995</year> 
<pages>477-489</pages>
<url>db/journals/acta/acta32.html#Neraud95</url>
<abstract>We study the general problem which consists in detecting the morphic images of a given word in an arbitrary text. We introduce the concept ofrank of a pattern, which measures the complexity of its recognition in terms of periodicity.This notion leads to improve the general “naive” algorithm. A special class of equations in words is also concerned.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213080</ee>
</article><article mdate="2011-01-11" key="journals/acta/JacobsF88">
<author>Dean Jacobs</author>
<author>Martin S. Feather</author>
<title>Corrections to ``A Synthesis of Several Sorting Algorithms'' by J. Darlington.</title>
<pages>19-23</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#JacobsF88</url>
<abstract>Darlington applied program transformation to derive a number of sorting algorithms. We identify and correct two errors in his derivation of quick sort, one of which causes his resulting algorithm to be non-terminating on some inputs, the other of which could have led to an incorrect algorithm, but is fortuitously eliminated later in his derivation.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915444</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GenrichL73"> 
<author>Hartmann J. Genrich</author>
<author>Kurt Lautenbach</author>
<title>Synchronisationsgraphen</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>143-161</pages>
<url>db/journals/acta/acta2.html#GenrichL73</url>
</article>


<article mdate="2003-11-25" key="journals/acta/FrancescoS98">
<author>Nicoletta De Francesco</author>
<author>Antonella Santone</author>
<title>A Transformation System for Concurrent Processes.</title>
<pages>1037-1073</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035012/80351037.htm</ee>
<url>db/journals/acta/acta35.html#FrancescoS98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CunninghamD85">
<author>Jim Cunningham</author>
<author>A. J. J. Dick</author>
<title>Rewrite Systems on a Lattice of Types.</title>
<pages>149-169</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#CunninghamD85</url>
<abstract>Re-writing systems for partial algebras are developed by modifying the Knuth-Bendix completion algorithm to permit the use of latticestructured domains. Some problems with the original algorithm, such as the treatment of division rings, are overcome conveniently by this means. The use of a type lattice also gives a natural framework for specifying data types in Computer Science without over-specifying error situations. The soundness and meaning of the major concepts involved in re-writing systems are reviewed when applied to such structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264228</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Zuczek76"> 
<author>R. Zuczek</author>
<title>A New Approach to Parallel Computing.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>1-13</pages>
<url>db/journals/acta/acta7.html#Zuczek76</url>
<abstract>This paper presents a model of parallel computing. Six examples illustrate the method of programming. An implementation scheme for programs is also presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265218</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/PetersR87">
<author>Joseph G. Peters</author>
<author>Larry Rudolph</author>
<title>Parallel Approximation Schemes for Subset Sum and Knapsack Problems.</title>
<pages>417-432</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#PetersR87</url>
<abstract>This paper presents parallel approximation schemes for the Subset Sum, 0–1 Knapsack, and several other optimization problems. These algorithms offer a three-way trade-off among parallel time, the accuracy of the solution, and the number of processors used. The maximum numbers of processors which can be usefully employed depend on n (the size of the input), and the accuracy requirement ɛ. The parallel running times of the algorithms are polynomial in both log n and log(1/ɛ) when enough processors are used.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292111</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KapurNRZ91">
<author>Deepak Kapur</author>
<author>Paliath Narendran</author>
<author>Daniel J. Rosenkrantz</author>
<author>Hantao Zhang</author>
<title>Sufficient-Completeness, Ground-Reducibility and their Complexity.</title>
<pages>311-350</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta28.html#KapurNRZ91</url>
<abstract>The sufficient-completeness property of equational algebraic specifications has been found useful in providing guidelines for designing abstract data type specifications as well as in proving inductive properties using the induction-less-induction method. The sufficient-completeness property is known to be undecidable in general. In an earlier paper, it was shown to be decidable for constructor-preserving, complete (canonical) term rewriting systems, even when there are relations among constructor symbols. In this paper, the complexity of the sufficient-completeness property is analyzed for different classes of term rewriting systems. A number of results about the complexity of the sufficient-completeness property for complete (canonical) term rewriting systems are proved: (i) The problem is co-NP-complete for term rewriting systems with free constructors (i.e., no relations among constructors are allowed), (ii) the problem remains co-NP-complete for term rewriting systems with unary and nullary constructors, even when there are relations among constructors, (iii) the problem is provably in “almost” exponential time for left-linear term rewriting systems with relations among constructors, and (iv) for left-linear complete constructor-preserving rewriting systems, the problem can be decided in steps exponential innlogn wheren is the size of the rewriting system. No better lower-bound for the complexity of the sufficient-completeness property for complete (canonical) term rewriting system with nonlinear left-hand sides is known. An algorithm for left-linear complete constructor-preserving rewriting systems is also discussed. Finally, the sufficient-completeness property is shown to be undecidable for non-linear complete term rewriting systems with associative functions. These complexity results also apply to the ground-reducibility property (also called inductive-reducibility) which is known to be directly related to the sufficient-completeness property.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01893885</ee>
</article>
<article mdate="2005-01-25" key="journals/acta/BozapalidisK04">
<author>Symeon Bozapalidis</author>
<author>Antonios Kalampakas</author>
<title>An axiomatization of graphs.</title>
<pages>19-61</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The magmoid of hypergraphs labelled over a finite doubly ranked alphabet, is characterized as the quotient of the free magmoid generated by this alphabet divided by a finite set of equations. Thus a relevant open problem, posed by Engelfriet and Vereijken, is being solved.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0149-8</ee>
<url>db/journals/acta/acta41.html#BozapalidisK04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DeransartJL84">
<author>Pierre Deransart</author>
<author>Martin Jourdan</author>
<author>Bernard Lorho</author>
<title>Speeding up Circularity Tests for Attribute Grammars.</title>
<pages>375-391</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#DeransartJL84</url>
<abstract>We present three improvements to be applied to algorithms testing the circularity of attribute grammars. The first one, originally introduced in [10], discards from the set of graphs attached to a nonterminal symbol those graphs that are included in (“covered by”) others of the same set. The second one, first presented by Chebotar [1], establishes an optimal order for selection of productions and eliminates at each step those graphs that are unnecessary for subsequent stages of the algorithm, thus requiring less time and space. The last one skips recomputations on terminal trees, thus saving time. These three methods can be used alone or together to speed up circularity tests. We also discuss the practical complexity of circularity tests.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264616</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/BackW89">
<author>Ralph-Johan Back</author>
<author>Joakim von Wright</author>
<title>Duality in Specification Languages: A Lattice-Theoretical Approach.</title>
<pages>583-625</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta27.html#BackW89</url>
<abstract>A very general lattice-based language of commands, based on the primitive operations of substitution and test for equality, is constructed. This base language permits unbounded nondeterminism, demonic and angelic nondeterminism. A dual language permitting miracles is constructed. Combining these two languages yields an extended base language which is complete, in the sense that all monotonic predicate tranformers can be constructed in it. The extended base language provides a unifying framework for various specification languages; we show how two Dijkstra-style specification languages can be embedded in it.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00259469</ee>
</article>
<article mdate="2007-06-13" key="journals/acta/BergstraBP07">
<author>Jan A. Bergstra</author>
<author>Inge Bethke</author>
<author>Alban Ponse</author>
<title>Decision problems for pushdown threads.</title>
<pages>75-90</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Threads as contained in a thread algebra emerge from the behavioral abstraction from programs in an appropriate program algebra. Threads may make use of services such as stacks, and a thread using a single stack is called a pushdown thread. Equivalence of pushdown threads is shown decidable whereas pushdown thread inclusion is undecidable. This is again an example of a borderline crossing where the equivalence problem is decidable, whereas the inclusion problem is not.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0040-5</ee>
<url>db/journals/acta/acta44.html#BergstraBP07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Farr94">
<author>Graham Farr</author>
<title>On Problems with Short Certificates.</title>
<pages>479-502</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta31.html#Farr94</url>
<abstract>We consider languages in NP whose certificate size is bounded by a fixed, slowly growing function (sayf (n)) of the input size. The classesf (n)-NP, which are related to classes of Kintala and Fischer, are defined in order to classify such languages. We show that several natural problems, involving Boolean satisfiability, graph colouring and Hamiltonian circuits, are complete forf (n)-NP. Each of our problems is obtained by taking a known NP-complete problem and introducing an ingredient we callforcing, whereby a partial structure is enlarged by a sequence of local improvements. As special cases of these results we obtain some new logspace completeness results for P.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178668</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TrogemannG97">
<author>Georg Trogemann</author>
<author>Matthias Gente</author>
<title>Performance Analysis of Parallel Programs Based on Directed Acyclic Graphs.</title>
<pages>411-428</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta34.html#TrogemannG97</url>
<abstract>Task precedence graphs are widely used for modeling and evaluation of parallel applications. Their nodes represent the subtasks of the parallel program and the edges represent the precedence relations between the subtasks. The execution times of the subtasks are described by random variables and their distributions. In our paper we introduce a new class of distributions, particularly suited for the modeling and evaluation of parallel programs. Exponential polynomials introduced by Sahner and Trivedi have the disadvantage that a large number of parameters is needed for the representation of realistic task execution times, which usually have a small value of variation. We extend this class to derive the class of truncated \(\theta\)-exponential polynomials which allow the representation of realistic task execution times with fewer parameters. Additionally this class of distributions has the advantage that minimum as well as maximum execution times can be guaranteed. Models with a large number of subtasks \(n\) can not be evaluated on a computer using exact analytical methods because of memory requirements and numerical inaccuracies, which accumulate, when the operations of analysis are applied. Using extreme value theory we derive approximate formulas for the parallel independent execution of \(n\) subtasks, a structure, which can be found in every parallel program. The obtained results for truncated and not truncated distributions show, that distributions with an infinite domain are not suitable, particularly for massively parallel structures.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050092</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Drmota02">
<author>Michael Drmota</author>
<title>The variance of the height of digital search trees.</title>
<pages>261-276</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038004/20380261.htm</ee>
<url>db/journals/acta/acta38.html#Drmota02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MannaW81">
<author>Zohar Manna</author>
<author>Richard J. Waldinger</author>
<title>Problematic Features of Programming Languages: A Situational-Calculus Approach.</title>
<pages>371-426</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#MannaW81</url>
<abstract>Certain features of programming languages, such as data structure operations and procedure call mechanisms, have been found to resist formalization by conventional program verification techniques. An alternate approach is presented, based on a “situational calculus,” which makes explicit reference to the states of a computation. For each state, a distinction is drawn between an expression, its value, and the location of the value.Within this conceptual framework, the features of a programming language can be described axiomatically. Programs in the language can then be synthesized, executed, verified, or transformed by performing deductions in this axiomatic system. Properties of entire classes of programs, and of programming languages, can also be expressed and proved in this way. The approach is amenable to machine implementation.In a situational-calculus formalism it is possible to model precisely many “problematic” features of programming languages, including operations on such data structures as arrays, pointers, lists, and records, and such procedure call mechanisms as call by reference, call by value, and call by name. No particular obstacle is presented by aliasing between variables, by declarations, or by recursive procedures.In this paper, we introduce our conceptual framework and present an axiomatic definition of the assignment statement. If suitable restrictions on the programming language are imposed, the well-known Hoare assignment axiom can then be proved as a theorem. However, our definition can also describe the assignment statement of unrestricted programming languages, for which the Hoare axiom does not hold. In forthcoming papers, we apply the situational-calculus framework to the description of data structure operations and procedure call mechanisms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264494</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/DeselK15">
<author>J&ouml;rg Desel</author>
<author>G&ouml;rkem Kilin&ccedil;</author>
<title>Observable liveness of Petri nets.</title>
<pages>153-174</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>Whereas, for Petri nets, the traditional liveness property guarantees that each transition of a Petri net can always occur again, observable liveness requires that, from any reachable marking, each observable transition can be forced to fire by choosing appropriate controllable transitions; hence it is defined for Petri nets with distinguished observable and controllable transitions. We introduce observable liveness and show that this new notion generalizes traditional liveness in various ways. In particular, liveness of a 1-bounded Petri net implies observable liveness, provided the only conflicts that can appear are between controllable transitions. This assumption refers to applications where the uncontrollable part models a deterministic machine (or several deterministic machines), whereas the user of the machine is modeled by the controllable part and can behave arbitrarily.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0218-1</ee>
<url>db/journals/acta/acta52.html#DeselK15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DugganCO96">
<author>Dominic Duggan</author>
<author>Gordon V. Cormack</author>
<author>John Ophel</author>
<title>Kinded Type Inference for Parametric Overloading.</title>
<pages>21-68</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta33.html#DugganCO96</url>
<abstract>Parameteric overloading refers to the combination of parameteric polymorphism and overloading of polymorphic operators. The formal basis for parametric overloading, proposed by Kaes and extended by Wadler and Blott, is based on type predicates. In this paper another approach to type-checking for parameteric overloading is proposed. The resulting type system loosens some of the restrictions required of overload instance types for type-checking, while also providing fresh insight into type-checking for parameteric overloading. In this system, the kind for a type variable characterizes the set of closed type expressions which may be substituted for that variable. A theory of equality and subkinding for this system is presented, and algorithms for emptiness-checking, subkinding and intersection are provided. This kind system is used as the basis for an extension of Milner’s W algorithm for ML-style type inference to kinded type inference. Finally the kinded type system is verified to be sound and complete with respect to the system of type predicates proposed by Wadler and Blott.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050035</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ScheweT99">
<author>Klaus-Dieter Schewe</author>
<author>Bernhard Thalheim</author>
<title>Towards a Theory of Consistency Enforcement.</title>
<pages>97-141</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036002/90360097.htm</ee>
<url>db/journals/acta/acta36.html#ScheweT99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Mehlhorn79">
<author>Kurt Mehlhorn</author>
<title>Some Remarks on Boolean Sums.</title>
<pages>371-375</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Mehlhorn79</url>
<abstract>Neciporuk, Lamagna/Savage and Tarjan determined the monotone network complexity of a set of Boolean sums if any two sums have at most one variable in common. Wegener then solved the case that any two sums have at most k variables in common. We extend his methods and results and consider the case that any set of h +1 distinct sums have at most k variables in common. We use our general results to explicitly construct a set of n Boolean sums over n variables whose monotone complexity is of order n 5/3. The best previously known bound was of order n 3/2. Related results were obtained independently by Pippenger.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268321</ee>
</article>
<article mdate="2013-05-10" key="journals/acta/AizikowitzK13">
<author>Tamar Aizikowitz</author>
<author>Michael Kaminski</author>
<title>Conjunctive grammars and alternating pushdown automata.</title>
<pages>175-197</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>In this paper we introduce a variant of alternating pushdown automata, synchronized alternating pushdown automata, which accept the same class of languages as those generated by conjunctive grammars.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0177-3</ee>
<url>db/journals/acta/acta50.html#AizikowitzK13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/WotschkeW78">
<author>Detlef Wotschke</author>
<author>Celia Wrathall</author>
<title>A Note on Classes of Complements and the LBA Problem.</title>
<pages>169-173</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#WotschkeW78</url>
<abstract>The complements of an AFL ℒ form an AFL if and only if ℒ is closed under “length-preserving” universal quantification. The complements of the context-sensitive languages form a principal AFL with a hardest set L 1. The context-sensitive languages are closed under complementation if and only if L 1 is context-sensitive.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289154</ee>
</article>
<article mdate="2012-08-13" key="journals/acta/FanHTW12">
<author>Chen-Ming Fan</author>
<author>Cheng-Chih Huang</author>
<author>Christine Chifen Tseng</author>
<author>Jen-Tse Wang</author>
<title>Prefix-primitive annihilators of languages under some operations.</title>
<pages>281-293</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>This paper studies some properties of prefix-primitive annihilators of languages under the catenation, shuffle product and bi-catenation operations. We prove that for every finite language L under the catenation operation, the left prefix-primitive annihilator of L is not equal to the right prefix-primitive annihilator of L, the left prefix-primitive annihilator of languages is not regular for any finite language, and the left prefix-primitive annihilator of any thin languages is not empty. Moreover, we also characterize the prefix-primitive annihilators of non-empty language under the shuffle product and bi-catenation operations over the alphabet with two letters.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0159-x</ee>
<url>db/journals/acta/acta49.html#FanHTW12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Woeginger94">
<author>Gerhard J. Woeginger</author>
<title>Heuristics for Parallel Machine Scheduling with Delivery Times.</title>
<pages>503-512</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#Woeginger94</url>
<abstract>A parallel machine scheduling problem is considered in which each job has a processing time and a delivery time. The objective is to find a schedule which minimizes the time by which all jobs are delivered. For a single machine this problem is easily solved in polynomial time, form≥2 machines it becomes NP-hard. Several heuristics using list scheduling as a subroutine are proposed and a tight worst-case analysis is given. The best one of our heuristics has a worst-case performance guarantee of 2−2/(m+1). For the on-line case we give a heuristic with the (best possible) worst-case performance of two.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213203</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Sannella84">
<author>Donald Sannella</author>
<title>A Set-Theoretic Semantics for Clear.</title>
<pages>443-472</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Sannella84</url>
<abstract>A semantics for the Clear specification language is given. The language of set theory is employed to present constructions corresponding to Clear's specification-combining operations, which are then used as the basis for a denotational semantics. This is in contrast to Burstall and Goguen's 1980 semantics which described the meanings of these operations more abstractly via concepts from category theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271641</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Alt79">
<author>Helmut Alt</author>
<title>Lower Bounds on Space Complexity for Contextfree Recognition.</title>
<pages>33-61</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Alt79</url>
<abstract>Using methods from linear algebra and crossing-sequence arguments it is shown that logarithmic space is necessary for the recognition of all context-free nonregular subsets of {a1}* ... {an}*, where {a1,...,an} is some alphabet. It then follows that log n is a lower bound on the space complexity for the recognition of any bounded or deterministic non-regular context-free language.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264016</ee>
</article>
<article mdate="2013-02-05" key="journals/acta/ArroyoCDMS13">
<author>Fernando Arroyo</author>
<author>Juan Castellanos</author>
<author>J&uuml;rgen Dassow</author>
<author>Victor Mitrana</author>
<author>Jos&eacute;-Ram&oacute;n S&aacute;nchez-Couso</author>
<title>Accepting splicing systems with permitting and forbidding words.</title>
<pages>1-14</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this paper we propose a generalization of the accepting splicing systems introduced in Mitrana et al. (Theor Comput Sci 411:2414–2422, 2010). More precisely, the input word is accepted as soon as a permitting word is obtained provided that no forbidding word has been obtained so far, otherwise it is rejected. Note that in the new variant of accepting splicing system the input word is rejected if either no permitting word is ever generated (like in Mitrana et al. in Theor Comput Sci 411:2414–2422, 2010) or a forbidding word has been generated and no permitting word had been generated before. We investigate the computational power of the new variants of accepting splicing systems and the interrelationships among them. We show that the new condition strictly increases the computational power of accepting splicing systems. Although there are regular languages that cannot be accepted by any of the splicing systems considered here, the new variants can accept non-regular and even non-context-free languages, a situation that is not very common in the case of (extended) finite splicing systems without additional restrictions. We also show that the smallest class of languages out of the four classes defined by accepting splicing systems is strictly included in the class of context-free languages. Solutions to a few decidability problems are immediately derived from the proof of this result.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0169-8</ee>
<url>db/journals/acta/acta50.html#ArroyoCDMS13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MannilaR83">
<author>Heikki Mannila</author>
<author>Kari-Jouko R&auml;ih&auml;</author>
<title>On the Relationship of Minimum and Optimum Covers for a Set of Functional Dependencies.</title>
<pages>143-158</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#MannilaR83</url>
<abstract>Most algorithms in relational database theory use a set of functional dependencies as their input. The efficiency of the algorithms depends on the size of the set. The notions of a minimum set (with as few dependencies as possible) and an optimum set (which is as short as possible) were introduced by Maier. He showed that while a minimum cover for a given set of dependencies can be found in polynomial time, obtaining an optimum cover is an NP-complete problem. Here the relationship of these covers is explored further. It is shown that the length of a minimum set (i) cannot be bounded by a linear function on the length of an optimum cover, and (ii) is bounded by the square of the length of an optimum cover. It is also shown that the NP-completeness of the optimization problem is somewhat surprisingly caused solely by the difficulty of optimizing a single class of dependencies having equivalent left sides, not by the globality of the optimality condition. This result has some practical significance, since the equivalence classes appearing in practice are short. The problem of optimizing an equivalence class is studied and left and right sides of a dependency are shown to behave differently. A new representation for equivalence classes based on this observation is suggested. The optimization of single dependencies is shown to be NP-complete, and a method to produce good approximations is given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289412</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Ben-AriPM83">
<author>Mordechai Ben-Ari</author>
<author>Amir Pnueli</author>
<author>Zohar Manna</author>
<title>The Temporal Logic of Branching Time.</title>
<pages>207-226</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Ben-AriPM83</url>
<abstract>A temporal logic is defined which contains both linear and branching operators. The underlying model is the tree of all possible computations. The following metatheoretical results are proven: 1) an exponential decision procedure for satisfiability; 2) a finite model property; 3) the completeness of an axiomatization.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01257083</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wegener81">
<author>Ingo Wegener</author>
<title>An Improved Complexity Hierarchy on the Depth of Boolean Functions.</title>
<pages>147-152</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Wegener81</url>
<abstract>Circuit depth is an important complexity measure for a Boolean function. Let some Boolean function of n variables have depth k according to an arbitrary binary basis Ω. For each j where [log n]≦j≦k we prove the existence of a Boolean function f with the following properties. f depends essentially on n variables and the depth of f according to Ω is exactly j Thus we state the best possible hierarchy result on the depth of all nondegenerate Boolean functions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288962</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/DeganoPLT99">
<author>Pierpaolo Degano</author>
<author>Corrado Priami</author>
<author>Lone Leth</author>
<author>Bent Thomsen</author>
<title>Causality for Debugging Mobile Agents.</title>
<pages>335-374</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036005/90360335.htm</ee>
<url>db/journals/acta/acta36.html#DeganoPLT99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FrancescoI94">
<author>Nicoletta De Francesco</author>
<author>Paola Inverardi</author>
<title>Proving Finiteness of CCS Processes by Non-Standard Semantics.</title>
<pages>55-80</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta31.html#FrancescoI94</url>
<abstract>We present a semantic method to check the finiteness of CCS terms. The method is interpretative, i.e. it is based on a non-standard CCS operational semantics. According to this semantics it is always possible, given a processp, to build a finite state transition system which, if a condition holds, is a finite representation ofp; otherwise it is a suitable approximation of its semantic behaviour. The method is able to decide the finiteness of a CCS term in a larger number of cases than those captured by known syntactic criteria.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178922</ee>
</article>
<article mdate="2012-03-08" key="journals/acta/MedunaZ12">
<author>Alexander Meduna</author>
<author>Petr Zemek</author>
<title>Nonterminal complexity of one-sided random context grammars.</title>
<pages>55-68</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>In the present paper, we study the nonterminal complexity of one-sided random context grammars. More specifically, we prove that every recursively enumerable language can be generated by a one-sided random context grammar with no more than ten nonterminals. An analogical result holds for thirteen nonterminals in terms of these grammars with the set of left random context rules coinciding with the set of right random context rules. Furthermore, we introduce the notion of a right random context nonterminal, defined as a nonterminal that appears on the left-hand side of a right random context rule. We demonstrate how to convert any one-sided random context grammar G to an equivalent one-sided random context grammar H with two right random context nonterminals. An analogical conversion is given in terms of (1) propagating one-sided random context grammars and (2) left random context nonterminals. In the conclusion, two open problems are stated.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0150-6</ee>
<url>db/journals/acta/acta49.html#MedunaZ12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KapurNZ87">
<author>Deepak Kapur</author>
<author>Paliath Narendran</author>
<author>Hantao Zhang</author>
<title>On Sufficient-Completeness and Related Properties of Term Rewriting Systems.</title>
<pages>395-415</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#KapurNZ87</url>
<abstract>The decidability of the sufficient completeness property of equational specifications satisfying certain conditions is shown. In addition, the decidability of the related concept of quasi-reducibility of a term with respect to a set of rules is proved. Other results about irreducible ground terms of a term rewriting system also follow from a key technical lemma used in these decidability proofs; this technical lemma states that there is a finite bound on the substitutions of ground terms that need to be considered in order to check for a given term, whether the result obtained by any substitution of ground terms into the term is irreducible. These results are first shown for untyped systems and are subsequently extended to typed systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292110</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Knuth71"> 
<author>Donald E. Knuth</author>
<title>Optimum Binary Search Trees.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>14-25</pages>
<url>db/journals/acta/acta1.html#Knuth71</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264289</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/IglehartS84">
<author>Donald L. Iglehart</author>
<author>Gerald S. Shedler</author>
<title>Simulation Output Analysis for Local Area Computer Networks.</title>
<pages>321-338</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#IglehartS84</url>
<abstract>This paper develops discrete event simulation methods for local area computer networks. We restrict attention to local network simulations with an underlying stochastic process that can be represented as a generalized semi-Markov process. Using a “geometric trials” criterion for recurrence, we establish a regenerative process structure for passage times in this setting. This leads to an estimation procedure for delay characteristics of ring and bus networks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264614</ee>
</article>
<article mdate="2010-10-25" key="journals/acta/DaxKL10">
<author>Christian Dax</author>
<author>Felix Klaedtke</author>
<author>Martin Lange</author>
<title>On regular temporal logics with past.</title>
<pages>251-277</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>The IEEE standardized Property Specification Language, PSL for short, extends the well-known linear-time temporal logic LTL with so-called semi-extended regular expressions. PSL and the closely related SystemVerilog Assertions, SVA for short, are increasingly used in many phases of the hardware design cycle, from specification to verification. In this article, we extend the common core of these specification languages with past operators. We name this extension PPSL. Although all ω-regular properties are expressible in PSL, SVA, and PPSL, past operators often allow one to specify properties more naturally and concisely. In fact, we show that PPSL is exponentially more succinct than the cores of PSL and SVA. On the star-free properties, PPSL is double exponentially more succinct than LTL. Furthermore, we present a translation of PPSL into language-equivalent nondeterministic Büchi automata, which is based on novel constructions for 2-way alternating automata. The upper bound on the size of the resulting nondeterministic Büchi automata obtained by our translation is almost the same as the upper bound for the nondeterministic Büchi automata obtained from existing translations for PSL and SVA. Consequently, the satisfiability problem and the model-checking problem for PPSL fall into the same complexity classes as the corresponding problems for PSL and SVA.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0118-3</ee>
<url>db/journals/acta/acta47.html#DaxKL10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LodayaS90">
<author>Kamal Lodaya</author>
<author>R. K. Shyamasundar</author>
<title>Proof Theory for Exception Handling in a Tasking Environment.</title>
<pages>7-41</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta28.html#LodayaS90</url>
<abstract>In this paper, we develop a syntax-directed proof system for a fragment of Ada consisting of the essential features of tasking and exception handling. The proof system is based on a correctness formula for therobust specification of single-entry-multiple-exit structures that provides a unified framework for exception handling mechanisms in the presence of nondeterminism, concurrency and communication. The proof system uses the technique ofco-operating proofs, which was developed for proving the correctness of communicating sequential processes [AFD80] and extended to a concurrent fragment of Ada in [GD84]. We build upon the latter. The soundness and completeness are established formally in [Lod87]. The proof rules are structured so that exceptions can be used as a structured escape mechanism in accordance with the design objectives of Ada. Examples are given to show how the rules highlight the annotation required for establishing the robustness of Ada programs.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02983373</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PettorossiB82">
<author>Alberto Pettorossi</author>
<author>Rod M. Burstall</author>
<title>Deriving very Efficient Algorithms for Evaluating Linear Recurrence Relations Using the Program Transformation Technique.</title>
<pages>181-206</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#PettorossiB82</url>
<abstract>Using the program transformation technique we derive some algorithms for evaluating linear recurrence relations in logarithmic time. The particular case of the Fibonacci function is first considered and a comparison with the conventional matrix exponentiation algorithm is made. This comparison allows us also to contrast the transformation technique and the stepwise refinement technique underlining some interesting features of the former one. Through the examples given we also explain why those features are interesting for a useful and reliable program construction methodology.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264438</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rozenberg72"> 
<author>Grzegorz Rozenberg</author>
<title>Direction Controlled Programmed Grammars.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>242-252</pages>
<url>db/journals/acta/acta1.html#Rozenberg72</url>
<abstract>A generalization of the notion of a context-free grammar is presented here. It is based on the notion of a programmed grammar. When the underlying context-free rules do not contain erasing, the class of languages obtained is identical with the class of context-sensitive languages. With underlying context-free rules containing erasing one obtains the class of recursively enumerable languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288688</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/LeeLW86">
<author>C. C. Lee</author>
<author>D. T. Lee</author>
<author>C. K. Wong</author>
<title>Generating Binary Trees of Bounded Height.</title>
<pages>529-544</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#LeeLW86</url>
<abstract>We present a new encoding scheme for binary trees with n internal nodes whose heights are bounded by a given value h, h≧⌈log2(n +1)1⌉. The scheme encodes the internal nodes of the tree level by level and enables us to develop an algorithm for generating all binary trees within this class in a certain predetermined order. Specifically, the trees are generated in decreasing height and for trees of the same height they are generated in lexicographically increasing order. The algorithm can be easily generalized to encompass t-ary trees with bounded height. It is then shown that the average generation time per tree is constant (independent of n and h).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288468</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/JajaS82">
<author>Joseph J&aacute;J&aacute;</author>
<author>Janos Simon</author>
<title>Space Efficient Algorithms for Some Graph Theoretical Problems.</title>
<pages>411-423</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#JajaS82</url>
<abstract>We present space-efficient-O(log2 n)-deterministic algorithms for some graph theoretical problems such as planarity testing, producing a plane embedding, finding minimum cost spanning trees, obtaining the connected, biconnected and triconnected components of a graph. Previous planarity algorithms used Ω(n) space. Several algorithms are based on a space-efficient matrix inversion method. The same bounds hold for uniform circuit depth.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264160</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Takeichi87">
<author>Masato Takeichi</author>
<title>Partial Parametrization Eliminates Multiple Traversals of Data Structures.</title>
<pages>57-77</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta24.html#Takeichi87</url>
<abstract>The use of higher order functions in functional programming opens up the possibility of defining functions by partial parametrization, and lazy evaluation brings out a new approach in programming methodology. This paper describes a new transformation technique based on partial parametrization and fully lazy evaluation for eliminating multiple traversais of data structures. It uses no particular mechanisms in functional programming, whereas it transforms a wider class of programs into efficient ones than that proposed so far.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290706</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Ehrich74a"> 
<author>Hans-Dieter Ehrich</author>
<title>Grundlagen einer Theorie der Datenstrukturen und Zugriffssysteme. Teil II: Zugriffssysteme.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>299-310</pages>
<url>db/journals/acta/acta4.html#Ehrich74a</url>
<abstract>In part I of this paper, a mathematical model for data structures has been presented. Based on this model and on a corresponding formalized notion of retrieval operation, a model for storage access systems is introduced, which is called a Q-system. Equivalence, separation, and decomposition of Q-systems are studied, resulting in a set of basic principles for transforming Q-systems. These can be used for a systematical description of practical storage access systems for multi-attribute-retrieval.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289613</ee>
</article>

<article mdate="2010-12-28" key="journals/acta/KutribMO10">
<author>Martin Kutrib</author>
<author>Hartmut Messerschmidt</author>
<author>Friedrich Otto</author>
<title>On stateless deterministic restarting automata.</title>
<pages>391-412</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The transitions of a stateless automaton do not depend on internal states but solely on the symbols currently scanned by its head accessing the input and memory. We investigate stateless deterministic restarting automata that, after executing a rewrite step, continue to read their tape before performing a restart. Even the weakest class thus obtained contains the regular languages properly. The relations between different classes of stateless automata as well as between stateless automata and the corresponding types of automata with states are investigated, and it is shown that the language classes defined by the various types of deterministic stateless restarting automata without auxiliary symbols are anti-AFLs that are not even closed under reversal.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0125-4</ee>
<url>db/journals/acta/acta47.html#KutribMO10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ReuschM86">
<author>Bernd Reusch</author>
<author>Wolfgang Merzenich</author>
<title>Minimal Coverings for Incompletely Specified Sequential Machines.</title>
<pages>663-678</pages>
<year>1986</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta22.html#ReuschM86</url>
<abstract>In the literature the problem of finding minimal realizations for incompletely specified machines has been treated in a number of different ways. Solutions to this problem depend on the precise definition of what minimal realization means in this case. If the behaviour of a state is definied as its related partial input-output function then the behaviour of one machine A can cover the behaviour of another machine B if it contains better definied I/O functions for all states of B. Finding a minimal covering in this case is known to be NP-complete. We develop an algebraic treatment of the problem and give a homomorphic characterization of the covering-relation. The construction of state-splitting is also characterized as a special morphism. Then a heuristic method is proposed for finding minimal coverings.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263650</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GeistSTD86">
<author>Robert Geist</author>
<author>Mark Smotherman</author>
<author>Kishor S. Trivedi</author>
<author>Joanne Bechta Dugan</author>
<title>The Reliability of Life-Critical Computer Systems.</title>
<pages>621-642</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#GeistSTD86</url>
<abstract>In order to aid the designers of life-critical, fault-tolerant computing systems, accurate and efficient methods for reliability prediction are needed. The accuracy requirement implies the need to model the system in great detail, and hence the need to address the problems of large state space, non-exponential distributions, and error analysis. The efficiency requirement implies the need for new model solution techniques, in particular the use of decomposition/aggregation in the context of a hybrid model. We describe a model for reliability prediction which meets both requirements. Specifically, our model is partitioned into fault occurrence and fault/error handling submodels, which are represented by non-homogeneous Markov processes and extended stochastic Petri nets, respectively. The overall aggregated model is a stochastic process that is solved by numerical techniques. Methods to analyze the effects of variations in input parameters on the resulting reliability predictions are also provided.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264310</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/KhardonMR99">
<author>Roni Khardon</author>
<author>Heikki Mannila</author>
<author>Dan Roth</author>
<title>Reasoning with Examples: Propositional Formulae and Database Dependencies.</title>
<pages>267-286</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036004/90360267.htm</ee>
<url>db/journals/acta/acta36.html#KhardonMR99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Whaley91">
<author>Thomas P. Whaley</author>
<title>Postorder Trees and Eulerian Numbers.</title>
<pages>703-712</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#Whaley91</url>
<abstract>Binary search trees built from the postorder traversal sequence of other binary search trees are characterized in terms of their binary tree structure. A connection is established between this structure and the Eulerian numbers. This yields considerable information concerning the “average” binary search tree with a given number of nodes. Periodicity is established for the process of repeatedly taking postorder sequences and building binary search trees. Finally, the average depth of a node in a postorder tree withn nodes is determined.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178684</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AdlemanBPR78">
<author>Leonard M. Adleman</author>
<author>Kellogg S. Booth</author>
<author>Franco P. Preparata</author>
<author>Walter L. Ruzzo</author>
<title>Improved Time and Space Bounds for Boolean Matrix Multiplication.</title>
<pages>61-77</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#AdlemanBPR78</url>
<abstract>Using modular arithmetic we obtain the following improved bounds on the time and space complexities for n × n Boolean matrix multiplication: O(n log 2 7 lognlogloglognloglogloglogn) bit operations and O(n 2loglog n) bits of storage on a logarithmic cost RAM having no multiply or divide instruction; O(n log 2 7(logn)2−1/2log 2 7(loglog n)1/2log 2 7−1) bit operations and O(n 2log n) bits of storage on a RAM which can use indirect addressing for table lookups. The first algorithm can be realized as a Boolean circuit with O(n log 2 7lognlogloglognloglogloglogn) gates. Whenever n×n arithmetic matrix multiplication can be performed in less than O(n log 2 7) arithmetic operations, our results have corresponding improvements.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264600</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Schenke99">
<author>Michael Schenke</author>
<title>Transformational Design of Real-Time Systems. Part II: From Program Specifications to Programs.</title>
<pages>67-96</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036001/90360067.htm</ee>
<url>db/journals/acta/acta36.html#Schenke99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DadunaS81">
<author>Hans Daduna</author>
<author>Rolf Schassberger</author>
<title>A Discrete-Time Round-Robin Queue with Bernoulli Input and General Arithmetic Service Time Distributions.</title>
<pages>251-263</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#DadunaS81</url>
<abstract>We present a discrete-time round-robin queue with a last-in-first-served rule: a newly arriving job receives a quantum of service immediately and only thereafter joins the tail of the queue. For Bernoulli input and general arithmetic service times we compute steady-state probabilities and mean response times.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289264</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Book79">
<author>Ronald V. Book</author>
<title>On Languages Accepted by Space-Bounded Oracle Machines.</title>
<pages>177-185</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Book79</url>
<abstract>Characterizations of classes of languages accepted by space-bounded oracle machines are developed. These characterizations are given in terms of the regular sets, certain information about the oracle set, and certain algebraic closure operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00266049</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HoareHS93">
<author>C. A. R. Hoare</author>
<author>Jifeng He</author>
<author>Augusto Sampaio</author>
<title>Normal Form Approach to Compiler Design.</title>
<pages>701-739</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta30.html#HoareHS93</url>
<abstract>This paper demonstrates how reduction to normal form can help in the design of a correct compiler for Dijkstra's guarded command language. The compilation strategy is to transform a source program, by a series of algebraic manipulations, into a normal form that describes the behaviour of a stored-program computer. Each transformation eliminates high-level language constructs in favour of lower-level constructs. The correctness of the compiler follows from the correctness of each of the algebraic transformations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191809</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Walter76"> 
<author>Hermann K.-G. Walter</author>
<title>Grammarforms and Grammarhomomorphisms.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>75-93</pages>
<url>db/journals/acta/acta7.html#Walter76</url>
<abstract>We show that grammar forms, introduced by S. Ginsburg, can be treated with the help of grammar homomorphisms, introduced by G. Hotz. This gives us the possibility to generalize the notion of grammar forms in such a way that we can prove closure properties of the associated language family using some simple axioms by diagram chasing. Moreover we demonstrate a principle of duality in dealing with this theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265222</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/PenabadBHP02">
<author>Miguel R. Penabad</author>
<author>Nieves R. Brisaboa</author>
<author>H&eacute;ctor J. Hern&aacute;ndez</author>
<author>Jos&eacute; R. Param&aacute;</author>
<title>A general procedure to check conjunctive query containment.</title>
<pages>489-529</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038007/20380489.htm</ee>
<url>db/journals/acta/acta38.html#PenabadBHP02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Schoett92">
<author>Oliver Schoett</author>
<title>Two Impossibility Theorems on Behaviour Specification of Abstract Data Types.</title>
<pages>595-621</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#Schoett92</url>
<abstract>Two kinds of finite specification of the behaviour of a counter data type are proved impossible.We consider the class of data types (many-sorted algebras) behaving like an encapsulated counter that can be observed only by a test for zero. It is shown that no nonempty subclass of this class can be finitely specified in “observational first-order logic”, which is a variant of first-order logic in which equality may not be used on encapsulated types. Secondly, it is shown that the class cannot be described exactly by a finite specification in first-order logic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185563</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wegener80">
<author>Ingo Wegener</author>
<title>A new Lower Bound on the Monotone Network Complexity of Boolean Sums.</title>
<pages>109-114</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Wegener80</url>
<abstract>Neciporuk [3], Lamagna/Savage [1] and Tarjan [6] determined the monotone network complexity of a set of Boolean sums if each two sums have at most one variable in common. By this result they could define explicitely a set of n Boolean sums which depend on n variables and whose monotone complexity is of order n 3/2. In the main theorem of this paper we prove a more general lower bound on the monotone network complexity of Boolean sums. Our lower bound is for many Boolean sums the first nontrivial lower bound. On the other side we can prove that the best lower bound which the main theorem yields is the n 3/2-bound cited above. For the proof we use the technical trick of assuming that certain functions are given for free.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263988</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/KobuchiSN00">
<author>Youichi Kobuchi</author>
<author>Takashi Saito</author>
<author>Hidenobu Nunome</author>
<title>Semantics analysis through elementary meanings.</title>
<pages>1-19</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037001/00370001.htm</ee>
<url>db/journals/acta/acta37.html#KobuchiSN00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Chazelle87">
<author>Bernard Chazelle</author>
<title>Some Techniques for Geometric Searching with Implicit Set Representations.</title>
<pages>565-582</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#Chazelle87</url>
<abstract>There are many efficient ways of searching a set when all its elements can be represented in memory. Often, however, the domain of the search is too large to have each element stored separately, and some implicit representation must be used. Whether it is still possible to search efficiently in these conditions is the underlying theme of this paper. We look at several occurrences of this problem in computational geometry and we propose various lines of attack. In the course of doing so, we improve the solutions of several specific problems; for example, computing order statistics, performing polygonal range searching, testing algebraic predicates, etc.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263295</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Tsakalidis87">
<author>Athanasios K. Tsakalidis</author>
<title>The Nearest Common Ancestor in a Dynamic Tree.</title>
<pages>37-54</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta25.html#Tsakalidis87</url>
<abstract>We consider the problem of determining the nearest common ancestor of two given nodes x and y (denoted by nca(x, y)) in a dynamic arbitrary tree T. We present an implementation of T by a pointer machine which needs linear space, performs m arbitrary insertions and deletions in the initially empty tree T in time O(m) and a query about nca(x, y) can be answered on-line in time O(log(min{depth(x), depth(y))+α(k,k))}, where the second factor is amortized over k queries, α is a functional inverse of Ackermann's function and depth(x) the distance from node x to the root of T.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF00268844</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/JurgensenS95"> 
<author>Helmut J&uuml;rgensen</author>
<author>Ludwig Staiger</author>
<title>Local Hausdorff Dimension.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>5</number>
<year>1995</year> 
<pages>491-507</pages>
<url>db/journals/acta/acta32.html#JurgensenS95</url>
<abstract>We define the notion of local size-measure in metric spaces and derive general properties of local size-measures. Special cases include the local Hausdorff dimension, the local entropy, and the local Kolmogorov complexity. For the case of finite-state and closed ω-languages we exhibit an algorithm for the approximate calculation of the local Hausdorff dimension using the fact that, in this case, the local Hausdorff dimension and the local entropy coincide.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213081</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/ColemanH79">
<author>Derek Coleman</author>
<author>Jane W. Hughes</author>
<title>The Clean Termination of Pascal Programs.</title>
<pages>195-210</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#ColemanH79</url>
<abstract>The axiomatic definition of PASCAL takes no account of the finite bounds of real computers. It is proposed that the bounds of differing machines may be accounted for in the PASCAL definition by the use of an axiom schema with machine dependent parameters. If these parameters are available to the program prover and to the program it is possible to prove the clean termination of a program on a particular bounded machine. The use of a parameterised definition for all PASCAL machines, means that clean termination can be guaranteed over a range of machines. In particular a programmer may prove his program against a set of bounds chosen for ease of proof, as long as the implemented machine is “larger”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289066</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SupowitR82">
<author>Kenneth J. Supowit</author>
<author>Edward M. Reingold</author>
<title>The Complexity of Drawing Trees Nicely.</title>
<pages>377-392</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#SupowitR82</url>
<abstract>We investigate the complexity of producing aesthetically pleasing drawings of binary trees, drawings that are as narrow as possible. The notion of what is aesthetically pleasing is embodied in several constraints on the placement of nodes, relative to other nodes. Among the results we give are: (1) There is no obvious “principle of optimality” that can be applied, since globally narrow, aesthetic placements of trees may require wider than necessary subtrees. (2) A previously suggested heuristic can produce drawings on n-node trees that are Θ(n) times as wide as necessary. (3) The problem can be reduced in polynomial time to linear programming; hence, if the coordinates assigned to the nodes are continuous variables, then the problem can be solved in polynomial time. (4) If the placement is restricted to the integral lattice then the problem is NP-hard, as is its approximation to within a factor of about 4 per cent.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289576</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SurS95"> 
<author>Sumit Sur</author>
<author>Pradip K. Srimani</author>
<title>IEH Graphs. A Novel Generalization of Hypercube Graphs.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>6</number>
<year>1995</year> 
<pages>597-609</pages>
<url>db/journals/acta/acta32.html#SurS95</url>
<abstract>We propose a new family of interconnection topology that can be used to design communication architecture for distributed systems with an arbitrary number of computing nodes. The design is based on a novel generalization of the well known hypercube graphs. The proposed topology is shown to be incrementally extensible in steps of 1 (cost of restructuring or adding edges is very low), optimally fault tolerant and its diameter is logarithmic in the number of nodes. Moreover, for any given number of nodes, the difference of the maximum and the minimum degree of a node in the graph is ≤1, i.e., the graph is almost regular. A shortest routing algorithm for the proposed family of graphs has been developed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178908</ee>
</article>

<article mdate="2015-02-04" key="journals/acta/BestD15">
<author>Eike Best</author>
<author>Raymond R. Devillers</author>
<title>Synthesis and reengineering of persistent systems.</title>
<pages>35-60</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In formal verification, a structural object, such as a program or a Petri net, is given, and questions are asked about its behaviour. In system synthesis, conversely, a behavioural object, such as a transition system, is given, and questions are asked about the existence of a structural object realising this behaviour. In system reengineering, one wishes to transform a given system into another one, with similar behaviour and other properties not enjoyed by the original system. This paper addresses synthesis and reengineering problems in the specific framework of finite-state labelled transition systems, place/transition Petri nets, and behaviour isomorphisms. Since algorithms solving these problems are prohibitively time-consuming in general, it is interesting to know whether they can be improved in restricted circumstances, and whether direct correspondences can be found between classes of behavioural and classes of structural objects. This paper is concerned with persistent systems, which occur in hardware design and in various other applications. We shall derive exact conditions for a finite persistent transition system to be isomorphically implementable by a bounded Petri net exhibiting persistence in a structural way, and derive an efficient algorithm to find such a net if one exists. For the class of marked graph Petri nets, this leads to an exact characterisation of their state spaces.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0209-7</ee>
<url>db/journals/acta/acta52.html#BestD15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Sen89">
<author>Arunabha Sen</author>
<title>Supercube: An Optimally Fault Tolerant Network Architecture.</title>
<pages>741-748</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#Sen89</url>
<abstract>A new class of interconnection network topology is proposed for parallel and distributed processing. The attractive features of this class include (a) the network can be constructed for any number of computing nodes, (b) the network is incrementally expandable, i.e., a new node can easily be added to the existing network, (c) it has good fault-tolerant characteristics (measured by the connectivity of the network graph) and (d) it has small delay characteristics (measured by the diameter of the network graph). The node connectivity of the network is equal to the minimum node degree. In this sense the network is optimally fault-tolerant.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289159</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Senizergues96">
<author>G&eacute;raud S&eacute;nizergues</author>
<title>On the Rational Subsets of the Free Group.</title>
<pages>281-296</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta33.html#Senizergues96</url>
<abstract>We show that every rational subset of a free group of finite rank is either disjunctive or has finite index. We then generalise this result to virtually free groups: if G is virtually free and R is a rational subset of G, then the syntactic normal subgroup N of R is either finite or has finite index.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050045</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LecarmeD74"> 
<author>Olivier Lecarme</author>
<author>Pierre Desjardins</author>
<title>More Comments on the Programming Language Pascal.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>231-243</pages>
<url>db/journals/acta/acta4.html#LecarmeD74</url>
<abstract>A. N. Habermann recently published some “Critical comments on the programming language Pascal”. His reproaches are principally that numerous constructs are ill-defined, that there is “confusion” amongst ranges, types and structures, and that the goto statement should have been abolished. The present reply successively deals with points that are clearly refutable, those which are debatable and those which constitute valid criticism. Its principal aim is to encourage the reader to form his own opinion.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288728</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/PaulR80">
<author>Wolfgang J. Paul</author>
<author>R&uuml;diger Reischuk</author>
<title>On Alternation II. A Graph Theoretic Approach to Determinism Versus Nondeterminism.</title>
<pages>391-403</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#PaulR80</url>
<abstract>Every deterministic t(n)-time bounded multitape Turing machine can be simulated by an alternating t(n) loglog t(n)/log t(n)-time bounded Turing machine.If the depth of every directed acyclic graph with n edges can be reduced to log n by removing only o(n) edges, then in linear time nondeterministic multitape Turing machines can recognize mor languages than deterministic multitape Turing machines. For some graphs reduction of the depth to log n requires the removal of Ω(n/loglog n) edges. A graph theoretic condition is given, which implies that obliviousness reduces the power of multitape Turing machines.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286494</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AutebertG89">
<author>Jean-Michel Autebert</author>
<author>Joaquim Gabarr&oacute;</author>
<title>Iterated GSMs and Co-CFL.</title>
<pages>749-769</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#AutebertG89</url>
<abstract>We study the infinite words generated by an iterated gsm. The motivation was two fold. The first one was given by the apparent similarity between the iterated gsm and the iterated morphism. However contrary to the appearences almost all questions become undecidable. The second one was to disprove the following conjecture of Berstel: The language of coprefixes of an infinite word w is context free iff w is generated by an iterated gsm. We use for that the infinite word: w = abca2 ba 2 bca 4 ba 4 ba 2 ba 4 bc ... (a 2n b)2n c .... We prove also that the degree of the ambiguity problem for coprefixes of iterated gsm is Π 1-complete in the Kleene hierarchy. This result fills the gap between the degree of this problem for iterated morphisms which is Π 0 and for arbitrary context-free grammars which is Π 2-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289160</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AcetoM96">
<author>Luca Aceto</author>
<author>David Murphy</author>
<title>Timing and Causality in Process Algebra.</title>
<pages>317-350</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta33.html#AcetoM96</url>
<abstract>There has been considerable controversy in concurrency theory between the ‘interleaving’ and ‘true concurrency’ schools. The former school advocates associating a transition system with a process which captures concurrent execution via the interleaving of occurrences; the latter adopts more complex semantic structures to avoid reducing concurrency to interleaving.In this paper we show that the two approaches are not irreconcilable. We define a timed process algebra where occurrences are associated with intervals of time, and give it a transition system semantics. This semantics has many of the advantages of the interleaving approach; the algebra admits an expansion theorem, and bisimulation semantics can be used as usual. Our transition systems, however, incorporate timing information, and this enables us to express concurrency: merely adding timing appropriately generalises transition systems to asynchronous transition systems, showing that time gives a link between true concurrency and interleaving. Moreover, we can provide a complete axiomatisation of bisimulation for our algebra; a result that is often problematic in a timed setting.Another advantage of incorporating timing information into the calculus is that it allows a particularly simple definition of action refinement; this we present. The paper concludes with a comparison of the equivalence we present with those in the literature, and an example system specification in our formalism.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050047</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PurdomB80">
<author>Paul Walton Purdom Jr.</author>
<author>Cynthia A. Brown</author>
<title>Semantic Routines and <i> LR(k) </i> Parsers.</title>
<pages>299-315</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#PurdomB80</url>
<abstract>Most applications of parsing require that the parser call semantic action routines while processing the input. For LR(k) parsers it is well known that a semantic action routine can be called when the end of a production is recognized. Often, however, it is desirable to call routines at other times.This paper presents fast algorithms that determine, for an LR(k) (or SLR(k)) grammar, which positions are suitable for calling routines. The algorithms are practical for use with LR(1) (SLR(1)) parser building programs, because the worst case running time is dominated by the time required to build the LR(1) (SLR(1)) parser. Applications of the algorithms to attribute grammars and automatic indentation are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286489</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LucaV94">
<author>Aldo de Luca</author>
<author>Stefano Varricchio</author>
<title>Well Quasi-Orders and Regular Languages.</title>
<pages>539-557</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#LucaV94</url>
<abstract>An extension of Myhill's theorem of automata theory, due to Ehrenfeucht et al. [4] shows that a subsetX of a semigroupsS is recognizable if and only ifX is closed with respect to a monotone well quasi-order onS. In this paper we prove that a similar extension of Nerode's theorem is not possible by showing that there exist non-regular languages on a binary alphabet which are closed with respect to a right-monotone well quasi-order. We give then some additional conditions under which a setX S closed with respect to a right-monotone well quasi-order becomes recognizable. We prove the following main proposition: A subsetX ofS is recognizable if and only ifX is closed with respect to two well quasi-orders<=1 and<=2 which are right-monotone and left-monotone, respectively. Some corollaries and applications are given. Moreover, we consider the family ℱ of all languages which are closed with respect to a right-monotone well quasi-order on a finitely generated free monoid. We prove that ℱ is closed under rational operations, intersection, inverse morphisms and direct non-erasing morphisms. This implies that ℱ is closed under faithful rational transductions. Finally we prove that the languages in ℱ satisfy a suitable ‘pumping’ lemma and that ℱ contains languages which are not recursively enumerable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213206</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KuckM74"> 
<author>David J. Kuck</author>
<author>Yoichi Muraoka</author>
<title>Bounds on the Parallel Evaluation of Arithmetic Expressions Using Associativity and Commutativity.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>203-216</pages>
<url>db/journals/acta/acta3.html#KuckM74</url>
<abstract>We show that any arithmetic expression with n operands and parentheses nested to depth d can be evaluated in at most 1+2d+ [log2 n] steps, assuming that only associativity and commutativity are used to transform the expression. We also show that at most [n−2d/2] processors are needed to achieve this bound.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288634</ee>
</article>

<article mdate="2004-03-03" key="journals/acta/BiskupP03">
<author>Joachim Biskup</author>
<author>Torsten Polle</author>
<title>Adding inclusion dependencies to an object-oriented data model with uniqueness constraints.</title>
<pages>391-449</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract></abstract>
<ee>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0001-5903&amp;volume=39&amp;issue=6&amp;spage=391</ee>
<url>db/journals/acta/acta39.html#BiskupP03</url>
</article>
<article mdate="2015-01-08" key="journals/acta/Bauer89">
<author>Friedrich L. Bauer</author>
<title>In Memoriam: Andrei Petrovich Ershov.</title>
<pages>193-194</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta27.html#Bauer89</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00572987</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Spuler94">
<author>David Spuler</author>
<title>Optimal Search Trees Using Two-Way Key Comparisons.</title>
<pages>729-740</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#Spuler94</url>
<abstract>A generalization of binary search trees and binary split trees is developed that takes advantage of two-way key comparisons: the two-way comparison tree. The two-way comparison tree has little use for dynamic situations but is an improvement over the optimal binary search tree and the optimal binary split tree for static data sets. AnO(n) time and space algorithm is presented for constructing an optimal two-way comparison tree when access probabilities are equal, and an exact formula for the optimal cost is developed. The construction of the optimal two-way comparison tree for unequal access frequencies, both successful and unsuccessful, is computable inO(n 5) time andO(n 3) space using algorithms similar to those for the optimal binary split tree. The optimal two-way comparison tree can improve search cost by up to 50% over the optimal binary search tree.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178732</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NakajimaHN80">
<author>Reiji Nakajima</author>
<author>Michio Honda</author>
<author>Hayao Nakahara</author>
<title>Hierarchical Program Specification and Verification - a Many-sorted Logical Approach.</title>
<pages>135-155</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#NakajimaHN80</url>
<abstract>The notion of abstractions in programming is characterized by the distinction between specification and implementation. As far as the specification structures are concerned, hierarchical program development with abstraction mechanisms is naturally regarded as a process of theory extensions in a many-sorted logic. To support such program development, a language called t is proposed with which one can structuredly build up theories and write their program implementation. There, the implementation is regarded as another level of theory extension, and the relation between the specification and the implementation of an abstraction is characterized in terms of a homomorphism between the two theories. On this formalism, a mechanizable proof method is introduced for validation of implementations of both data and procedural abstraction. Finally, a new data type concept is introduced to generalize the so-called type-parametrization mechanism. A justification of this concept within the first order logic is provided as well as its applications to program structuring and verification.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288541</ee>
</article>
<article mdate="2014-09-05" key="journals/acta/CaoYY14">
<author>Chunhua Cao</author>
<author>Shuang Yang</author>
<author>Di Yang</author>
<title>Some kinds of primitive and non-primitive words.</title>
<pages>339-346</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>If the length of a primitive word \(p\) is equal to the length of another primitive word \(q\), then \(p^{n}q^{m}\) is a primitive word for any \(n,m\ge 1\) and \((n,m)\ne (1,1)\). This was obtained separately by Tetsuo Moriya in 2008 and Shyr and Yu in 1994. In this paper, we prove that if the length of \(p\) is divisible by the length of \(q\) and the length of \(p\) is less than or equal to \(m\) times the length of \(q\), then \(p^{n}q^{m}\) is a primitive word for any \(n,m\ge 1\) and \((n,m)\ne (1,1)\). Then we show that if \(uv,u\) are non-primitive words and the length of \(u\) is divisible by the length \(v\) or one of the length of \(u\) and \(uv\) is odd for any two nonempty words \(u\) and \(v\), then \(u\) is a power of \(v\).</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0200-3</ee>
<url>db/journals/acta/acta51.html#CaoYY14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Landwehr76"> 
<author>Carl E. Landwehr</author>
<title>An Endogenous Priority Model for Load Control in Combined Batch-Interactive Computer Systems.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>153-166</pages>
<url>db/journals/acta/acta7.html#Landwehr76</url>
<abstract>A relatively high level analytical model for computer systems serving both batch and interactive users is presented. The model is unusual in its employment of an endogenous priority scheme to represent a class of strategies for controlling service to the two types of customers. Numerical methods developed by V. L. Wallace are used to generate steady state probability distributions for the infinite state Markov chain formed by the model. Data from the Michigan Terminal System, which includes a load controlling mechanism of the type modelled, is used to validate the model. Finally, additional parameter studies indicate that the model reflects the dynamic behavior of such system in a reasonable way.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265768</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Habermann91">
<author>A. Nico Habermann</author>
<title>Alan J. Perlis 1922-1990.</title>
<pages>409-410</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#Habermann91</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178580</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChibaON85">
<author>Norishige Chiba</author>
<author>Kazunori Onoguchi</author>
<author>Takao Nishizeki</author>
<title>Drawing Plane Graphs Nicely.</title>
<pages>187-201</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#ChibaON85</url>
<abstract>This paper presents two efficient algorithms for drawing plane graphs nicely. Both draw all edges of a graph as straight line segments without crossing lines. The first draws a plane graph “convex” if possible, that is, in a way that every inner face and the complement of the outer face are convex polygons. The second, using the first, produces a pleasing drawing of a given plane graph that satisfies the following property as far as possible: the complements of 3-connected components, together with inner faces and the complement of the outer face, are convex polygons. The running time and storage space of both algorithms are linear in the number of vertices of the graph.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264230</ee>
</article>
<article mdate="2010-02-16" key="journals/acta/HabermehlIV10">
<author>Peter Habermehl</author>
<author>Radu Iosif</author>
<author>Tom&aacute;s Vojnar</author>
<title>Automata-based verification of programs with tree updates.</title>
<pages>1-31</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper describes a verification framework for Hoare-style pre- and post-conditions of programs manipulating balanced tree-like data structures. Since the considered verification problem is undecidable, we appeal to the standard semi-algorithmic approach in which the user has to provide loop invariants, which are then automatically checked, together with the program pre- and post-conditions. We specify sets of program states, representing tree-like memory configurations, using Tree Automata with Size Constraints (TASC). The main advantage of this new class of tree automata is that they recognise tree languages based on arithmetic reasoning about the lengths of various (possibly all) paths in trees, like, e.g., in AVL trees or red–black trees. TASCs are closed under union, intersection, and complement, and their emptiness problem is decidable. Thus we obtain a class of automata which are an interesting theoretical contribution by itself. Further, we show that, under few restrictions, one can automatically compute the effect of tree-updating program statements on the set of configurations represented by a TASC, which makes TASC a practical verification tool. We tried out our approach on the insertion procedure for red–black trees, for which we verified that the output on an arbitrary balanced red–black tree is also a balanced red–black tree.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0108-5</ee>
<url>db/journals/acta/acta47.html#HabermehlIV10</url>
</article>
<article mdate="2015-01-08" key="journals/acta/Turski89">
<author>Wladyslaw M. Turski</author>
<title>On Specification of Multiprocessor Computing.</title>
<pages>685-696</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta27.html#Turski89</url>
<abstract>The paper presents a new specification style for computations to be executed in an essentially multiprocessor environment. This style is based on two pragmatic premises: (1) the specification is derived from considerations of system reaction related to system state, rather than to a goal to be achieved, (2) a reaction enabled by a system state is executed independently of any other system activity but its outcome is accepted only if the system “by itself” satisfies a postguard condition, i.e. finds itself in a (possibly different) well-defined state.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264282</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BuningP80">
<author>Hans Kleine B&uuml;ning</author>
<author>Lutz Priese</author>
<title>Universal Asynchronous Iterative Arrays of Mealy Automata.</title>
<pages>269-285</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#BuningP80</url>
<abstract>Asynchronous two-dimensional iterative arrays of automata will be introduced where the underlying automata are not of Moore-type but of Mealy-type. We will prove that there exists a Mealy automaton, \(\mathfrak{U}_{ 0} \), with only two states and one input and output for each of its four distinguished directions, such that any given Mealy-automaton can be realized by an iterative array with only \(\mathfrak{U}_{ 0} \) for its component-machines. It is known that loop-free nets cannot be as powerful as Mealy automata; however, we will show that any Mealy automaton can be realized by a network, N, with very restrictive component machines, where no signal may pass a loop in N. Using this fact asynchronous iterative arrays can be built up with one component machine, \(\mathfrak{U}_{ 1} \) such that any given Mealy automaton can be realized under the restriction that no signal passes a loop more than once. \(\mathfrak{U}_{ 1} \) contains only four states and one input and output for each direction.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288646</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BrisaboaH97">
<author>Nieves R. Brisaboa</author>
<author>H&eacute;ctor J. Hern&aacute;ndez</author>
<title>Testing Bag-Containment of Conjunctive Queries.</title>
<pages>557-578</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta34.html#BrisaboaH97</url>
<abstract>Under the bag-theoretic semantics relations are bags of tuples, that is, a tuple may have any number of duplicates. Under this semantics, a conjunctive query \(Q\) is bag-contained in a conjunctive query \(Q^{\prime }\), denoted \( Q\leq _bQ^{\prime }\), if for all databases \({\cal D}\), \(Q({\cal D})\), the result of applying \(Q\) to \({\cal D}\), is a subbag of \( Q^{\prime }({\cal D)}\). It is not known whether testing \(Q\leq _bQ^{\prime }\) is decidable. In this paper we prove that \(Q\leq _bQ^{\prime }\) can be tested on a finite set of canonical databases built from the body of \(Q\). Using that result we give a procedure that decides the bag-containment problem of conjunctive queries in a large number of cases.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050097</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikD93">
<author>Karel Culik II</author>
<author>Simant Dube</author>
<title>L-Systems and Mutually Resurcive Function Systems.</title>
<pages>279-302</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#CulikD93</url>
<abstract>In this paper, we investigate the relationship between two different approaches to generate fractal images—L-systems and mutually recursive function systems. We consider two different ways in which L-systems have been used to generate images. The first is the well-known turtle geometry method, and the other is the vector interpretation method as used by Dekking. We show that a uniformly growing D0L-system can be simulated by an MRFS, and any D0L-system can be simulated by a control set produced by an iterative GSM.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179375</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kingston85">
<author>Jeffrey H. Kingston</author>
<title>Analysis of Tree Algorithms for the Simulation Event List.</title>
<pages>15-33</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#Kingston85</url>
<abstract>The simulation event list is a priority queue found in simulation packages like SIMULA. Its task is to hold the pending events of the simulation, so that they can be executed in the correct order. For varying reasons, most standard algorithms are poorly suited to the special demands of this application.Recent work, on the average-case performance of the binary search tree (BST) and p-tree algorithms under these conditions, is presented. The algorithms are shown to be worse than O(log(n)) in many cases.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290143</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Weber89">
<author>Andreas Weber</author>
<title>On the Valuedness of Finite Transducers.</title>
<pages>749-780</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta27.html#Weber89</url>
<abstract>We investigate the valuedness of finite transducers in connection with their inner structure. We show: The valuedness of a finite-valued nondeterministic generalized sequential machine (NGSM) M with n states and output alphabet Δ is at most the maximum of (1-⌊1/#Δ⌋) · (2 k 1 · k 3 ) n · n n ·#Δ n 3 ·k 4 / 3 and ⌊1/#Δ⌋·(2 k 2 ·k 3 ·(1+k 4 )) n ·n n where k 1≦6.25 and k 2≦11.89 are constants and k 3≧1 and k 4≧0 are local structural parameters of M. There are two simple criteria which characterize the infinite valuedness of an NGSM. By these criteria, it is decidable in polynomial time whether or not an NGSM is infinite-valued. In both cases, #Δ > 1 and #Δ = 1, the above upper bound for the valuedness is almost optimal. By reduction, all results can be easily generalized to normalized finite transducers.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264285</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Culik78">
<author>Karel Culik II</author>
<title>The Ultimate Equivalence Problem for DOL Systems.</title>
<pages>79-84</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Culik78</url>
<abstract>The ultimate equivalence problem for DOL systems is shown to be recursively decidable. In algebraic formulation this problem can be stated as follows: Given finite alphabet Σ, two homomorphisms h 1 and h 2 on the free monoid Σ* and two words w 1 w 2 in Σ*, does there exist m≧0 so that h 1 n (w 1) = h 2 n (w 2) for all n≧m?</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260925</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GuttagH78">
<author>John V. Guttag</author>
<author>James J. Horning</author>
<title>The Algebraic Specification of Abstract Data Types.</title>
<pages>27-52</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#GuttagH78</url>
<abstract>There have been many recent proposals for embedding abstract data types in programming languages. In order to reason about programs using abstract data types, it is desirable to specify their properties at an abstract level, independent of any particular implementation. This paper presents an algebraic technique for such specifications, develops some of the formal properties of the technique, and shows that these provide useful guidelines for the construction of adequate specifications.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260922</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Larsen98">
<author>Kim S. Larsen</author>
<title>Amortized Constant Relaxed Rebalancing Using Standard Rotations.</title>
<pages>859-874</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035010/80350859.htm</ee>
<url>db/journals/acta/acta35.html#Larsen98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Vardi83">
<author>Moshe Y. Vardi</author>
<title>Inferring Multivalued Dependencies From Functional and Join Dependencies.</title>
<pages>305-324</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Vardi83</url>
<abstract>We describe an algorithm to test whether a multivalued dependency is implied by a set of functional and join dependencies. The worst case running time of the algorithm is O(nm), where n is the length of the input and m is the number of the attributes in the universe. We also apply the algorithm to test implication of embedded multivalued dependencies, lossless join dependencies, acyclic join dependencies, first order hierarchical decompositions, and functional dependencies. The worst case running time of the algorithm for all these problems is still polynomial in the length of the input.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290729</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KirschenhoferP94">
<author>Peter Kirschenhofer</author>
<author>Helmut Prodinger</author>
<title>The Path Length of Random Skip Lists.</title>
<pages>775-792</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#KirschenhoferP94</url>
<abstract>The skip list is a recently introduced data structure that may be seen as an alternative to (digital) tries. In the present paper we analyze the path length of random skip lists asymptotically, i.e. we study the cumulated successful search costs. In particular we derive a precise asymptotic result on the variance, being of ordern 2 (which is in contrast to tries under the symmetric Bernoulli model, where it is only of ordern). We also intend to present some sort of technical toolkit for the skilful manipulation and asymptotic evaluation of generating functions that appear in this context.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178735</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ChengK98">
<author>Edward Y. C. Cheng</author>
<author>Michael Kaminski</author>
<title>Context-Free Languages over Infinite Alphabets.</title>
<pages>245-267</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta35.html#ChengK98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035003/80350245.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Tennent77"> 
<author>Robert D. Tennent</author>
<title>Language Design Methods Based on Semantic Principles.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>97-112</pages>
<url>db/journals/acta/acta8.html#Tennent77</url>
<abstract>Two language design methods based on principles derived from the denotational approach to programming language semantics are described and illustrated by an application to the language Pascal. The principles are, firstly, the correspondence between parametric and declarative mechanisms, and secondly, a principle of abstraction for programming languages adapted from set theory. Several useful extensions and generalizations of Pascal emerge by applying these principles, including a solution to the array parameter problem, and a modularization facility.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289243</ee>
</article>

<article mdate="2010-10-24" key="journals/acta/HochbaumL10">
<author>Dorit S. Hochbaum</author>
<author>Asaf Levin</author>
<title>How to allocate review tasks for robust ranking.</title>
<pages>325-345</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>In the process of reviewing and ranking projects by a group of reviewers, the allocation of the subset of projects to each reviewer has major impact on the robustness of the outcome ranking. We address here this problem where each reviewer is assigned, out of the list of all projects, a subset of up to k projects. Each individual reviewer then ranks and compares all pairs of k projects. The k-allocation problem is to determine an allocation of up to k projects to each reviewer, that lie within the expertise set of the reviewer, so that the resulting union of reviewed projects has certain desirable properties. The k-complete problem is a k-allocation with the property that all pairs of projects have been compared by at least one reviewer. A k-complete allocation is desirable as otherwise there may be projects that were not compared by any reviewer, leading to possible adverse properties in the outcome ranking. When a k-complete allocation cannot be achieved, one might settle for other properties. One basic requirement is that each pair of projects is comparable via a ranking path which is a sequence of pairwise rankings of projects implying a comparison of all pairs on the path. A k-allocation with a ranking path between each pair is the connectivity-k-aloc. Since the robustness of relative comparisons deteriorates with increased length of the ranking path, another goal is that between each pair of projects there will be at least one ranking path that has at most two hops or q hops for fixed values of q. An alternative means for increasing the robustness of the ranking is to use a k-allocation with at least p disjoint ranking paths between each pair. We model all these problems as graph problems. We demonstrate that the connectivity-k-aloc problem is polynomially solvable, using matroid intersection; we prove that the k-complete problem is NP-hard unless k = 2; and we provide approximation algorithms for a related optimization problem. All other variants are shown to be NP-complete for all values of k ≥ 2.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0120-9</ee>
<url>db/journals/acta/acta47.html#HochbaumL10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Backhouse76">
<author>Roland Carl Backhouse</author>
<title>An Alternative Approach to the Improvement of <i>LR(k)</i> Parsers.</title>
<pages>277-296</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Backhouse76</url>
<abstract>The methods of improving LR(k) parsers proposed by DeRemer and Korenjak are shown to be based on a single concept — that of modifying the contextual information on which parsing decisions are made. This concept is then used to derive a straightforward algorithm for eliminating unit productions from an LR parser.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288658</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Pansiot83">
<author>Jean-Jacques Pansiot</author>
<title>Hi&eacute;rarchie et fermeture de certaines classes de tag-syst&egrave;mes.</title>
<pages>179-196</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Pansiot83</url>
<abstract>Nous définissons des ensembles de mots infinis engendrés par différentes classes de tag-systèmes. Nous montrons que tout mot infini engendré par tag-système étendu peut être engendré par tag-système ɛ-free. Nous en déduisons un graphe complet d'inclusion et diverses propriétés de fermeture pour les ensembles de mots infinis considérés.We define sets of infinite words generated by various classes of tag-systems. We show that every infinite word generated by extended tag-system can also be generated by ɛ-free tag-system. We give a full inclusion graph and several closure properties for the sets of infinite words under study.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289415</ee>
</article>
<article mdate="2011-10-22" key="journals/acta/ZhangH89">
<author>Bin Zhang 0004</author>
<author>Meichun Hsu</author>
<title>Unsafe Operations in B-Trees.</title>
<pages>421-438</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#ZhangH89</url>
<abstract>A simple mathematical model for analyzing the dynamics of a B-tree node is presented. From the solution of the model, it is shown that the simple technique of allowing a B-tree node to be slightly less than half full can significantly reduce the rate of split, merge and borrow operations. We call split, merge, borrow and balance operations unsafe operations in this paper. In a multi-user environment, a lower unsafe operation rate implies less blocking and higher throughput, even when tailored concurrency control algorithms (e.g., that proposed by Lehman and Yao [10]) are used. A lower unsafe operation rate also means a longer life time of an optimally initialized B-tree (e.g., compact B-tree). It is in general useful to have an analytical model which can predict the rate of unsafe operations in a dynamic data structure, not only for comparing the behavior of variations of B-trees, but also for characterizing workload for performance evaluation of different concurrency control algorithms for such data structures. The model presented in this paper represents a starting point in this direction.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289145</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/AycockHJM01">
<author>John Aycock</author>
<author>R. Nigel Horspool</author>
<author>Jan Janousek</author>
<author>Borivoj Melichar</author>
<title>Even faster generalized LR parsing.</title>
<pages>633-651</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037009/10370633.htm</ee>
<url>db/journals/acta/acta37.html#AycockHJM01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SannellaST92">
<author>Donald Sannella</author>
<author>Stefan Sokolowski</author>
<author>Andrzej Tarlecki</author>
<title>Toward Formal Development of Programs from Algebraic Specifications: Parameterisation Revisited.</title>
<pages>689-736</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta29.html#SannellaST92</url>
<abstract>Parameterisation is an important mechanism for structuring programs and specifications into modular units. The interplay between parameterisation (of programs and of specifications) and specification (of parameterised and of non-parameterised programs) is analysed, exposing important semantic and methodological differences between specifications of parameterised programs and parameterised specifications. The extension of parameterisation mechanisms to the higher-order case is considered, both for parameterised programs and parameterised specifications, and the methodological consequences of such an extension are explored.A specification formalism with parameterisation of an arbitrary order is presented. Its denotational-style semantics is accompanied by an inference system for proving that an object satisfies a specification. The formalism includes the basic specification-building operations of the ASL specification language and is institution independent.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191893</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Heilbrunner79">
<author>Stephan Heilbrunner</author>
<title>On the Definition of ELR(k) and ELL(k) Grammars.</title>
<pages>169-176</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Heilbrunner79</url>
<abstract>Extended context free grammars are obtained by allowing regular expressions on the right hand sides of production rules of context free grammars. The LR(k) and LL(k) conditions are made applicable to these grammars by defining canonical transformations of extended grammars into context free grammars.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264023</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NarendranO88">
<author>Paliath Narendran</author>
<author>Friedrich Otto</author>
<title>Elements of Finite Order for Finite Weight-Reducing and Confluent Thue Systems.</title>
<pages>573-591</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta25.html#NarendranO88</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00279954</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rembowski85">
<author>Bogdan Rembowski</author>
<title>A Priority Queue With Interruptions of Service Permitted After a Time Quantum.</title>
<pages>241-251</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta22.html#Rembowski85</url>
<abstract>The queueing theory is applied to analyse a model of a multiprogramming operating system in which preemptive priorities are used for scheduling the service of concurrent streams of requests. Preemptions are permitted at the end of each service quantum. Mean waiting times and higher statistical moments in the M/G/1 system analysed are computed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265681</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BarringerCJ84">
<author>Howard Barringer</author>
<author>J. H. Cheng</author>
<author>Cliff B. Jones</author>
<title>A Logic Covering Undefinedness in Program Proofs.</title>
<pages>251-269</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BarringerCJ84</url>
<abstract>Recursive definition often results in partial functions; iteration gives rise to programs which may fail to terminate for some imputs. Proofs about such functions or programs should be conducted in logical systems which reflect the possibility of “undefined values”. This paper provides an axiomatization of such a logic together with examples of its use.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264250</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/ParamaBPP06">
<author>Jos&eacute; R. Param&aacute;</author>
<author>Nieves R. Brisaboa</author>
<author>Miguel R. Penabad</author>
<author>&Aacute;ngeles S. Places</author>
<title>A semantic approach to optimize linear datalog programs.</title>
<pages>341-370</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>In this work, we present a semantic query optimization approach to improve the efficiency of the evaluation of a subset of SQL:1999 recursive queries. Using datalog notation, we can state our main contribution as an algorithm that builds a program P′ equivalent to a given program P, when both are applied over a database d satisfying a set of functional dependencies. The input program P is a linear recursive datalog program. The new program P′ has less different variables and, sometimes, less atoms in rules, thus it is cheaper to evaluate. Using coral and ibm db2, P′ is empirically shown to be more efficient than the original program.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0025-9</ee>
<url>db/journals/acta/acta43.html#ParamaBPP06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KastensW94">
<author>Uwe Kastens</author>
<author>William M. Waite</author>
<title>Modularity and Reusability in Attribute Grammars.</title>
<pages>601-627</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta31.html#KastensW94</url>
<abstract>An attribute grammar is a declarative specification of dependence among computations carried out at the nodes of a tree. Attribute grammars have proven remarkably difficult to decompose into logical fragments. As a result, they have not yet been accepted as a viable specification technique. By combining the ideas of remote attribute access and inheritance, we have been able to define “attribution modules” that can be reused in a variety of applications. As an example, we show how to define reusable modules for name analysis that embody different scope rules.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177548</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/IglehartS79">
<author>Donald L. Iglehart</author>
<author>Gerald S. Shedler</author>
<title>Regenerative Simulation of Response Times in Networks of Queues with Multiple Job Types.</title>
<pages>159-175</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#IglehartS79</url>
<abstract>We have previously discussed the simulation of networks of queues for general characteristics of passage times of a single job type, using the regenerative method for simulation and the idea of tracking a distinguished job through the network. We consider here, from a somewhat different point ov view, passage time simulation in closed networks of queues having multiple job types. Our results provide a means of obtaining, from a single replication, point and interval estimates for passage times of the several job types. They also yield a statistically more efficient estimation procedure for passage times of a single job type.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00266048</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CostaSS94">
<author>Jos&eacute; F&eacute;lix Costa</author>
<author>Am&iacute;lcar Sernadas</author>
<author>Cristina Sernadas</author>
<title>Object Inheritance Beyond Subtyping.</title>
<pages>5-26</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta31.html#CostaSS94</url>
<abstract>A categorial semantic domain for objects is presented in order to clarify both aggregation and specialization. Three kinds of specialization are discussed: (1) subtyping (specialization with no side effects and no non-monotonic overriding); (2) monotonic specialization (possibly with side effects but still only with monotonic overriding); and (3) non-monotonic specialization (possibly with side effects and non-monotonic overriding). A sequence of three categories of objects differing only in the morphisms is presented. The first one is used to explain object aggregation (respecting locality through a frame constraint) and the strictest form of specialization (subtyping). The second category is shown to be adequate for explaining specialization with side effects (by relaxing the frame constraint). Finally, the third category supports also non-monotonic overriding, by adopting as morphisms suitable partial morphisms of the second one. All these categories are complete and cocomplete. Colimits are used for explaining the semantics of aggregation and multiple inheritance.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178920</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HuangW84">
<author>Shou-Hsuan Stephen Huang</author>
<author>C. K. Wong</author>
<title>Generalized Binary Split Trees.</title>
<pages>113-123</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#HuangW84</url>
<abstract>The definition of binary split trees is generalized by removing the condition of decreasing frequency. It is shown that the access time of generalized split trees is less than that of split trees in general. The optimal representation of generalized split trees is studied. A polynomial time algorithm to construct such optimal tree structures is given. The relationship among several classes of binary trees are also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289143</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AndersonEH73"> 
<author>T. Anderson</author>
<author>J. Eve</author>
<author>James J. Horning</author>
<title>Efficient LR(1) Parsers.</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>12-39</pages>
<url>db/journals/acta/acta2.html#AndersonEH73</url>
<abstract>Knuth'sLR(1) parsing algorithm is sufficiently general to handle the parsing of most programming languages with the additional benefit of earlier detection of syntax errors than in other formal methods used in compilers. The major obstacle impeding the use of this algorithm is the large space requirement for parsing tables. In addition, certain optimisations described here, which increase parsing speed, exacerbate the space problem.Using parsers related to theLR(1) parser which parse a large subset of theLR(1) grammars, but which have much smaller parsing tables.Devising compact encodings and performing space optimisations on these tables.Time and space efficiency is evaluated using the Stanford University Algol W compiler as a base for comparison since the parsing routine in this compiler is among the more efficient presently used.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00571461</ee>
</article>


<article mdate="2015-01-08" key="journals/acta/SondergaardS89">
<author>Harald S&oslash;ndergaard</author>
<author>Peter Sestoft</author>
<title>Referential Transparency, Definiteness and Unfoldability.</title>
<pages>505-517</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta27.html#SondergaardS89</url>
<abstract>The term “referential transparency” is frequently used to indicate that a programming language has certain useful substitution properties. We observe, however, that the formal and informal definitions given in the literature are not equivalent and we investigate their relationships. To this end, we study the definitions in the context of a simple expression language and show that in the presence of non-determinism, the differences between the definitions are manifest. We propose a definition of “referential transparency”, based on Quine's, as well as of the related notions: definiteness and unfoldability. We demonstrate that these notions are useful to characterize programming languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00277387</ee>
</article>
<article mdate="2008-08-08" key="journals/acta/BrijderH08">
<author>Robert Brijder</author>
<author>Hendrik Jan Hoogeboom</author>
<title>The fibers and range of reduction graphs in ciliates.</title>
<pages>383-402</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>The biological process of gene assembly transforms a nucleus (the MIC) into a functionally and physically different nucleus (the MAC). For each gene in the MIC (the input), recombination operations transform the gene to its MAC form (the output). Here we characterize which inputs obtain the same output, and moreover characterize the possible forms of the outputs. We do this in the abstract and more general setting of so-called legal strings.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0074-3</ee>
<url>db/journals/acta/acta45.html#BrijderH08</url>
</article>
<article mdate="2003-11-25" key="journals/acta/SanlavilleS98">
<author>Eric Sanlaville</author>
<author>G&uuml;nter Schmidt</author>
<title>Machine Scheduling with Availability Constraints.</title>
<pages>795-811</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035009/80350795.htm</ee>
<url>db/journals/acta/acta35.html#SanlavilleS98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Devroye88">
<author>Luc Devroye</author>
<title>Applications of the Theory of Records in the Study of Random Trees.</title>
<pages>123-130</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#Devroye88</url>
<abstract>The theory of records in sequences of independent identically distributed random variables leads to simple proofs of various properties of random trees, including among other things, the limit law for the depth of the last node of random ordered trees, random union-find trees, and random binary search trees.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915448</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Flajolet83">
<author>Philippe Flajolet</author>
<title>On the Performance Evaluation of Extendible Hashing and Trie Searching.</title>
<pages>345-369</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Flajolet83</url>
<abstract>A class of trees occurs both in digital searching and in schemes for maintaining dynamic hash tables. We study the distribution of height in these trees using the saddle point method of complex analysis. As a result, we derive a precise evaluation of the memory requirements of extendible hashing — a dynamic hashing scheme — and discuss some related implementation issues.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264279</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Gries73"> 
<author>David Gries</author>
<title>Describing an Algorithm by Hopcroft</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>97-109</pages>
<url>db/journals/acta/acta2.html#Gries73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Roth92">
<author>Peter Roth</author>
<title>Every Binary Pattern of Length Six is Avoidable on the Two-Letter Alphabet.</title>
<pages>95-107</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta29.html#Roth92</url>
<abstract>U. Schmidt [9, 10] showed that every pattern on two letters of length at least 13 is avoidable an a two-letter alphabet (i.e. 2-avoidable). We prove that this bound can be improved to 6. Since there are patterns of length 5 being not 2-avoidable, this bound is optimal.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178567</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/HonkalaL02">
<author>Iiro S. Honkala</author>
<author>Antoine Lobstein</author>
<title>On the complexity of the identification problem in Hamming spaces.</title>
<pages>839-845</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>11/12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038011/20380839.htm</ee>
<url>db/journals/acta/acta38.html#HonkalaL02</url>
</article>
<article mdate="2010-10-24" key="journals/acta/DolevT10">
<author>Shlomi Dolev</author>
<author>Nir Tzachar</author>
<title>Randomization adaptive self-stabilization.</title>
<pages>313-323</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>We present a scheme to convert self-stabilizing algorithms that use randomization during and following convergence to self-stabilizing algorithms that use randomization only during convergence. We thus reduce the number of random bits from an infinite number to an expected bounded number. The scheme is applicable to the cases in which there exits a local predicate for each node, such that global consistency is implied by the union of the local predicates. We demonstrate our scheme over the token circulation algorithm of Herman (Infor Process Lett 35:63–67, 1990) and the recent constant time Byzantine self-stabilizing clock synchronization algorithm by Ben-Or, Dolev and Hoch (Proceedings of the 27th Annual ACM SIGACT-SIGOPS symposium on principles of distributed computing, (PODC), 2008). The application of our scheme results in the first constant time Byzantine self-stabilizing clock synchronization algorithm that eventually stops using random bits.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0119-2</ee>
<url>db/journals/acta/acta47.html#DolevT10</url>
</article>
<article mdate="2011-04-15" key="journals/acta/CavalcantiG11">
<author>Ana Cavalcanti</author>
<author>Marie-Claude Gaudel</author>
<title>Testing for refinement in <i>Circus</i>.</title>
<pages>97-147</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Circus combines constructs to define complex data operations and interactions; it integrates Z and CSP, and, distinctively, it is a language for refinement that can describe programs as well as specification and design models. The semantics is based on the unifying theories of programming (UTP). Most importantly, Circus is representative of a class of refinement-oriented languages that combines facilities to specify abstract data types in a model-based style and patterns of interaction. What we present here is the Circus testing theory; this work is relevant as a foundation for sound test-generation techniques for a plethora of state-rich reactive languages. To cater for data operations, we define symbolic tests and exhaustive test sets. They are the basis for test-generation techniques that can combine coverage criteria for data and transition models. The notion of correctness is Circus refinement, a UTP-based generalisation of failures-divergences refinement that considers data modelling. Proof of exhaustivity exploits the correspondence between the operational and denotational semantics.</abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0133-z</ee>
<url>db/journals/acta/acta48.html#CavalcantiG11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KouMB81">
<author>Lawrence T. Kou</author>
<author>George Markowsky</author>
<author>Leonard Berman</author>
<title>A Fast Algorithm for Steiner Trees.</title>
<pages>141-145</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#KouMB81</url>
<abstract>Given an undirected distance graph G=(V, E, d) and a set S, where V is the set of vertices in G, E is the set of edges in G, d is a distance function which maps E into the set of nonnegative numbers and S⊑V is a subset of the vertices of V, the Steiner tree problem is to find a tree of G that spans S with minimal total distance on its edges. In this paper, we analyze a heuristic algorithm for the Steiner tree problem. The heuristic algorithm has a worst case time complexity of O(¦S¦¦V¦ 2) on a random access computer and it guarantees to output a tree that spans S with total distance on its edges no more than 2(1−1/l) times that of the optimal tree, where l is the number of leaves in the optimal tree.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288961</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Meduna89">
<author>Alexander Meduna</author>
<title>Context Free Derivations on Word Monoids.</title>
<pages>781-786</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta27.html#Meduna89</url>
<abstract>The notion of a (direct) derivation is introduced on word monoids generated by finite languages over total vocabularies of context free grammars. It is shown that using generators of the length at most two, context sensitive and recursively enumerable languages can be characterized in a natural manner.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264286</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Clint81">
<author>Maurice Clint</author>
<title>On the Use of History Variables.</title>
<pages>15-30</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Clint81</url>
<abstract>This paper is a response to a suggestion that the use of history variables in proofs of the correctness of programs is unnecessary. It is argued that the use of history or ghost variables can be of benefit in improving the clarity of some proofs; that without their use some proofs require programming techniques which are at variance with the widely-accepted tenets of structured programming and that for some proofs of correctness their use is unavoidable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289587</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bruno85">
<author>John L. Bruno</author>
<title>On Scheduling Tasks with Exponential Service Times and In-Tree Precedence Constraints.</title>
<pages>139-148</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta22.html#Bruno85</url>
<abstract>In this paper we extend the work of Chandy and Reynolds in which they considered the problem of scheduling tasks on two identical processors. The processing times of the tasks are independent, identically distributed exponential random variables. The tasks are subject to in-tree precedence constraints. Chandy and Reynolds have shown that the expected value of the makespan is minimized if and only if the scheduling policy is Highest-Level-First (HLF). We extend their result by showing that a policy maximizes the probability that all tasks finish by some time t≧0 if and only if the policy is HLF. Additionally, we show that a policy maximizes the probability that the sum of the finishing times of all the tasks is less than some value s≧0 if and only if the policy is HLF.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264227</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HuangL89a">
<author>Chua-Huang Huang</author>
<author>Christian Lengauer</author>
<title>An Incremental Mechanical Development of Systolic Solutions to the Algebraic Path Problem.</title>
<pages>97-124</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta27.html#HuangL89a</url>
<abstract>The Algebraic Path Problem, whose solution is Gauss-Jordan elimination, is one of the most complex problems for which systolic implementations have been proposed. We apply a development method which derives these systolic implementations from a traditional (i.e., Pascal-like) program by formal computational steps. The structure which our method imposes on the derivation process exposes clearly the relationship between the different implementations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265150</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Khabbaz74"> 
<author>Nabil A. Khabbaz</author>
<title>Multipass Precedence Analysis.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>77-85</pages>
<url>db/journals/acta/acta4.html#Khabbaz74</url>
<abstract>This paper defines a hierarchy of languages which is properly contained in the context sensitive languages and which starts with the context free family. The hierarchy is defined inductively by controlling labeled linear grammars with languages in one family to yield languages in the next larger family. The families of the hierarchy have properties analogous to those of the context free family, in particular, the new mechanism introduced is very suitable for parsing.A language in the n-th family is specified by a sequence of n — 1 labeled linear grammars and a context free grammar. By assuming that the reversals of the first n — 1 grammars and the last labeled linear grammar are precedence grammars, the concepts and parsing algorithm of Wirth and Weber extend to yield a parsing algorithm within the hierarchy. This considerably enhances the usefulness of the construction and allows much of the power of the context sensitive languages to become accessible in measured amounts for potential programming applications.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288937</ee>
</article>

<article mdate="2006-05-10" key="journals/acta/TipleaE06">
<author>Ferucio Laurentiu Tiplea</author>
<author>Constantin Enea</author>
<title>Abstractions of data types.</title>
<pages>639-671</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>The use of abstraction in the context of abstract data types, is investigated. Properties to be checked are formulas in a first order logic under Kleene's 3-valued interpretation. Abstractions are defined as pairs consisting of a congruence and a predicate interpretation. Three types of abstractions are considered,∀∀, ∀∃ and ∃0,1∀, and for each of them corresponding property preservation results are established. An abstraction refinement property is also obtained. It shows how one can pass from an existing abstraction to a (less) finer one. Finally, equationally specified abstractions in the context of equationally specified abstract data types are discussed and exemplified.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0010-3</ee>
<url>db/journals/acta/acta42.html#TipleaE06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/TaniguchiK76">
<author>Kenichi Taniguchi</author>
<author>Tadao Kasami</author>
<title>An O(n) Algorithm for Computing the Set of Available Expressions of D-Charts.</title>
<pages>361-364</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#TaniguchiK76</url>
<abstract>In this paper, an idea for computing the set of available expressions at entrance to the nodes of D-charts is explained. An algorithm based on the idea will work in time O(n), given bit vector operations, where n is the number of nodes. D-charts are flow graphs which correspond to the programs where ifs and whiles are used as control statements. The paper is based on the authors' previous report [9].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268137</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Reisig03">
<author>Wolfgang Reisig</author>
<title>On Gurevich's theorem on sequential algorithms.</title>
<pages>273-305</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Abstract-State Machines have been introduced as “a computation model that is more powerful and more universal than standard computation models”, by Yuri Gurevich in 1985. ASM gained much attention as a specification method, in particular for the description of the semantics of programming languages, communication protocols, distributed algorithms, etc. Gurevich proved recently that a sequential algorithm must only meet a few liberal requirements to be representable as an ASM. We critically examine Gurevich's requirements for sequential algorithms, as well as the semantics of ASM-programs and the proof of his main theorem. A couple of examples support and explain intuition and motivation of ASM.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-002-0106-3</ee>
<url>db/journals/acta/acta39.html#Reisig03</url>
</article>
<article mdate="2009-09-28" key="journals/acta/BergstraM09">
<author>Jan A. Bergstra</author>
<author>C. A. Middelburg</author>
<title>Machine structure oriented control code logic.</title>
<pages>375-401</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Control code is a concept that is closely related to a frequently occurring practitioner’s view on what is a program: code that is capable of controlling the behaviour of some machine. We present a logical approach to explain issues concerning control codes that are independent of the details of the behaviours that are controlled. Using this approach, such issues can be explained at a very abstract level. We illustrate this among other things by means of an example about the production of a new compiler from an existing one. The approach is based on abstract machine models, called machine structures. We introduce a model of systems that provide execution environments for the executable codes of machine structures and use it to go into portability of control codes.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0099-2</ee>
<url>db/journals/acta/acta46.html#BergstraM09</url>
</article>
<article mdate="2015-01-08" key="journals/acta/GoudaHR89">
<author>Mohamed G. Gouda</author>
<author>Rodney R. Howell</author>
<author>Louis E. Rosier</author>
<title>The Instability of Self-Stabilization.</title>
<pages>697-724</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta27.html#GoudaHR89</url>
<abstract>We argue that the important property of self-stabilization is, in principle, unstable across system classes. In particular, we first define a very broad notion of simulation. We then define what it means for a simulation to either preserve or force self-stabilization. Given these definitions, we then show that, for a variety of system classes, there is no simulation that preserves or forces self-stabilization.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264283</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KatajainenP94">
<author>Jyrki Katajainen</author>
<author>Tomi Pasanen</author>
<title>Sorting Multisets Stably in Minimum Space.</title>
<pages>301-313</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta31.html#KatajainenP94</url>
<abstract>We consider the problem of sorting a multiset of sizen containingm distinct elements, where theith distinct element appearsn i times. Under the assumption that our model of computation allows only the operations of comparing elements and moving elements in the memory,Ω(n logn − ∑ i=1 m n i logn i +n) is known to be a lower bound for the computational complexity of the sorting problem. In this paper we present aminimum space algorithm that sortsstably a multiset in asymptoticallyOptimal worst-case time. A Quicksort type approach is used, where at each recursive step the median is chosen as the partitioning element. To obtain a stable minimum space implementation, we develop linear-time in-place algorithms for the following problems, which have interest of their own:Stable unpartitioning: Assume that ann-element arrayA is stably partitioned into two subarraysA 0 andA 1. The problem is to recoverA from its constitutentsA 0 andA 1. The information available is the partitioning element used and a bit array of sizen indicating whether an element ofA 0 orA 1 was originally in the corresponding position ofA.Stable selection: The task is to find thekth smallest element in a multiset ofn elements such that the relative order of identical elements is retained.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178508</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BuchholzK98">
<author>Thomas Buchholz</author>
<author>Martin Kutrib</author>
<title>On Time Computability of Functions in One-Way Cellular Automata.</title>
<pages>329-352</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035003/80350329.htm</ee>
<url>db/journals/acta/acta35.html#BuchholzK98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CantorEH86">
<author>J. Cantor</author>
<author>Anthony Ephremides</author>
<author>D. Horton</author>
<title>Information Theoretic Analysis for a General Queueing System at Equilibrium with Application to Queues in Tandem.</title>
<pages>657-678</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#CantorEH86</url>
<abstract>In this paper, information theoretic inference methology for system modeling is applied to estimate the probability distribution for the number of customers in a general, single server queueing system with infinite capacity utilized by an infinite customer population. Limited to knowledge of only the mean number of customers and system equilibrium, entropy maximization is used to obtain an approximation for the number of customers in the G¦ G¦1 queue. This maximum entropy approximation is exact for the case of G=M, i.e., the M¦M¦1 queue. Subject to both independent and dependent information, an estimate for the joint customer distribution for queueing systems in tandem is presented. Based on the simulation of two queues in tandem, numerical comparisons of the joint maximum entropy distribution is given. These results serve to establish the validity of the inference technique and as an introduction to information theoretic approximation to queueing networks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264312</ee>
</article>
<article mdate="2009-09-28" key="journals/acta/Armendariz-InigoMGM09">
<author>Jos&eacute; Enrique Armend&aacute;riz-I&ntilde;igo</author>
<author>Jos&eacute; Ram&oacute;n Gonz&aacute;lez de Mend&iacute;vil</author>
<author>Jos&eacute; Ram&oacute;n Garitagoitia</author>
<author>Francesc D. Mu&ntilde;oz-Esco&iacute;</author>
<title>Correctness proof of a database replication protocol under the perspective of the I/O automaton model.</title>
<pages>297-330</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Correctness of recent database replication protocols has been justified in a rather informal way focusing only in safety properties and without using any rigorous formalism. Since a database replication protocol must ensure some degree of replica consistency and that transactions follow a given isolation level, previous proofs only focused in these two issues. This paper proposes a formalization using the I/O automaton model, identifying several components in the distributed system that are involved in the replication support (replication protocol, group communication system, database replicas) and specifying clearly their actions in the global replicated system architecture. Then, a general certification-based replication protocol guaranteeing the snapshot isolation level is proven correct. To this end, different safety and liveness properties are identified, checked and proved. Our work shows that some details of the replication protocols that were ignored in previous correctness justifications are indeed needed in order to guarantee our proposed correctness criteria.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0097-4</ee>
<url>db/journals/acta/acta46.html#Armendariz-InigoMGM09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/NavarroOR93">
<author>Marisa Navarro</author>
<author>Fernando Orejas</author>
<author>Jean-Luc Remy</author>
<title>Contextual Rewriting as a Sound and Complete Proof Method for Conditional LOG-Specifications.</title>
<pages>147-180</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta30.html#NavarroOR93</url>
<abstract>In this paper we provide foundations to contextual rewriting. We present the class of LOG-specifications, which may be seen, essentially, as a variety of conditional specifications, which may be seen, essentially, as a of LOG-specifications are LOG-algebras, i.e. algebras satisfying that their boolean part coincides with the boolean algebra of two elements. With respect to this semantics, a proof-system called L is presented characterizing logical consequence proof-theoretically. Then, we show that, under adequate assumptions of confluence and finite termination, contextual rewriting is a complete method for this kind of specifications.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178578</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Greibach78">
<author>Sheila A. Greibach</author>
<title>Hierarchy Theorems for Two-Way Finite State Transducers.</title>
<pages>80-101</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Greibach78</url>
<abstract>For a family of languages ℒ, CAL(ℒ) is defined as the family of images of ℒ under nondeterministic two-way finite state transducers, while FINITE · VISIT(ℒ) is the closure of ℒ under deterministic two-way finite state transducers; CAL0(ℒ)=ℒ and for n≧0, CAL n+1(ℒ)=CAL n (CAL(ℒ)). For any semiAFL ℒ, if FINITE · VISIT(ℒ) ≠ CAL(ℒ), then CAL n (ℒ) forms a proper hierarchy and for every n≧0, FINITE · VISIT(CALn(ℒ)) ⫋CAL n+1(ℒ)⫋ FINITE · VISIT(CAL n+1(ℒ)). If ℒ is a SLIP semiAFL or a weakly k-iterative full semiAFL or a semiAFL contained in any full bounded AFL, then FINITE · VISIT(ℒ) ≠ CAL(ℒ) and in the last two cases, ℒ≠ FINITE · VISIT(ℒ). If ℒ is a substitution closed full principal semiAFL and ℒ≠ FINITE · VISIT(ℒ), then FINITE · VISIT(ℒ) ≠ CAL(ℒ). If ℒ is a substitution closed full principal semiAFL generated by a language without an infinite regular set and ℒ1 is a full semiAFL, then ℒ is contained in ∪ CALm(ℒ1) if and only if it is contained in ℒ1. Among the applications of these results are the following. For the following families ℒ, CAL n (ℒ) forms a proper hierarchy: ℒ=INDEXED, ℒ=ETOL, and ℒ any semiAFL contained in CF. The family CF is incomparable with ∪CAL m (NESA) where NESA is the family of one-way nonerasing stack languages and INDEXED is incomparable with ∪CAL m (STACK) where STACK is the family of one-way stack languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264603</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Stephens97">
<author>Robert Stephens</author>
<title>A Survey of Stream Processing.</title>
<pages>491-541</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta34.html#Stephens97</url>
<abstract>  Stream processing is a term that is used widely in the literature to describe a variety of systems. We present an overview of the historical development of stream processing and a detailed discussion of the different languages and techniques for programming with streams that can be found in the literature. This includes an analysis of dataflow, specialized  functional and logic programming with streams, reactive systems, signal processing systems, and the use of streams in the design and verification of hardware.The aim of this survey is an analysis of the development of each of these specialized topics to determine if a general theory of stream processing has emerged. As such, we discuss and classify the different classes of stream processing systems found in the literature from the perspective of programming primitives, implementation techniques, and computability issues, including a comparison of the semantic models that are used to formalize stream based computation.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050095</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Galil80a">
<author>Zvi Galil</author>
<title>An <i> O(V5/3 E2/3) </i> Algorithm for the Maximal Flow Problem.</title>
<pages>221-242</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Galil80a</url>
<abstract>A new algorithm for finding a maximal flow in a given network is presented. The algorithm runs in time O(V 5/3 E 2/3), where V and E are the number of the vertices and edges in the network.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264254</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/CarpiL00">
<author>Arturo Carpi</author>
<author>Aldo de Luca</author>
<title>Special Factors, Periodicity, and an Application to Sturmian Words.</title>
<pages>983-1006</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036012/00360983.htm</ee>
<url>db/journals/acta/acta36.html#CarpiL00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/NakatsuKY82">
<author>Narao Nakatsu</author>
<author>Yahiko Kambayashi</author>
<author>Shuzo Yajima</author>
<title>A Longest Common Subsequence Algorithm Suitable for Similar Text Strings.</title>
<pages>171-179</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#NakatsuKY82</url>
<abstract>Efficient algorithms for computing the longest common subsequence (LCS for short) are discussed. O(pn) algorithm and O(p(m-p) log n) algorithm [Hirschberg 1977] seem to be best among previously known algorithms, where p is the length of an LCS and m and n are the lengths of given two strings (m≦n). There are many applications where the expected length of an LCS is close to m.In this paper, O(n(m-p)) algorithm is presented. When p is close to m (in other words, two given strings are similar), the algorithm presented here runs much faster than previously known algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264437</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Salomaa73"> 
<author>Arto Salomaa</author>
<title>On Sentential Forms of Context-Free Grammars.</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>40-49</pages>
<url>db/journals/acta/acta2.html#Salomaa73</url>
<abstract>There is no algorithm for deciding whether two linear context-free grammars generate the same sentential forms. The equivalence problem for propagatingOL-systems is undecidable. The finiteness problem forOL-systems is decidable.SF-languages, i.e., languages which equal the set of sentential forms of a context-free grammar, possess some of the properties of context-free languages but their family is not closed under any of the ordinary operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00571462</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/JanickeK97">
<author>Ryszard Janicki</author>
<author>Maciej Koutny</author>
<title>Fundamentals of Modelling Concurrency Using Discrete Relational Structures.</title>
<pages>367-388</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta34.html#JanickeK97</url>
<abstract>We consider relational structures \((X,R_1,R_2)\) such that \(X\) is a set and \(R_1,R_2\) are two binary relations on \(X\). For a number of different classes of structures we show that any structure can be represented as the intersection of its maximal extensions. Such a property – called extension completeness – can be seen as a generalisation of Szpilrajn's theorem which states that each partial order is the intersection of its total order extensions. When \(R_1\) can be interpreted as causality and \(R_2\) as ‘weak’ causality we obtain a model of concurrent histories generalising that based on causal partial orders.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050090</ee>
</article>
<article mdate="2010-04-28" key="journals/acta/BackX98">
<author>Ralph-Johan Back</author>
<author>Qiwen Xu</author>
<title>Refinement of Fair Action Systems.</title>
<pages>131-165</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035002/80350131.htm</ee>
<url>db/journals/acta/acta35.html#BackX98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Schuler74a"> 
<author>P. F. Schuler</author>
<title>WCS-Analysis of the Context-Sensitive.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>359-371</pages>
<url>db/journals/acta/acta4.html#Schuler74a</url>
<abstract>In order to gain some insight into the practically undisclosed phenomenon of general Context-Sensitivity the concept of Weak-Context-Sensitivity proves to be a very useful tool.With the correspondences WCS—recursive and Context-Sensitive—recursively enumberable a strong connection to the well known Analysis of the Unsolvable is established.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289617</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Karr76">
<author>Michael Karr</author>
<title>Affine Relationships Among Variables of a Program.</title>
<pages>133-151</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Karr76</url>
<abstract>Several optimizations of programs can be performed when in certain regions of a program equality relationships hold between a linear combination of the variables of the program and a constant. This paper presents a practical approach to detecting these relationships by considering the problem from the viewpoint of linear algebra. Key to the practicality of this approach is an algorithm for the calculation of the “sum” of linear subspaces.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268497</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/HemaspaandraRW97">
<author>Lane A. Hemaspaandra</author>
<author>J&ouml;rg Rothe</author>
<author>Gerd Wechsung</author>
<title>Easy Sets and Hard Certificate Schemes.</title>
<pages>859-879</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<url>db/journals/acta/acta34.html#HemaspaandraRW97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034011/70340859.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MacVeigh77"> 
<author>Donal T. MacVeigh</author>
<title>Effect of Data Representation on Cost of Sparse Matrix Operations.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>361-394</pages>
<url>db/journals/acta/acta7.html#MacVeigh77</url>
<abstract>This paper analyzes the effect the data representation has on the cost of the operations on sparse matrices of matrix addition, multiplication of a matrix by a non-sparse vector, and matrix multiplication. For each operation an algorithm is given for each representation. Each algorithm is analyzed to compute the number of operations and the time required. The cost of each matrix operation is reported analytically as a function of the matrix representation used, the matrix densities, and the speeds of floating point addition and multiplication relative to fixed point operations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289469</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/FerdinandSW94">
<author>Christian Ferdinand</author>
<author>Helmut Seidl</author>
<author>Reinhard Wilhelm</author>
<title>Tree Automata for Code Selection.</title>
<pages>741-760</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#FerdinandSW94</url>
<abstract>We deal with the generation of code selectors in compiler backends. The fundamental concepts are systematically derived from the theory of regular tree grammars and finite tree automata. We use this general approach to construct algorithms that generalize and improve existing methods.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178733</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LeviP88">
<author>Giorgio Levi</author>
<author>Catuscia Palamidessi</author>
<title>Contributions to the Semantics of Logic Perpetual Processes.</title>
<pages>691-711</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta25.html#LeviP88</url>
<abstract>Logic perpetual processes (logic programs with infinite data structures) have been given several formal (operational and fixpoint) semantics. In this paper, we compare the various semantics and define a formal characterization of a least fixpoint semantics, which is based on a modified version of the logic programs and which is satisfactory for a large class of logical perpetual processes. Our results show that all the proposed fixpoint semantics are not equivalent to the operational semantics and suggest an improvement of the least fixpoint approach.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00291055</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Meduna95"> 
<author>Alexander Meduna</author>
<title>Syntactic Complexity of Scattered Context Grammars.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>3</number>
<year>1995</year> 
<pages>285-298</pages>
<url>db/journals/acta/acta32.html#Meduna95</url>
<abstract>The syntactic complexity of scattered context grammars with respect to the number of nonterminals is investigated. First, the family of the recursively enumerable languages is characterized by some basic operations, such as quotient and coding, over the languages generated by propagating scattered context grammars with four nonterminals. Then, a new method of achieving the characterization of the family of recursively enumerable languages by scattered context grammars is given; in fact, this family is characterized by scattered context grammars with only five nonterminals and a single erasing production. Finally, it is demonstrated that the number of nonterminals can be decreased by one in the present characterizations if scattered context grammars start their derivations from a word rather than a single symbol.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178263</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Huynh85">
<author>Dung T. Huynh</author>
<title>Complexity of the Word Problem for Commutative Semigroups of Fixed Dimension.</title>
<pages>421-432</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#Huynh85</url>
<abstract>In this paper we investigate the computational complexity of the word problem for commutative semigroups of fixed dimension. It is shown that for commutative semigroups of dimension k, k ≧ 6, the word problem is complete for symmetric linear space, providing another complete problem for this symmetric complexity class. We also show that in the case of one generator, the word problem is solvable in polynomial time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288776</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LevcopoulosO88">
<author>Christos Levcopoulos</author>
<author>Mark H. Overmars</author>
<title>A Balanced Search Tree with <i> O </i> (1) Worst-case Update Time.</title>
<pages>269-277</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#LevcopoulosO88</url>
<abstract>In this paper a new data structure is described for performing member and neighbor queries in O(logn) time that allows for O(1) worst-case update time once the position of the inserted or deleted element is known. In this way previous solutions that achieved only O(1) amortized time or O(log* n) worst-case time are improved. The method is based on a combinatorial result on the height of piles that are split after some fixed number of insertions. This combinatorial result is interesting in its own right and might have other applications as well.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299635</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KoblerST89">
<author>Johannes K&ouml;bler</author>
<author>Uwe Sch&ouml;ning</author>
<author>Jacobo Tor&aacute;n</author>
<title>On Counting and Approximation.</title>
<pages>363-379</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#KoblerST89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276023</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Sokolowski77">
<author>Stefan Sokolowski</author>
<title>Axioms for Total Correctness.</title>
<pages>61-71</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Sokolowski77</url>
<abstract>A notation for total correctness of a program with respect to input and output formulas is introduced; and Hoare's loop axiom is rearranged in such a way as to form a good inference system for the total correctness. Its consistency and completeness are shown.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263765</ee>
</article>
<article mdate="2004-06-28" key="journals/acta/HeJ04">
<author>Yong He</author>
<author>Yiwei Jiang</author>
<title>Optimal algorithms for semi-online preemptive scheduling problems on two uniform machines.</title>
<pages>367-383</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>This paper investigates two preemptive semi-online scheduling problems to minimize makespan on two uniform machines. In the first semi-online problem, we know in advance that all jobs have their processing times in between p and rp \((p > 0,r\geq 1)\). In the second semi-online problem, we know the size of the largest job in advance. We design an optimal semi-online algorithm which is optimal for every combination of machine speed ratio \(s\geq 1\) and job processing time ratio \(r\geq 1\) for the first problem, and an optimal semi-online algorithm for every machine speed ratio \(s\geq 1\) for the second problem.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0134-7</ee>
<url>db/journals/acta/acta40.html#HeJ04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Bromley80">
<author>Allan G. Bromley</author>
<title>Memory Fragmentation in Buddy Methods for Dynamic Storage Allocation.</title>
<pages>107-117</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Bromley80</url>
<abstract>Methods are presented for the estimation of bounds on the memory fragmentation in buddy methods of dynamic storage allocation. These bounds, when compared with the results of simulation studies, are found to be sufficiently precise to be of considerable practical utility.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288539</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Steensgaard-Madsen79">
<author>J&oslash;rgen Steensgaard-Madsen</author>
<title>Pascal-Clarifications and Recommended Extensions.</title>
<pages>73-94</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Steensgaard-Madsen79</url>
<abstract>The objectives of this paper are to clarify certain issues in the language Pascal that were left open by the defining Report and to recommend specific forms for certain extensions of the language that have repeatedly appeared in discussions and even implementations. By encouraging prospective implementors to adopt a common form, we wish to enhance the prospects for practical portability of Pascal programs. Except for parameters being procedures and functions, the language constructs described by the Pascal Report are not changed, i.e. the new syntax permits the same constructs with the same (intended) meaning.The paper expresses the author's proposal following a discussion among a small group of people who have been working on Pascal compilers and standardization. In itself it is not an attempt to standardize Pascal or present a complete revision of the Report. Concentrating on the type concept, the meaning of identifiers, and a limited number of extensions the need of which is generally accepted, the paper establishes guidelines for standardization and revision of the Pascal Report. It is presented as a carefully deliberated and (hopefully) consistent proposal for acceptance by whatever means the Pascal community may choose to adopt.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264018</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HuiC97">
<author>Chi-Chung Hui</author>
<author>Samuel T. Chanson</author>
<title>Minimal Communication Cost Software Construction in the Internet Environment.</title>
<pages>579-595</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta34.html#HuiC97</url>
<abstract>This paper investigates the issue of building software in the Internet environment, where local area network (LAN) based systems are interconnected by links with different bandwidth and do not share file systems. The software is modeled as a directed acyclic graph. Each node in the graph represents a logical step in processing the software while the edges describe the order of execution. The problem is to construct the software at a particular LAN with minimum Internet communication cost. An optimal polynomial algorithm, SOFTCON, with time complexity \({\cal O}(N C + E + {\cal A}(N, N + E))\) is presented, where \(N\) and \(E\) are the number of nodes and edges in the graph describing the software respectively, \(C\) is the number of LANs in the Internet environment, and \({\cal O}({\cal A}({\cal N}, {\cal E}))\) is the time complexity of the network flow algorithm on the flow network with \({\cal N}\) nodes and \({\cal E}\) edges transformed from the directed acyclic graph of the software.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050098</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FennerL81">
<author>Trevor I. Fenner</author>
<author>George Loizou</author>
<title>An Analysis of two Related Loop-free Algorithms for Generating Integer Partitions.</title>
<pages>237-252</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#FennerL81</url>
<abstract>Two loop-free algorithms, LEX and NEXPAR2, for generating the partitions of a positive integer n, in lexicographic and antilexicographic order, respectively, are investigated, and their structures are shown to be closely related. By utilising a number of combinatorial identities which relate the cardinalities of various classes of partitions, we derive formulae from which operation counts for the two algorithms may be obtained. For large n, corresponding asymptotic formulae are also obtained. A number of modifications and refinements of the two algorithms are discussed, and the relative performance of the algorithms resulting, and also the original algorithms, is analysed for both the non-asymptotic and the asymptotic cases.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261261</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CorradiniN97">
<author>Flavio Corradini</author>
<author>Rocco De Nicola</author>
<title>Locality Based Semantics for Process Algebras.</title>
<pages>291-324</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta34.html#CorradiniN97</url>
<abstract>A general framework proposed by Degano, De Nicola and Montanari has been fruitful to define in a natural way non interleaving semantics for process description languages based on causality. The framework relies on a decomposition function used to obtain the set of its sequential processes from a parallel term, and on a set of distributed transition rules carrying information about the actions processes can perform and their location. In this paper we show that also semantics discriminating according to space distribution of processes can be formulated in a natural way within this framework. Two new semantics are proposed. The first one is based on an alternative characterization of the locality equivalence of Boudol, Castellani, Hennessy and Kiehn. Over the latter, our equivalence has the advantage of not requiring explicit introduction of a (infinite) space of locations; this makes it amenable to a mechanical treatment in the same vein as the classical bisimulation-based equivalences. The second semantics is proposed via a direct generalization of Castellani and Hennessy's distributed equivalence to languages with global scoping operators.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050086</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Horowitz74"> 
<author>Ellis Horowitz</author>
<title>A Unified View of the Complexity of Evaluation and Interpolation.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>123-133</pages>
<url>db/journals/acta/acta3.html#Horowitz74</url>
<abstract>Four problems are considered: 1) from an n-precision integer compute its residues modulo n single precision primes; 2) from an n-degree polynomial compute its values at n points; 3) from n residues compute the unique n-precision integer congruent to the residues; 4) from n points compute the unique interpolating polynomial through those points. If M (n) is the time for n-precision integer multiplication, then the time for problems 1 and 2 is shown to be M (n) log n and for problems 3 and 4 to be M (n) (log n) 2. Moreover it is shown that each of the four algorithms are really all instances of the same general algorithm. Finally it is shown how preconditioning or a change of domain will reduce the time for problems 3 and 4 to M (n) (log n).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264033</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Proietti99">
<author>Guido Proietti</author>
<title>An Optimal Algorithm for Decomposing a Window into Maximal Quadtree Blocks.</title>
<pages>257-266</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036004/90360257.htm</ee>
<url>db/journals/acta/acta36.html#Proietti99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Poblete93">
<author>Patricio V. Poblete</author>
<title>The Analysis of Heuristics for Search Trees.</title>
<pages>233-248</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#Poblete93</url>
<abstract>We analyze the performance of search trees built under a variety of insertion heuristics. The main results are a method to obtain asymptotic expressions for the moments of the distribution of the search time, and a proof that this distribution is asymptotically normal.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179372</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Slobodova92">
<author>Anna Slobodov&aacute;</author>
<title>Communication for Alternating Machines.</title>
<pages>425-441</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#Slobodova92</url>
<abstract>A new model of parallel computations generalizing the concept of alternation is introduced and several properties of this model are established. The model supports a simple form of communication via states among parallel processes. It seems to be a useful tool for investigation of both nondeterminism and parallelism.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193576</ee>
</article>
<article mdate="2004-06-28" key="journals/acta/AndreiCC04">
<author>Stefan Andrei</author>
<author>Wei-Ngan Chin</author>
<author>Salvador Valerio Cavadini</author>
<title>Self-embedded context-free grammars with regular counterparts.</title>
<pages>349-365</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>In general, it is undecidable if an arbitrary context-free grammar has a regular solution. Past work has focused on special cases, such as one-letter grammars, non self-embedded grammars and the finite-language grammars, for which regular counterparts have been proven to exist. However, little is known about grammars with the self-embedded property. Using systems of equations, we highlight a number of subclasses of grammars, with self-embeddedness terms, such as \(X \alpha X\) and \(\gamma X \gamma\), that can still have regular languages as solutions. Constructive proofs that allow these subclasses of context-free grammars to be transformed to regular expressions are provided. We also point out a subclass of context-free grammars that is inherently non-regular. Our latest results can help demarcate more precisely the known boundaries between the regular and non-regular languages, within the context-free domain.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0133-8</ee>
<url>db/journals/acta/acta40.html#AndreiCC04</url>
</article>
<article mdate="2007-02-07" key="journals/acta/OlderogR07">
<author>Ernst-R&uuml;diger Olderog</author>
<author>Anders P. Ravn</author>
<title>Editorial: Hybrid Systems.</title>
<pages>449-450</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract></abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0034-8</ee>
<url>db/journals/acta/acta43.html#OlderogR07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/AdiriBFK89">
<author>Igal Adiri</author>
<author>John L. Bruno</author>
<author>Esther Frostig</author>
<author>A. H. G. Rinnooy Kan</author>
<title>Single Machine Flow-Time Scheduling With a Single Breakdown.</title>
<pages>679-696</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta26.html#AdiriBFK89</url>
<abstract>We consider the problem of scheduling tasks on a single machine to minimize the flowtime. The machine is subject to breakdowns during the processing of the tasks. The breakdowns occur at a random times and the machine is unavailable until it is repaired. The times for repair are random and independent of each other and of the breakdown process. A task that is preempted due to a breakdown must be restarted and otherwise preemptions are not allowed. We show in the case of a single breakdown that if the distribution function of the time to breakdown is concave then Shortest Processing Time (SPT) first scheduling stochastically minimizes the flowtime. For the case of multiple breakdowns we show that SPT minimizes the expected flowtime when the times to breakdown are exponentially distributed. If the time for a single breakdown is known before scheduling begins, and the processing times of the tasks are also known, then we show that the problem of deciding whether there is a schedule with flowtime less than or equal to a given value is NP-complete. Finally, we bound the performance of SPT scheduling in the deterministic case when there is a single breakdown.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288977</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Mili83">
<author>Ali Mili</author>
<title>A Relational Approach to the Design of Deterministic Programs.</title>
<pages>315-328</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Mili83</url>
<abstract>Deterministic programs are rules for functions; their specifications are relations. Designing a program to meet a specification (relation) R amounts to determining a function that meets some consistency requirement with R. This problem becomes more complex when relation R is complex, hence the potential need to decompose relation R. Complex relations can be built from simpler relations by relative product, union or transitive closure; hence complex relations (specifications) can be decomposed into simpler ones by writing them as a relative product, a union or a transitive closure of simpler ones. These decomposition strategies correspond to the traditional programming language constructs of sequence (;), alternative (if-then-else) and iteration (while-do). This paper presents relational decomposition rules and discusses their validity and significance.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264277</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/YenT99">
<author>William C. K. Yen</author>
<author>C. Y. Tang</author>
<title>An Optimal Algorithm for Solving the Searchlight Guarding Problem on Weighted Two-Terminal Series-Parallel Graphs.</title>
<pages>143-172</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036002/90360143.htm</ee>
<url>db/journals/acta/acta36.html#YenT99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BroyW82">
<author>Manfred Broy</author>
<author>Martin Wirsing</author>
<title>Partial Abstract Types.</title>
<pages>47-64</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#BroyW82</url>
<abstract>Hierarchical abstract types, where particular sorts, operations, and axioms are designated as primitive, with conditional equational formulas are studied. Introducing notions of different homomorphisms particular models of this class can be distinguished as initial or (weakly) terminal. Sufficient conditions for the existence of such models are given and their relationship to the principle of fully abstract semantics is investigated. By this the concept of algebraic specification is extended to specify the semantics of programming languages in a completely abstract algebraic way as it is demonstrated for two toy languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625280</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Winklmann82a">
<author>Karl Winklmann</author>
<title>On the Complexity of some Problems Concerning the Use of Procedures II.</title>
<pages>411-430</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Winklmann82a</url>
<abstract>We consider programming languages which allow procedures to be declared dynamically and to be passed as parameters. The influence of these two features on the decidability of “formal parameter correctness”, “formal recursivity”, and other properties relevant for debugging and optimization has been studied in [1, 2, 4–9]. In this paper we study the feasibility of such decision procedures in those cases where decidability has been proven. Thus this paper presents a complexity-theoretic refinement of some of the recursion-theoretic work from [1, 2, 4–9].Deciding whether or not a program has the “formal most-recent-property” is a P-space-complete problem even for programs with no more than 4 parameters per procedure (Theorem 7).Deciding formal parameter correctness, formal recursivity and reachability of procedures, and the formal macro-property are all P-space complete problems for the class of programs without procedure nesting (Theorem 4). Detecting the presence of recursive procedures is an NP-complete problem for this class of programs (Theorem 4).In finite-mode programs, detecting the presence of formally recursive procedures is an NP-complete problem; deciding whether or not a procedure is formally recursive, deciding whether or not a procedure is formally reachable, and deciding whether or not a program has the formal macro-property are P-space-hard problems; and deciding whether or not a program has the formal most-recent-property is a P-space-complete problem (Theorem 5).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289578</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Langmaack73"> 
<author>Hans Langmaack</author>
<title>On Correct Procedure Parameter Transmission in Higher Programming Languages</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>110-142</pages>
<url>db/journals/acta/acta2.html#Langmaack73</url>
</article>


<article mdate="2015-10-06" key="journals/acta/OttoM15">
<author>Friedrich Otto</author>
<author>Frantisek Mr&aacute;z</author>
<title>Deterministic ordered restarting automata for picture languages.</title>
<pages>593-623</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The ordered restarting automaton (processing strings) is introduced, and it is shown that its nondeterministic variant is very expressive, as it accepts some languages that are not even context-free, while the deterministic ordered restarting automata just accept the regular languages. Then three different extensions of the deterministic ordered restarting automaton to two-dimensional inputs are defined that differ in the way in which they can move their read/write windows. We compare the classes of picture languages that these types of automata accept to each other and to some well studied classes of picture languages from the literature, and we present some closure and non-closure properties for them.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0230-5</ee>
<url>db/journals/acta/acta52.html#OttoM15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/TurnbullL79">
<author>C. J. M. Turnbull</author>
<author>E. S. Lee</author>
<title>Generalized Deterministic Left To Right Parsing.</title>
<pages>187-207</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#TurnbullL79</url>
<abstract>A parser model is presented whose structure is a generalization of the well known LR(k) parsers. Various classes of this parser that would be both practical and efficient to use in a compiler are examined. Associated with these classes of parsers is a hierarchy of type-0 grammars, each grammatical class being defined in terms of the form and structure of derivations. In particular, parsers based on a class called deterministic regular parsable (DRP) grammars will detect any errors as soon as possible during a left to right scan of the input. LR(k) grammars are also DRP. Much research related to LR(k) grammars and parsing is also applicable to DRP grammars and their associated parsers.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264578</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/FaigleK91">
<author>Ulrich Faigle</author>
<author>Walter Kern</author>
<title>Some Order Dimension Bounds for Communication Complexity Problems.</title>
<pages>593-601</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#FaigleK91</url>
<abstract>We associate with a general (0, 1)-matrixM an ordered setP(M) and derive lower and upper bounds for the deterministic communication complexity ofM in terms of the order dimension ofP(M). We furthermore consider the special class of communication matricesM obtained as cliques vs. stable sets incidence matrices of comparability graphsG. We bound their complexity byO((logd)·(logn)), wheren is the number of nodes ofG andd is the order dimension of an orientation ofG. In this special case, our bound is shown to improve other well-known bounds obtained for the general cliques vs. stable set problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463947</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bouge88">
<author>Luc Boug&eacute;</author>
<title>On the Existence of Symmetric Algorithms to Find Leaders in Networks of Communicating Sequential Processes.</title>
<pages>179-201</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta25.html#Bouge88</url>
<abstract>We define a semantic notion of symmetry well-suited for networks of processes specified in Hoare's language CSP. Symmetric algorithms to find a leader in such networks are then studied. We show that the existence of such algorithms depends crucially on the network topology and on the use of input/output guards in processes. The election problem appears thus as a powerful criterion in assessing the expressive power of distributed programming languages like CSP.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263584</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LloydL85">
<author>Errol L. Lloyd</author>
<author>Michael C. Loui</author>
<title>On the Worst Case Performance of Buddy Systems.</title>
<pages>451-473</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#LloydL85</url>
<abstract>The worst-case performance of both binary and Fibonacci buddy systems is analyzed. For both unrestricted and allocation-only request sequences, exact bounds on both the external and total fragmentation are derived.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288778</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Yao78">
<author>Andrew Chi-Chih Yao</author>
<title>On Random 2-3 Trees.</title>
<pages>159-170</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Yao78</url>
<abstract>It is shown that ¯n (N), the average number of nodes in an N-key random 2–3 tree, satisfies the inequality 0.70 N < ¯n(N) <0.79 N for large N. A similar analysis is done for general B-trees. It is shown that storage utilization is essentially ln 2≈69% for B-tree of high orders.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289075</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ParentP77"> 
<author>Michel Parent</author>
<author>Dominique Potier</author>
<title>A Note on the Influence of Program Loading on the Page Fault Rate.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>359-370</pages>
<url>db/journals/acta/acta8.html#ParentP77</url>
<abstract>We define and analyse in this paper the concept of modified life time function. This concept is introduced in order to take into account both internal and external factors which influence the mean time between page faults of a program executing on a page-on-demand multiprogramming system. The analysis is based on a probabilistic model of a program paging activity during its execution. The intrinsic behaviour of the program in its adress space as well as the memory allotment and the swapping policy are considered in the model, and the interactions of these different factors are analysed. The results point out that the influence of the external factors on the life time function of a program is significant, and provide some insight on the non-convex shape of observed life time functions. Numerical illustrations are presented, and it is shown that the analysis can be used to quantify the performance of preloading policies.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271344</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Rabin82">
<author>Michael O. Rabin</author>
<title>The Choice Coordination Problem.</title>
<pages>121-134</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Rabin82</url>
<abstract>In the course of a concurrent computation, processes P1,..., Pn must reach a common choice of one out of k alternatives A 1,..., A k. They do this by protocols using k shared variables, one for each alternative. If the range of the variables has m values then \(\frac{{\text{1}}}{{\text{2}}}\sqrt[{\text{3}}]{n} \leqq \operatorname{m} \) is necessary, and n + 2≦m is sufficient, for deterministic protocols solving the choice coordination problem (C.C.P.). We introduce very simple randomizing protocols which, independently of n, solve the C.C.P. by use of a fixed alphabet. A single-byte (256-valued) alphabet permits a solution with non-termination probability smaller than 2−127. Many software and hardware tasks involving concurrency can be interpreted as choice coordination problems. Choice coordination problems occur also in nature.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288965</ee>
</article>
<article mdate="2010-10-24" key="journals/acta/AcetoFIM10">
<author>Luca Aceto</author>
<author>Wan Fokkink</author>
<author>Anna Ing&oacute;lfsd&oacute;ttir</author>
<author>Mohammad Reza Mousavi</author>
<title>Lifting non-finite axiomatizability results to extensions of process algebras.</title>
<pages>147-177</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>This paper presents a general technique for obtaining new results pertaining to the non-finite axiomatizability of behavioural (pre)congruences over process algebras from old ones. The proposed technique is based on a variation on the classic idea of reduction mappings. In this setting, such reductions are translations between languages that preserve sound (in)equations and (in)equational provability over the source language, and reflect families of (in)equations responsible for the non-finite axiomatizability of the target language. The proposed technique is applied to obtain a number of new non-finite axiomatizability theorems in process algebra via reduction to Moller’s celebrated non-finite axiomatizability result for CCS. The limitations of the reduction technique are also studied. In particular, it is shown that prebisimilarity is not finitely based over CCS with the divergent process Ω, but that this result cannot be proved by a reduction to the non-finite axiomatizability of CCS modulo bisimilarity. This negative result is the inspiration for the development of a sharpened reduction method that is powerful enough to show that prebisimilarity is not finitely based over CCS with the divergent process Ω.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0114-7</ee>
<url>db/journals/acta/acta47.html#AcetoFIM10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CuntoG87">
<author>Walter Cunto</author>
<author>Jose Luis Gascon</author>
<title>Improving Time and Space Efficiency in Generalized Binary Search Trees.</title>
<pages>583-594</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#CuntoG87</url>
<abstract>This paper deals with main memory data structures for which time and space performance are simultaneously considered. The main contribution is a new data structure called Generalised Binary Search Tree (GBS-tree) together with searching and updating algorithms on this structure. GBS-trees generalise different data structures based on binary trees that have appeared in the literature. A k-t GBS-tree allows up to t keys per node and subtrees in the tree's fringe of exactly 2k-1 full nodes are kept balanced. Their time and space performances are analysed in depth. The time performance is expressed in terms of the average and the variance of the number of binary comparisons between a given key and keys already in the structure. The space performance measures both the space used to space generated ratio (space utilization factor) and the pointers to keys ratio of these trees. The analysis shows that the time performance always improves when GBS-trees of higher order are considered. In the absence of balancing techniques, larger values of t, which produces smaller pointers to key ratios, induce unacceptably poor space utilizations factors. We show that both pointers to keys ratio and space utilization factor improve when larger values of k are used. Thus, local balancing techniques are adequate, not only for time performance improvement, but also, for space performance improvement.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263296</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kastens87">
<author>Uwe Kastens</author>
<title>Lifetime Analysis for Attributes.</title>
<pages>633-651</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta24.html#Kastens87</url>
<abstract>Reduction of attribute storage is a vital requirement for attribute evaluators. We present a new method for the analysis of lifetime of attribute instances. It is assumed that attribute evaluation is performed by a visit-oriented evaluator. Its evaluation sequence for any input can be described by a contex-free grammar derived from the visit-sequences. Conditions on that CFG decide for each attribute whether all its instances can be stored in a single global variable. Furthermore one can decide whether several different attributes can be mapped to a single global variable. Similarly conditions for stack implementation are given. All decisions can be made efficiently at evaluator generation time. Hence the method is well suited for compiler generation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00282619</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rice75"> 
<author>John R. Rice</author>
<title>Parallel Algorithms for Adaptive Quadrature II Metalgorithm Correctness.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>273-285</pages>
<url>db/journals/acta/acta5.html#Rice75</url>
<abstract>This paper introduces a rather specific metalgorithm (or meta-program) for a class of algorithms for adaptive quadrature on parallel (MIMD) computers. This class includes all the current approaches to adaptive quadrature. The main result is that any member of this metalgorithm satisfies the conditions of a traditional numerical analysis convergence theorem from [2]. The algorithm structure in this metalgorithm is specified in some detail and 32 Attributes are assumed. These Attributes and structure serve to guide the design of particular algorithms. They also facilitate establishing algorithm correctness by providing a detailed set of algorithm properties (most of which are like “assertions” in program proving) that are sufficient for correctness.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264562</ee>
</article>

<article mdate="2007-09-11" key="journals/acta/KariMT07">
<author>Lila Kari</author>
<author>Kalpana Mahalingam</author>
<author>Gabriel Thierrin</author>
<title>The syntactic monoid of hairpin-free languages.</title>
<pages>153-166</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>The study of hairpin-free words has been initiated in the context of DNA computing. DNA strands that, theoretically speaking, are finite strings over the alphabet {A, G, C, T} are used in DNA computing to encode information. Due to the fact that A is complementary to T and G to C, DNA single strands that are complementary can bind to each other or to themselves in either intended or unintended ways. One of the structures that is usually undesirable for biocomputation, since it makes the affected DNA string unavailable for future interactions, is the hairpin: if some subsequences of a DNA single string are complementary to each other, the string will bind to itself forming a hairpin-like structure. This paper continues the theoretical study of hairpin-free languages. We study algebraic properties of hairpin-free words and hairpins. We also give a complete characterization of the syntactic monoid of the language consisting of all hairpin-free words over a given alphabet and illustrate it with an example using the DNA alphabet.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0041-4</ee>
<url>db/journals/acta/acta44.html#KariMT07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Dunne87">
<author>Paul E. S. Dunne</author>
<title>A Result on <i> k </i> -Valent Graphs and Its Application to a Graph Embedding Problem.</title>
<pages>447-459</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#Dunne87</url>
<abstract>It is proved that any n-vertex, k-valent undirected simple graph, G, contains a spanning tree with at least \(\frac{{{\text{(}}k - {\text{2)}}n}}{{{\text{(5}}k - {\text{8}}{\text{.5)}}}}\) leaves. As a result of this it is shown that any such graph contains an independent set, of size at least n/5k, with the property that deleting the vertices in this set and their incident edges does not disconnect G. This latter result is applied by giving an improved upper bound on the area required to embed arbitrary graphs into grid graphs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292113</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CuntoP88">
<author>Walter Cunto</author>
<author>Patricio V. Poblete</author>
<title>Transforming Unbalanced Multiway Trees into a Practical External Data Structure.</title>
<pages>193-211</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta26.html#CuntoP88</url>
<abstract>Unbalanced Multiway Trees (UM-trees) of degree m are external data structures wherein each node may be linked to at most m subtrees. Although they allow fast searches and updates UM-trees show poor space efficiency. In order to improve their time and space performance an overflow technique similar to that used previously for B *-trees is adapted to UM-trees. Analytical results show that when compared with UM-trees the new data structure improves average searching time and substantially increases space efficiency. Asymptotic space efficiency, measured as the ratio of space used to space generated, is 50% in the worst case and in the average case it is upper bounded by at least 85.7% for any m. Simulations suggest that this upper bound is tight. Compared with a homologous variant of B *-trees, simulation results indicate that the data structure proposed is highly balanced with comparable average space efficiency and lower average searching time. We conclude that overflow techniques can be applied not only to bottom-up type trees (e.g., B-trees) but also to top-down type trees such as UM-trees, in cases when the performance of an external data structure needs to be improved with little overhead.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00299632</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Anderson93">
<author>James H. Anderson</author>
<title>A Fine-Grained Solution to the Mutual Exclusion Problem.</title>
<pages>249-265</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#Anderson93</url>
<abstract>We present a “fine-grained” solution to the mutual exclusion problem. A program isfine-grained if it uses only single-reader, single-writer boolean variables and if each of its atomic operations has at most one occurrence of at most one shared variable. In contrast to other fine-grained solutions that have appeared in the literature, processes in our solution do not bysy-wait, but wait on one another only by executingawait statements. Such statements can be implemented in practice either by means of context switching or by means of “local” spinning. We show that our algorithm is correct even if shared variables are accessed nonatomically.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179373</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nipkow86">
<author>Tobias Nipkow</author>
<title>Non-deterministic Data Types: Models and Implementations.</title>
<pages>629-661</pages>
<year>1986</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta22.html#Nipkow86</url>
<abstract>The model theoretic basis for (abstract) data types is generalized from algebras to multi-algebr as in order to cope with non-deterministic operations. A programming oriented definition and a model theoretic criterion (called simulation) for implementation of data types are given. To justify the criterion w.r.t. the definition, an abstract framework linking denotational semantics of programming languages and model theory of data types is set up. A set of constraints on a programming language semantics are derived which guarantee that simulation implies implementation. It is argued that any language supporting data abstraction does fulfill these constraints. As an example a simple but expressive language L is defined and it is formally proved that L does conform to these restrictions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263649</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DarlingtonB76">
<author>John Darlington</author>
<author>Rod M. Burstall</author>
<title>A System which Automatically Improves Programs.</title>
<pages>41-60</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#DarlingtonB76</url>
<abstract>Here we give methods of mechanically converting programs that are easy to understand into more efficient ones, converting recursion equations using high level operations into lower level flowchart programs.The main transformations involved are (i) recursion removal (ii) eliminating common subexpressions and combining loops (iii) replacing procedure calls by their bodies (iv) introducing assignments which overwrite list cells no longer in use (compiletime garbage collection).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263742</ee>
</article>
<article mdate="2010-01-04" key="journals/acta/AycockB09">
<author>John Aycock</author>
<author>Angelo Borsotti</author>
<title>Early action in an Earley parser.</title>
<pages>549-559</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>Traditional Earley parsers operate in two phases: first recognizing the input, then constructing the forest of parse trees. Practically speaking, this quirk makes it awkward to use in a compiler-compiler, because semantic actions attached to rules are only executed after the fact. We address this problem by identifying safe Earley sets, points during the recognition phase at which partial parse trees can be constructed; this means that semantic actions may be executed on the fly. A secondary benefit is that Earley sets can be deleted during recognition, resulting in a substantial savings of both space and time.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0107-6</ee>
<url>db/journals/acta/acta46.html#AycockB09</url>
</article>
<article mdate="2003-11-25" key="journals/acta/CarpiLV02">
<author>Arturo Carpi</author>
<author>Aldo de Luca</author>
<author>Stefano Varricchio</author>
<title>Words, univalent factors, and boxes.</title>
<pages>409-436</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038006/20380409.htm</ee>
<url>db/journals/acta/acta38.html#CarpiLV02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Nutt76">
<author>Gary J. Nutt</author>
<title>Some Resource Allocation Policies in a Multi Associative Processor.</title>
<pages>211-225</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Nutt76</url>
<abstract>The Multi Associative Processor is a hypothetical machine composed of eight control units and an arbitrary number of processing elements. Each control unit executes a single-instruction-stream multiple-data-stream program in conjunction with a subset of the dynamically allocatable processing elements. In this machine, the data bus interconnecting control units and processing elements is partitioned in order to decrease the hardware cost of the interconnection. In previous work, the degree of partitioning was investigated, and it was found that the processing element allocation algorithm was very critical to the performance of the system, [5]. In this paper, a basic allocation algorithm is investigated under various job loads, and then the performance is compared to three distinct algorithms that compact processing elements into smaller subsets of the partitions under varying conditions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288655</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PurdomBR81">
<author>Paul Walton Purdom Jr.</author>
<author>Cynthia A. Brown</author>
<author>Edward L. Robertson</author>
<title>Backtracking with Multi-Level Dynamic Search Rearrangement.</title>
<pages>99-113</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#PurdomBR81</url>
<abstract>The order in which the variables are tested in a backtrack program can have a major effect on its running time. The best search order usually varies among the branches of the backtrack tree, so the number of possible search orders can be astronomical. We present an algorithm that chooses a search order dynamically by investigating all possibilities for k levels below the current level, extending beyond k levels wherever possible by setting the variables that have unique forced values. The algorithm takes time O(n k+1) to process a node. For k=2 and binary variables the analysis for selecting the next variable to introduce into the backtrack tree makes complete use of the information contained in the two-level investigations. For larger k or variables of higher degree there is no polynomial-time algorithm that makes complete use of the k-level investigations to limit searching (unless P=NP). The search rearrangement algorithm is closely related to constraint propagation. Experimental studies on conjunctive normal form predicates confirm that 1-level search rearrangement saves a great deal of time compared to 0-level (ordinary backtracking), and show that 2-level saves time over 1-level on large problems. For such problems with 256 variables 2-level is better than 1-level by a factor of two.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288958</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LitwinSV89">
<author>Witold Litwin</author>
<author>Yehoshua Sagiv</author>
<author>K. Vidyasankar</author>
<title>Concurrency and Trie Hashing.</title>
<pages>597-614</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta26.html#LitwinSV89</url>
<abstract>The Trie Hashing (TH), defined by Litwin, is one of the fastest access methods for dynamic and ordered files. The hashing function is defined in terms of a trie, which is basically a binary tree where a character string is associated implicitly with each node. This string is compared with a prefix of the given key in the search process, and depending on the result either the left or the right child is chosen as the next node to visit. The leaf nodes point to buckets which contain the records. The buckets are on a disk, whereas the trie itself is in the core memory. In this paper we consider concurrent execution of the TH operations. In addition to the usual search, insertion and deletion operations, we also include range queries among the concurrent operations. Our algorithm locks only leaf nodes and at most two nodes need to be locked simultaneously by any operation regardless of the number of buckets being accessed. The modification required in the basic data structure in order to accommodate concurrent operations is very minor.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288973</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Howden78">
<author>William E. Howden</author>
<title>Algebraic Program Testing.</title>
<pages>53-66</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Howden78</url>
<abstract>An approach to the study of program testing is introduced in which program testing is treated as a special kind of equivalence problem. In this approach, classes of programs P * and associated classes of test sets T * are defined which have the property that if two programs P and Q in P * agree on a set of tests from T *, then P and Q are computationally equivalent. The properties of a class P * and the associated class T * can be thought of as defining a set of assumptions about a hypothetical correct version Q of a program P in P *. If the assumptions are valid then it is possible to prove the correctness of P by testing. The main result of the paper is an equivalence theorem for classes of programs which carry out sequences of computations involving the elements of arrays.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260923</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Clarke80">
<author>Edmund M. Clarke</author>
<title>Proving Correctness of Coroutines Without History Variables.</title>
<pages>169-188</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Clarke80</url>
<abstract>We examine the question of whether history variables are necessary in formal proofs of correctness for coroutines. History variables are special variables, which are added to a program to facilitate its proof by recording the sequence of states reached by the program during a computation; after the proof has been completed the history variables may be deleted. The use of such variables in correctness proofs was first suggested by Clint [CL73] in a paper entitled “Program Proving: Coroutines;” subsequently, history variables have been used by Owicki [OW76a] and Howard [HO75] in verifying concurrent programs and by Apt [APT77] in verifying sequential programs. We argue that recording the entire history of a computation in a single set of variables can actually complicate a correctness proof and should be avoided if possible. We propose a modification of Clint's axiom system and a strategy for constructing proofs that eliminates the need for history variables in verifying simple coroutines. Examples (including Clint's program “Histo”) are given to illustrate this technique of verifying coroutines, and our axiom system is shown to be sound and relatively complete with respect to an operational semantics for coroutines. Finally, we discuss extensions of the coroutine concept for which history variables do appear to be needed; we also discuss the question of whether such variables are necessary in verifying concurrent programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263992</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BackB98">
<author>Ralph-Johan Back</author>
<author>Michael J. Butler</author>
<title>Fusion and Simultaneous Execution in the Refinement Calculus.</title>
<pages>921-949</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035011/80350921.htm</ee>
<url>db/journals/acta/acta35.html#BackB98</url>
</article>
<article mdate="2012-08-13" key="journals/acta/Guttmann12">
<author>Walter Guttmann</author>
<title>Algebras for iteration and infinite computations.</title>
<pages>343-359</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We give axioms for an operation that describes iteration in various relational models of computations. The models differ in their treatment of finite, infinite and aborting executions, covering partial, total and general correctness and extensions thereof. Based on the common axioms we derive separation, refinement and program transformation results hitherto known from particular models, henceforth recognised to hold in many different models. We introduce a new model that independently describes the finite, infinite and aborting executions of a computation, and axiomatise an operation that extracts the infinite executions in this model and others. From these unifying axioms we derive explicit representations for recursion and iteration. We show that also the new model is an instance of our general theory of iteration. All results are verified in Isabelle heavily using automated theorem provers.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0162-2</ee>
<url>db/journals/acta/acta49.html#Guttmann12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DijkstraG86">
<author>Edsger W. Dijkstra</author>
<author>A. J. M. van Gasteren</author>
<title>A Simple Fixpoint Argument Without the Restriction to Continuity.</title>
<pages>1-7</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta23.html#DijkstraG86</url>
<abstract>In programming language semantics, the introduction of unbounded nondeterminacy, which amounts to the introduction of noncontinuous predicate transformers, is needed for dealing with such concepts as fair interleaving. With the semantics of the repetition given as the strongest solution of a fixpoint equation, the weakest precondition expressed in closed form would then require transfinite ordinals. Here, however, it is shown that, even in the case of unbounded nondeterminacy, the fundamental theorem about the repetition can be proved by a simple and quite elementary argument.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00268074</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HoareL74"> 
<author>C. A. R. Hoare</author>
<author>Peter E. Lauer</author>
<title>Consistent and Complementary Formal Theories of the Semantics of Programming Languages.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>135-153</pages>
<url>db/journals/acta/acta3.html#HoareL74</url>
<abstract>This paper presents a comparative study of different methods for formal description of programming languages. These methods have been applied to a simple but realistically usable programming language; the more abstract definitions have been proved to be consistent relative to the more concrete ones.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264034</ee>
</article>

<article mdate="2005-12-14" key="journals/acta/NicolaS05">
<author>Rocco De Nicola</author>
<author>Davide Sangiorgi</author>
<title>Types in concurrency.</title>
<pages>79-81</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract></abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0174-2</ee>
<url>db/journals/acta/acta42.html#NicolaS05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BrunoD85">
<author>John L. Bruno</author>
<author>Peter J. Downey</author>
<title>Probabilistic Bounds for Dual Bin-Packing.</title>
<pages>333-345</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta22.html#BrunoD85</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265685</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BestR81">
<author>Eike Best</author>
<author>Brian Randell</author>
<title>A Formal Model of Atomicity in Asynchronous Systems.</title>
<pages>93-124</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#BestR81</url>
<abstract>We propose a generalisation of occurrence graphs as a formal model of computational structure. The model is used to define the “atomic occurrence” of a program, to characterise “interference freeness” between programs, and to model error recovery in a decentralised system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289593</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Iliopoulos86">
<author>Costas S. Iliopoulos</author>
<title>Monte Carlo Circuits for the Abelian Permutation Group Intersection Problem.</title>
<pages>697-705</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#Iliopoulos86</url>
<abstract>We show that the problem of computing a basis for an abelian transitive permutation group is in N C k and also we show that the problem of computing a basis for an abelian permutation group and the problem of computing the intersection of two abelian groups acting on n points, can be solved in depth (log n)k on a Monte Carlo Boolean circuit of polynomial size. Moreover the latter two problems are shown to be in N C k in the restricted case of bounded number of generators.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264315</ee>
</article>
<article mdate="2015-06-08" key="journals/acta/GaravelLM15">
<author>Hubert Garavel</author>
<author>Fr&eacute;d&eacute;ric Lang</author>
<author>Radu Mateescu</author>
<title>Compositional verification of asynchronous concurrent systems using CADP.</title>
<pages>337-392</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>During the last decades, concurrency theory successfully developed salient concepts to formally model and soundly reason about distributed and parallel systems. In practice, however, most attempts at analyzing large systems face severe complexity issues, especially state explosion, which prevents to exhaustively enumerate reachable state spaces. Compositionality is the most promising approach to fight state explosion. In this article, we focus on finite-state verification techniques for asynchronous message-passing systems, highlighting the existence of multiple, diverse compositional techniques such as: compositional model generation, semi-composition and projection, automatic generation of projection interfaces, formula-dependent model generation, and partial model checking. These approaches have been implemented in the framework of the CADP (Construction and Analysis of Distributed Processes) software toolbox and applied to large-scale, industrial systems. A key point is the ability to combine several compositional techniques, as no single technique is sufficient to address all kinds of systems.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0226-1</ee>
<url>db/journals/acta/acta52.html#GaravelLM15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Kemp98">
<author>Rainer Kemp</author>
<title>Generating Words Lexicographically: An Average-Case Analysis.</title>
<pages>17-89</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta35.html#Kemp98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035001/80350017.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bertsch96">
<author>Eberhard Bertsch</author>
<title>An Observation on Suffix Redundancy in LL(1) Error Repair.</title>
<pages>631-639</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#Bertsch96</url>
<abstract>We give a simple grammatical characterization of the notion of suffix redundancy presented procedurally in a recent article by Fischer and Mauney. It is shown that certain properties of grammars related to suffix redundancy can be decided at parser generation time. Some suggestions concerning efficiency of repair attempts conclude the article.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036468</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KatzM75"> 
<author>Shmuel Katz</author>
<author>Zohar Manna</author>
<title>A Closer Look at Termination.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>333-352</pages>
<url>db/journals/acta/acta5.html#KatzM75</url>
<abstract>Several methods for proving that computer programs terminate are presented and illustrated. The methods considered involve (a) using the “no-infinitely-descending-chain” property of well-founded sets (Floyd's approach), (b) bounding a counter associated with each loop (loop approach), (c) showing that some exit of each loop must be taken (exit approach), or (d) inducting on the structure of the data domain (Burstall's approach). We indicate the relative merit of each method for proving termination or non-termination as an integral part of an automatic verification system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264565</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Allen82">
<author>Brian Allen</author>
<title>On the Costs of Optimal and Near-Optimal Binary Search Trees.</title>
<pages>255-263</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Allen82</url>
<abstract>We show that the cost of an optimal binary search tree can vary substantially, depending only on the left-to-right order imposed on the probabilities. We also prove that the costs of some common classes of near-optimal trees cannot be bounded above by the cost of an optimal tree plus a constant.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263193</ee>
</article>
<article mdate="2004-06-28" key="journals/acta/Markey04">
<author>Nicolas Markey</author>
<title>Past is for free: on the complexity of verifying linear temporal properties with past.</title>
<pages>431-458</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>We study the complexity of satisfiability and model checking problems for fragments of linear-time temporal logic with past (PLTL). We consider many fragments of PLTL, obtained by restricting the set of allowed temporal modalities, the use of negations or the nesting of future formulas into past formulas. Our results strengthen the widely accepted fact that “past is for free”, in the sense that allowing symmetric past-time modalities does not bring additional theoretical complexity. This result holds even for small fragments and even when nesting future formulas into past formulas.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0136-5</ee>
<url>db/journals/acta/acta40.html#Markey04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Strassen73"> 
<author>Volker Strassen</author>
<title>Berechnung und Programm. II.</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>64-79</pages>
<url>db/journals/acta/acta2.html#Strassen73</url>
<abstract>In §6 we define an algebraic equivalent of the notion of computation, in §§7, 8 we show that for a large class of computational problems no speed-up may be obtained by the use of branching, except for a small set of inputs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00571464</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/FarrowY86">
<author>Rodney Farrow</author>
<author>Daniel M. Yellin</author>
<title>A Comparison of Storage Optimizations in Automatically-Generated Attribute Evaluators.</title>
<pages>393-427</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta23.html#FarrowY86</url>
<abstract>Attribute grammars are a value-oriented, non-procedural extension to context-free grammars that facilitate the specification of translations whose domain is described by the underlying context-free grammar. Just as parsers for context-free languages can be automatically constructed from a context-free grammar, so can translators, called attribute evaluators, be automatically generated from an attribute grammar. A major obstacle to generating efficient attribute evaluators is that they typically use large amounts of memory to represent the attributed parse tree. In this report we investigate the problem of efficient representation of the attributed parse tree by analyzing and comparing the strategies of two systems that have been used to automatically generate a translator from an attribute grammar: the GAG system developed at the Universitat de Karlsruhe and the LINGUIST-86 system written at Intel Corporation. Our analysis will characterize the two strategies and highlight their respective strengths and weaknesses. Drawing on the insights given by this analysis, we propose a strategy for storage optimization in automatically generated attribute evaluators that not only incorporates the best features of both GAG and LINGUIST-86, but also contains novel features that address aspects of the problem that are handled poorly by both systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00267865</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MaurerW76">
<author>Hermann A. Maurer</author>
<author>Derick Wood</author>
<title>On Grammar Forms with Terminal Context.</title>
<pages>397-402</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#MaurerW76</url>
<abstract>A context-free grammar form G defines a family of context-free grammars {ie397-01}(G). In this paper {ie397-02}(G) is extended to give the family of terminal context grammars {ie397-03}(G), which were introduced by Book [4]. It is shown that the families of languages defined by {ie397-04}(G) and {ie397-05}(G) are equal when G is an ɛ-free context-free grammar form. This generalizes the result of Book [4] for context-free grammars and underlines the usefulness of the notion of grammar forms in formal language theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268140</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Vogler89">
<author>Walter Vogler</author>
<title>Failures Semantics and Deadlocking of Modular Petri Nets.</title>
<pages>333-348</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta26.html#Vogler89</url>
<abstract><ee>http://dx.doi.org/10.1007/BF00276021</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ArbibA79">
<author>Michael A. Arbib</author>
<author>Suad Alagic</author>
<title>Proof Rules for Gotos.</title>
<pages>139-148</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#ArbibA79</url>
<abstract>We offer a program specification format adapted to statements with multiple exits, and use it to present proof rules to replace the somewhat unsatisfactory treatment of jumps in [3]. We justify the “bridled” use of gotos in return exits, failure exits, and loops with jumps in the middle. To exemplify our methodology, we prove the function Lookup.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264021</ee>
</article>
<article mdate="2014-10-13" key="journals/acta/BelmonteGHP14">
<author>R&eacute;my Belmonte</author>
<author>Petr A. Golovach</author>
<author>Pim van 't Hof</author>
<author>Dani&euml;l Paulusma</author>
<title>Parameterized complexity of three edge contraction problems with degree constraints.</title>
<pages>473-497</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>For any graph class \(\mathcal{H}\), the \(\mathcal{H}\)-Contraction problem takes as input a graph \(G\) and an integer \(k\), and asks whether there exists a graph \(H\in \mathcal{H}\) such that \(G\) can be modified into \(H\) using at most \(k\) edge contractions. We study the parameterized complexity of \(\mathcal{H}\)-Contraction for three different classes \(\mathcal{H}\): the class \(\mathcal{H}_{\le d}\) of graphs with maximum degree at most \(d\), the class \(\mathcal{H}_{=d}\) of \(d\)-regular graphs, and the class of \(d\)-degenerate graphs. We completely classify the parameterized complexity of all three problems with respect to the parameters \(k\), \(d\), and \(d+k\). Moreover, we show that \(\mathcal{H}\)-Contraction admits an \(O(k)\) vertex kernel on connected graphs when \(\mathcal{H}\in \{\mathcal{H}_{\le 2},\mathcal{H}_{=2}\}\), while the problem is \(\mathsf{W}[2]\)-hard when \(\mathcal{H}\) is the class of \(2\)-degenerate graphs and hence is expected not to admit a kernel at all. In particular, our results imply that \(\mathcal{H}\)-Contraction admits a linear vertex kernel when \(\mathcal{H}\) is the class of cycles.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0204-z</ee>
<url>db/journals/acta/acta51.html#BelmonteGHP14</url>
</article>
<article mdate="2015-01-08" key="journals/acta/EhrenfeuchtR89">
<author>Andrzej Ehrenfeucht</author>
<author>Grzegorz Rozenberg</author>
<title>Partial (Set) 2-Structures. Part I: Basic Notions and the Representation Problem.</title>
<pages>315-342</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta27.html#EhrenfeuchtR89</url>
<abstract>The notion of a labeled partial 2-structure is introduced and studied. It generalizes the notion of a (labeled) 2-structure studied in [1] and [2] and it provides a convenient mathematical framework for studying graphs. In particular, a subclass of labeled partial 2-structures, the so-called labeled partial set 2-structures corresponds very closely to those graphs that are state spaces of concurrent systems. Part I of this paper investigates the basic theory of labeled partial 2-structures and it considers the problem of representing partial 2-structures as partial set 2-structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264611</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BaldoniHR98">
<author>Roberto Baldoni</author>
<author>Jean-Michel H&eacute;lary</author>
<author>Michel Raynal</author>
<title>Consistent Records in Asynchronous Computations.</title>
<pages>441-455</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta35.html#BaldoniHR98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035006/80350441.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CourtoisHP72"> 
<author>Pierre-Jacques Courtois</author>
<author>F. Heymans</author>
<author>David Lorge Parnas</author>
<title>Comments on "A Comparison of Two Synchronizing Concepts by Per Brinch Hansen".</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>375-376</pages>
<url>db/journals/acta/acta1.html#CourtoisHP72</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289516</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Reisig82">
<author>Wolfgang Reisig</author>
<title>Deterministic Buffer Synchronization of Sequential Processes.</title>
<pages>117-134</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Reisig82</url>
<abstract>Co-operation of sequential processes is one of the most widely known organization principles for distributed systems. We shall consider the class of those systems of sequential processes which communicate deterministically by means of buffers and discuss proof rules to decide whether or not deadlocks can occur in a given system of this type.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264434</ee>
</article>
<article mdate="2007-02-07" key="journals/acta/WisniewskiR07">
<author>Rafael Wisniewski</author>
<author>Martin Raussen</author>
<title>Geometric analysis of nondeterminacy in dynamical systems.</title>
<pages>501-519</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>This article intends to provide some new insights into concurrency using ideas from the theory of dynamical systems. Inherently discrete concurrency corresponds to a parallel continuous concept: a discrete state space corresponds to a differential manifold, an execution path corresponds to a flow line of a dynamical system. To model non-determinacy within dynamical systems, we introduce a new geometrical object, a section cone. A section cone is a convex set in the space of vector fields, all elements having the same singular points. We show that it is enough to consider flow lines of a single vector field in order to capture the behavior of all flow lines in the section cone up to homotopy (corresponding to equivalence of executions).</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0037-5</ee>
<url>db/journals/acta/acta43.html#WisniewskiR07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ershov76">
<author>Andrei P. Ershov</author>
<title>Axiomatics for Memory Allocation.</title>
<pages>61-75</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Ershov76</url>
<abstract>In the paper a method of labelling is applied to constructing a correct and complete transformation system which allows one, for any program scheme, to construct systematically any permissible memory allocation for variables of the scheme. Permissible memory allocations are assumed to be such allocations that preserve all information flow connections from the initial scheme.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263743</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/WedlerL98">
<author>Christoph Wedler</author>
<author>Christian Lengauer</author>
<title>On Linear List Recursion in Parallel.</title>
<pages>875-909</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035010/80350875.htm</ee>
<url>db/journals/acta/acta35.html#WedlerL98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LeeC94">
<author>Myung-Joon Lee</author>
<author>Kwang-Moo Choe</author>
<title>Boundedly LR( <i> k </i> )-conflictable Grammars.</title>
<pages>261-283</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta31.html#LeeC94</url>
<abstract>We present a new class of context-free grammars whose sentences are parsable in linear time and space. The class calledboundedly LR(k)-conflictable (BLRC(k)) grammars includes all LR(k) grammars, some non-LR unambiguous grammars and some boundedly ambiguous grammars. A context-free grammar is said to beBLRC(k) if the number of conflict occurences during LR(k) parsing for every sentence of the grammar is inherently bounded. A BLRC(k) grammar can be considered as a natural extension of an LR(k) grammar whose sentences can be parsed by an LR(k) manner with multiple stacks. We show that it is a decidable problem whether a context-free grammar is BLRC(k) for a givenk, whereas it is undecidable for arbitraryk. The result is derived from anLR(k) machine description grammar which describes the behavior of a give LR(k) parser in terms of the grammar symbols. The relationship between the class of BLRC(k) grammars (and languages) and those of other associated grammars (and languages), is also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01218406</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BijlsmaMW89">
<author>A. Bijlsma</author>
<author>P. A. Matthews</author>
<author>J. G. Wiltink</author>
<title>A Sharp Proof Rule for Procedures in wp Semantics.</title>
<pages>409-419</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#BijlsmaMW89</url>
<abstract>A proof rule for the procedure call is proposed that has the property that the precondition it defines is the weakest precondition that can be inferred solely from the procedure's specification. Thus the rule enforces exactly the abstraction introduced by the specification. Gries's proof rule for the procedure call is shown not to have this property in cases when the specification involves so-called specification variables.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289144</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MehlhornV84">
<author>Kurt Mehlhorn</author>
<author>Uzi Vishkin</author>
<title>Randomized and Deterministic Simulations of PRAMs by Parallel Machines with Restricted Granularity of Parallel Memories.</title>
<pages>339-374</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#MehlhornV84</url>
<abstract>The present paper provides a comprehensive study of the following problem. Consider algorithms which are designed for shared memory models of parallel computation (PRAMs) in which processors are allowed to have fairly unrestricted access patterns to the shared memory. Consider also parallel machines in which the shared memory is organized in modules where only one cell of each module can be accessed at a time. Problem. Give general fast simulations of these algorithms by these parallel machines.Each of our solutions answers two basic questions. (1) How to initially distribute the logical memory addresses of the PRAM, to be simulated, among the physical locations of the simulating machine? (2) How to compute the physical location of a logical address during the simulation?Randomization. The logical addresses are randomly distributed among the memory modules. This is done using universal hashing.Copies. We keep copies of each logical address in several memory modules.In a typical time cycle of the PRAM some number of memory requests has to be satisfied. As a primary objective, our simulations minimize the maximum number of memory requests which are assigned to the same module. Our solutions also optimize the following computational resources. They minimize the size of the physical memory, the time for computing the mapping from logical to physical addresses and the space for storing this mapping.We discuss extensions of our solutions to various PRAMs and various shared memory parallel machines. Our solution is also applicable to synchronous distributed machines with no shared memory where the processors can communicate through a bounded degree network.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264615</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Morris89a">
<author>Joseph M. Morris</author>
<title>Temporal Predicat Transformers and Fair Termination.</title>
<pages>287-313</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta27.html#Morris89a</url>
<abstract>It is usually assumed that implementations of nondeterministic programs may resolve the nondeterminacy arbitrarily. In some circumstances, however, we may wish to assume that the implementation is in some sense fair, by which we mean that in its long-term behaviour it does not show undue bias in forever favouring some nondeterministic choices over others. Under the assumption of fairness many otherwise failing programs become terminating. We construct various predicate transformer semantics of such fairly-terminating programs. The approach is based on formulating the familiar temporal operators always, eventually, and infinitely often as predicate transformers. We use these operators to construct a framework that accommodates many kinds of fairness, including varieties of socalled weak and strong fairness in both their all-levels and top-level forms. Our formalization of the notion of fairness does not exploit the syntactic shape of programs, and allows the familiar nondeterminacy and fair nondeterminacy to be arbitrarily combined in the one program. Invariance theorems for reasoning about fairly terminating programs are proved. The semantics admits probabilistic implementations provided that unbounded fairness is excluded.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264610</ee>
</article>
<article mdate="2005-03-14" key="journals/acta/MorvanR05">
<author>Christophe Morvan</author>
<author>Chloe Rispal</author>
<title>Families of automata characterizing context-sensitive languages.</title>
<pages>293-314</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>In the hierarchy of infinite graph families, rational graphs are defined by rational transducers with labelled final states. This paper proves that their traces are precisely context-sensitive languages and that this result remains true for synchronized rational graphs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://www.springerlink.com/index/10.1007/s00236-004-0160-0</ee>
<url>db/journals/acta/acta41.html#MorvanR05</url>
</article>
<article mdate="2003-11-25" key="journals/acta/MorimotoS01">
<author>Shin-ichi Morimoto</author>
<author>Masataka Sassa</author>
<title>Yet another generation of LALR parsers for regular right part grammars.</title>
<pages>671-697</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037009/10370671.htm</ee>
<url>db/journals/acta/acta37.html#MorimotoS01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/GelenbeP76"> 
<author>Erol Gelenbe</author>
<author>Guy Pujolle</author>
<title>The Behaviour of a Single-Queue in a General Queueing Network.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>123-136</pages>
<url>db/journals/acta/acta7.html#GelenbeP76</url>
<abstract>We develop a method based on diffusion approximations in order to compute, under general conditions, the queue length distribution of a single queue in a network of queues. Several applications of this approach to computer network performance analysis and to time-sharing systems are presented. The accuracy of model predictions are evaluated by comparison with known exact results in particular cases, with simulation experiments and with the approximation method of Kobayashi and Reiser.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265766</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LoizouT87">
<author>George Loizou</author>
<author>Peter Thanisch</author>
<title>Losslessness and Project-Join Constructibility in Relational Databases.</title>
<pages>131-144</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#LoizouT87</url>
<abstract>Checking a database scheme for the lossless join property with respect to a set, M, of multivalued dependencies (MVDs) is NP-hard. We prove that, for a class of MVDs that includes the set of projected full MVDs, this check can be performed in polynomial time. Even with a lossless database scheme and a consistent database, joining the set of relations in the database can take time and space that is exponential in the size of the relation finally obtained. Joining the set of relations of such a database can be performed in polynomial time if the database scheme is project-join constructible with respect to M. We prove that project-join constructibility, a stricter condition than the lossless join property, can be detected in a database scheme in polynomial time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264360</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bayer72"> 
<author>Rudolf Bayer</author>
<title>Symmetric Binary B-Trees: Data Structure and Maintenance Algorithms.</title>
<pages>290-306</pages>
<year>1972</year> 
<volume>1</volume> 
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta1.html#Bayer72</url>
<abstract>A class of binary trees is described for maintaining ordered sets of data. Random insertions, deletions, and retrievals of keys can be done in time proportional to log N where N is the cardinality of the data-set. Symmetric B-Trees are a modification of B-trees described previously by Bayer and McCreight. This class of trees properly contains the balanced trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289509</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Loveland85">
<author>Donald W. Loveland</author>
<title>Performance Bounds for Binary Testing with Arbitrary Weights.</title>
<pages>101-114</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta22.html#Loveland85</url>
<abstract>Binary testing concerns finding good algorithms to solve the class of binary identification problems. A binary identification problem has as input a set of objects, including one regarded as distinguished (e.g., faulty), for each object an a priori estimate that it is the distinguished object, and a set of tests. Output is a testing procedure to isolate the distinguished object. One seeks minimal cost testing procedures where cost is the average cost of isolation, summed over all objects. This is a problem schema for the diagnosis problem: applications occur in medicine, systematic biology, machine fault location, quality control and elsewhere.In this paper we extend work of Garey and Graham to assess the capability of a fast approximation rule, the binary splitting rule, to give near optimal testing procedures when the a priori estimates are arbitrary. We find conditions on the test set such that the approximation error reduces nearly to that of the equally likely a priori estimate case of Garey and Graham and find another upper bound on approximation error for the same test set conditions which works very well under a priori estimate assumptions where the first result is poor.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290148</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Devillers95"> 
<author>Raymond R. Devillers</author>
<title>S-Invariant Analysis of General Recursive Petri Boxes.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>4</number>
<year>1995</year> 
<pages>313-345</pages>
<url>db/journals/acta/acta32.html#Devillers95</url>
<abstract>The paper shows how to synthesise S-invariants and S-components for Petri Boxes constructed through general recursions, from S-invariants/S-components of their constituents. The construction is based on the tree-structure of the interface places used to define this operator and extends similar results obtained for the refinement operator. Emphasis is put on deriving coverability results; these results are then used to show that all the nets obtained through refinements and recursions from a family covered by S-components are self-concurrency free, at most 2-safe and exhibit a generalised emptiness property; in particular, this is the case for the nets obtained in the translation of the process algebra of Box expressions.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178382</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/HofstedeLW97">
<author>Arthur H. M. ter Hofstede</author>
<author>E. Lippe</author>
<author>Theo P. van der Weide</author>
<title>Applications of a Categorical Framework for Conceptual Data Modelling.</title>
<pages>927-963</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<url>db/journals/acta/acta34.html#HofstedeLW97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034012/70340927.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Biela88">
<author>Andrzej Biela</author>
<title>Program-Substitution and Admissibility of Rules in Algorithmic Logic.</title>
<pages>439-473</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta25.html#Biela88</url>
<abstract>The purpose of this work is to show a point of view upon the notions of program-substitution and admissibility of rules which are the tools for proving properties of programs of algorithmic logic and the so-called extended algorithmic logic with quantifiers and with non-deterministic programs. We prove that the set of theses of algorithmic logic is closed under each program-substitution. This substitution rule allows us to formulate a problem of algorithmic structural completeness as a question about derivability of all structural, finitary and admissible rules. We prove the incompleteness of algorithmic logic strengthened by the substitution rule and its algorithmically structural completeness.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02737110</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/IbarraT94">
<author>Oscar H. Ibarra</author>
<author>Nicholas Q. Tr&acirc;n</author>
<title>On Communication-Bounded Synchronized Alternating Finite Automata.</title>
<pages>315-327</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta31.html#IbarraT94</url>
<abstract>We continue the study of communication-bounded synchronized alternating finite automata (SAFA), first considered by Hromkovič et al. We show that to accept a nonregular language, an SAFA needs to generate at least Ω(log logn) communication symbols infinitely often; furthermore, a synchronized alternating finite automaton without nondeterminism (SUFA) needs to generate at leastΩ(log logn) communication symbols infinitely often for some constantk≥1. We also show that these bounds are tight.Next, we establish dense hierarchies of these machines on the function bounding the number of communication symbols. Finally, we give a characterization of NP in terms of communication-bounded multihead synchronized alternating finite automata, namely, NP = ⋃ k≥1 L(SAFA(k-heads,n k -com)). This result recasts the relationships between P, NP, and PSPACE in terms of multihead synchronized alternating finite automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178509</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hac93">
<author>Anna Hac</author>
<title>Performance and Reliability Improvement by Using Asynchronous Algorithms in Disk Buffer Cache Memory.</title>
<pages>131-146</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta30.html#Hac93</url>
<abstract>This paper proposes performance and reliability improvement by using new algorithms for asynchronous operations in disk buffer cache memory. These algorithms allow for writing the files into the buffer cache by the processes and consider the number of active processes in the system and the length of the queue to the disk buffer cache. Writing the contents of the buffer cache to the disk depends on the system load and the write activity. Performance and reliability measures including the elapsed time of writing a file into the buffer cache, the waiting time to start writing a file, and the mean number of blocks written to the disk between system failures are used to show performance and reliability improvement by using the algorithms. Sensitivity analysis is used to influence the algorithms' design. Examples of real systems are used to show the numerical results of performance and reliability improvement in different systems with various disk cache parameters and file sizes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178577</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/LuttgenC15">
<author>Gerald L&uuml;ttgen</author>
<author>Flavio Corradini</author>
<title>Special issue on "Comprehending asynchrony in specification and analysis" dedicated to Walter Vogler on the occasion of his 60th birthday.</title>
<pages>107-108</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0214-5</ee>
<url>db/journals/acta/acta52.html#LuttgenC15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DingW93">
<author>Yuzheng Ding</author>
<author>Mark Allen Weiss</author>
<title>The Relaxed min-max Heap.</title>
<pages>215-231</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#DingW93</url>
<abstract>A data structure that implements a mergeable double-ended priority queue, namely therelaxed min-max heap, is presented. A relaxed min-max heap ofn items can be constructed inO(n) time. In the worst case, operationsfind_min() andfind_max() can be performed in constant time, while each of the operationsmerge(),insert(),delete_min(),delete_max(),decrease_key(), anddelete_key() can be performed inO(logn) time. Moreover,insert() hasO(1) amortized running time. If lazy merging is used,merge() will also haveO(1) worst-case and amortized time. The relaxed min-max heap is the first data structure that achieves these bounds using only two pointers (puls one bit) per item.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179371</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Commentz-WalterS80">
<author>Beate Commentz-Walter</author>
<author>J&uuml;rgen Sattler</author>
<title>Size-depht Tradeoff in Non-monotone Boolean Formulae.</title>
<pages>257-269</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Commentz-WalterS80</url>
<abstract>Formula size and depth are two important complexity measures of Boolean functions. We study the tradeoff between those two measures:We give an infinite set of Boolean functions and show for nearly each of them: There is no formula over “and”, “or”, “negation” computing it optimal with respect to both measures. That implies a logarithmic lower bound on circuit depth.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264256</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChandraKMZ83">
<author>Ashok K. Chandra</author>
<author>Lawrence T. Kou</author>
<author>George Markowsky</author>
<author>Shmuel Zaks</author>
<title>On Sets of Boolean <i> n </i> -Projections Surjective.</title>
<pages>103-111</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#ChandraKMZ83</url>
<abstract>Given a set, S, of Boolean n-vectors, one can choose k of the n coordinate positions and consider the set of k-vectors which results by keeping only the designated k positions of each vector, i.e., from k-projecting S. In this paper, we study the question of finding sets S as small as possible such that every k-projection of S yields all the 2 k possible k-vectors. We solve this problem constructively and almost optimally for k=2 and all n. For k≧3, the constructive solutions we describe are much larger than an O(k 2 k log n) nonconstructive upper bound which we derive. The nonconstructive approach allows us to generate fairly small sets S which have a very high probability of having the surjective k-projection property.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264296</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Arnold82">
<author>Andr&eacute; Arnold</author>
<title>Synchronized Behaviours of Processes and Rational Relations.</title>
<pages>21-29</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Arnold82</url>
<abstract>Synchronized behaviours of processes, specified in three different ways, are compared with rational relations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262973</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BabichJ78">
<author>Wayne A. Babich</author>
<author>Mehdi Jazayeri</author>
<title>The Method of Attributes for Data Flow Analysis: Part I. Exhaustive Analysis.</title>
<pages>245-264</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#BabichJ78</url>
<abstract>A new technique for global data flow analysis, called the method of attributes, is introduced. The technique is iterative and operates on a parse tree representation of the program. Application to dead variable and available expression analysis is shown.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264319</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wand80">
<author>Mitchell Wand</author>
<title>First-Order Identities as a Defining Language.</title>
<pages>337-357</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Wand80</url>
<abstract>Inverting the adage that a data type is just a simple programming language, we take the position that a programming language is, semantically, just a complex data type; evaluation of a program is just another operation in the data type. The algebraic approach to data types may then be applied. We make a distinction between specification and modelling, and we emphasize the use of first-order identities as a specification language rather than as a tool for model-building. Denotational and operational semantics are discussed. Techniques are introduced for proving the equivalence of specifications. Reynolds' lambda-calculus interpreter is analyzed as an example.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286491</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Lubachevsky84">
<author>Boris D. Lubachevsky</author>
<title>An Approach to Automating the Verification of Compact Parallel Coordination Programs I.</title>
<pages>125-169</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Lubachevsky84</url>
<abstract>A class of parallel coordination programs for a shared memory asynchronous parallel processor is considered. These programs use the operation Fetch & Add which is the basic primitive for the NYU-Ultracomputer. A correctness proof for the considered programs must be done for arbitrary number N of processing elements since the Ultracomputer design includes thousands of PEs.A reachability set description (RSD) is introduced, in which all reachable states of a program (exponential function of N) are collapsed into a fixed number of metastates. The transitions between these metastates are then specified. By using such notation, it becomes feasible to prove various temporal properties of a parallel program, in particular, the absence of livelock. The concept of a compact parallel program is introduced. Roughly speaking a parallel program executed by N PEs is compact if there exists a boundary T independent of N such that any state of this program is reachable within time T. Compactness may also be understood as the finiteness of the expansion for the strongest invariant in the least fixpoint theory, where such finiteness is uniform over N. A program that builds RSDs for compact parallel programs and examples of proofs generated by this program are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289237</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Ben-AmramJ00">
<author>Amir M. Ben-Amram</author>
<author>Neil D. Jones</author>
<title>Computational complexity via programming languages: constant factors do matter.</title>
<pages>83-120</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037002/00370083.htm</ee>
<url>db/journals/acta/acta37.html#Ben-AmramJ00</url>
</article>
<article mdate="2012-12-07" key="journals/acta/LinY02">
<author>Huimin Lin</author>
<author>Wang Yi 0001</author>
<title>Axiomatising timed automata.</title>
<pages>277-305</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038004/20380277.htm</ee>
<url>db/journals/acta/acta38.html#LinY02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Bause96">
<author>Falko Bause</author>
<title>On the Analysis of Petri Nets with Static Priorities.</title>
<pages>669-685</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta33.html#Bause96</url>
<abstract>Priority specifications offer a convenient description technique to resolve conflicts in favour of particular actions. Apart from being employed for the specification of the functional behaviour of a system, priorities have also become important in the field of performance analysis using stochastic Petri nets. Here they are implicitly given due to the separation of transitions into immediate and timed. In the performance analysis of such stochastic Petri nets specific properties, like liveness and existence of home states, are of major interest, because they ensure the applicability of a Markovian based analysis. Since several efficient analysis techniques have been developed for Petri nets without priorities, our interest is in using these techniques also for the priority case. This paper shows that positive properties of a net such as liveness and the existence of home states do also hold for the net with static priorities, if a simple condition is imposed on the priority relation.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036470</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ChoyW78">
<author>David M. Choy</author>
<author>C. K. Wong</author>
<title>Optimal alpha-beta Trees with Capacity Constraint.</title>
<pages>273-296</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#ChoyW78</url>
<abstract>We consider a specific kind of binary trees with weighted edges. Each right edge has weight α while each left edge has weight β. Furthermore, no path in the tree is allowed to contain L or more consecutive α-edges, where L ≧ 1 is fixed. Given, α, β, L and the number of nodes n, an optimal tree is one which minimizes the total weighted path length. Algorithms for constructing an optimal tree as well as all optimal trees for given α, β, L and n are proposed and analyzed. Timing and storage requirements are also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264321</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CherkasovaHR95"> 
<author>Ludmila Cherkasova</author>
<author>Rodney R. Howell</author>
<author>Louis E. Rosier</author>
<title>Bounded Self-Stabilizing Petri Nets.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>3</number>
<year>1995</year> 
<pages>189-207</pages>
<url>db/journals/acta/acta32.html#CherkasovaHR95</url>
<abstract>We investigate the property of self-stabilization in bounded Petri nets. We give characterizations for both self-stabilizing bounded ordinary Petri nets (i.e., Petri nets without multiple arcs) and self-stabilizing bounded general Petri nets (i.e., Petri nets with multiple arcs). These characterizations allow us to determine the complexity of deciding self-stabilization for each of these classes. In particular, we show the self-stabilization problem to be PTIME-complete for bounded ordinary Petri nets and PSPACE-complete for bounded general Petri nets.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178259</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Langmaack82">
<author>Hans Langmaack</author>
<title>On Termination Problems for Finitely Interpreted ALGOL-like Programs.</title>
<pages>79-108</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Langmaack82</url>
<abstract>Main issue is: The actual termination problem for finitely interpreted non-deterministic ALGOL-like programs without procedure selfapplication and without global variables is algorithmically solvable. This result offers a new and substantial application of a theorem of Lipton: The above mentioned programs, restricted to deterministic ones, have a sound and relatively complete Hoare logic. So we conjecture: ALGOL-like programs (even non-deterministic ones with formal sharing of variables) without procedure selfapplication and without global variables have a sound and relatively complete Hoare deduction system with axioms and inference rules which reflect the syntactical structure of programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625282</ee>
</article>
<article mdate="2006-05-10" key="journals/acta/TrombettaM06">
<author>Alberto Trombetta</author>
<author>Danilo Montesi</author>
<title>Equivalences and optimizations in an expressive XSLT subset.</title>
<pages>515-539</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>XML is the standard data interchange format and XSLT is the W3C proposed standard for transforming and restructuring XML documents. It turns out that XSLT has very powerful query capabilities as well. Hovewer, due to its complex syntax and lack of formal specification, it is not a trivial task to decide whether two XSLT stylesheets yield the same result, even if for an XSLT subset. We isolate such fragment, powerful enough for expressing several interesting queries and for manipulating XML documents and show how to translate them into queries expressed in a properly extended version of TAX, a powerful XML query algebra, for which we provide a collection of equivalence rules. It is then possible to reason about XSLT equivalences, by translating XSLT stylesheets into XTAX expressions and then statically verifying their equivalence, by means of the mentioned equivalence rules.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-005-0004-6</ee>
<url>db/journals/acta/acta42.html#TrombettaM06</url>
</article>
<article mdate="2009-05-20" key="journals/acta/BaierM97">
<author>Christel Baier</author>
<author>Mila E. Majster-Cederbaum</author>
<title>Metric Semantics from Partial Order Semantics.</title>
<pages>701-735</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034009/70340701.htm</ee>
<url>db/journals/acta/acta34.html#BaierM97</url>
</article>
<article mdate="2003-11-25" key="journals/acta/AndreiKN00">
<author>Stefan Andrei</author>
<author>Manfred Kudlek</author>
<author>Radu Stefan Niculescu</author>
<title>Some results on the Collatz problem.</title>
<pages>145-160</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037002/00370145.htm</ee>
<url>db/journals/acta/acta37.html#AndreiKN00</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Menzel73"> 
<author>Wolfgang Menzel</author>
<title>An Extension of the Theory of Learning Systems</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>357-381</pages>
<url>db/journals/acta/acta2.html#Menzel73</url>
</article>


<article mdate="2012-04-26" key="journals/acta/LescanneP12">
<author>Pierre Lescanne</author>
<author>Matthieu Perrinel</author>
<title>"Backward" coinduction, Nash equilibrium and the rationality of escalation.</title>
<pages>117-137</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>We study a new application of coinduction, namely escalation which is a typical feature of infinite games. Therefore tools conceived for studying infinite mathematical structures, namely those deriving from coinduction are essential. Here we use coinduction, or backward coinduction (to show its connection with the same concept for finite games) to study carefully and formally infinite games especially the so-called dollar auction, which is considered as the paradigm of escalation. Unlike what is commonly admitted, we show that, provided one assumes that the other agent will always stop, bidding is rational, because it results in a subgame perfect equilibrium. We show that this is not the only rational strategy profile (the only subgame perfect equilibrium). Indeed if an agent stops and will stop at every step, we claim that he is rational as well, if one admits that his opponent will never stop, because this corresponds to a subgame perfect equilibrium. Amazingly, in the infinite dollar auction game, the behavior in which both agents stop at each step is not a Nash equilibrium, hence is not a subgame perfect equilibrium, hence is not rational. The right notion of rationality we obtain fits with common sense and experience and removes all feeling of paradox.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0153-3</ee>
<url>db/journals/acta/acta49.html#LescanneP12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LipskiP81">
<author>Witold Lipski Jr.</author>
<author>Franco P. Preparata</author>
<title>Efficient Algorithms for Finding Maximum Matchings in Convex Bipartite Graphs and Related Problems.</title>
<pages>329-346</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#LipskiP81</url>
<abstract>A bipartite graph G=(A, B, E) is convex on the vertex set A if A can be ordered so that for each element b in the vertex set B the elements of A connected to b form an interval of A; G is doubly convex if it is convex on both A and B. Letting ¦A¦=m and ¦B¦=n, in this paper we describe maximum matching algorithms which run in time O(m + nA(n)) on convex graphs (where A(n) is a very slowly growing function related to a functional inverse of Ackermann's function), and in time O(m+n) on doubly convex graphs. We also show that, given a maximum matching in a convex bipartite graph G, a corresponding maximum set of independent vertices can be found in time O(m+n). Finally, we briefly discuss some generalizations of convex bipartite graphs and some extensions of the previously discussed techniques to instances in scheduling theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264533</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GelenbeFT86">
<author>Erol Gelenbe</author>
<author>David Finkel</author>
<author>Satish K. Tripathi</author>
<title>Availability of a Distributed Computer System with Failures.</title>
<pages>643-655</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#GelenbeFT86</url>
<abstract>A model for distributed systems with failing components is presented. Each node may fail and during its recovery the load is distributed to other nodes that are up. The model assumes periodic checkpointing for error recovery and testing of the status of other nodes for the distribution of load. We consider the availability of a node, which is the proportion of time a node is available for processing, as the performance measure. A methodology for optimizing the availability of a node with respect to the checkpointing and testing intervals is given. A decomposition approach that uses the steady-state flow balance condition to estimate the load at a node is proposed. Numerical examples are presented to demonstrate the usefulness of the technique. For the case in which all nodes are identical, closed form solutions are obtained.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264311</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Moll80">
<author>Karl-Rudolf Moll</author>
<title>Left Context Precedence Grammars.</title>
<pages>317-335</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Moll80</url>
<abstract>Left context precendence grammars which are defined in this paper are a proper subclass of the precedence grammars and contain properly the simple precedence grammars. Left context precedence grammars need not be uniquely invertible. The parsing algorithm developed for left context precedence languages works with linear time and has the viable prefix property which is a stronger property than the correct prefix property.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00286490</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Schmidt87">
<author>Ursula Schmidt</author>
<title>Long Unavoidable Patterns.</title>
<pages>433-445</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#Schmidt87</url>
<abstract>We examine long unavoidable patterns, unavoidable in the sense of Bean, Ehrenfeucht, McNulty. Zimin and independently Schmidt have shown that there is only one unavoidable pattern of length 2 n -1 on an alphabet with n letters; this pattern is a “quasi-power” in the sense of Schützenberger. We characterize the unavoidable words of length 2 n -2 and 2 n -3. Finally we show that every sufficiently long unavoidable word has a certain “quasi-power” as a subword.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292112</ee>
</article>
<article mdate="2010-01-04" key="journals/acta/ShahriarL09">
<author>Md. Sumon Shahriar</author>
<author>Jixue Liu</author>
<title>Preserving key in XML data transformation.</title>
<pages>475-507</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>Transformation of XML data is an important task in data exchange, data publishing and data integration. Specifically in data integration, data in XML sources is transformed to match the target schema. Some of these sources have XML keys defined. When the data is transformed, the keys also need to be transformed for constraint comparisons, consistency checking and unification in the target schema. Thus, how the keys are transformed, and whether the transformed keys are valid and preserved to the target schema are important problems in XML data transformation and integration. Towards this problem, we firstly define XML keys and their satisfactions. We then study how keys are transformed and whether transformed keys are valid when a source schema is transformed to a target schema. Finally we show whether the transformed keys are satisfied by the transformed document.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0101-z</ee>
<url>db/journals/acta/acta46.html#ShahriarL09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hotz74"> 
<author>G&uuml;nter Hotz</author>
<title>Sequentielle Analyse kontextfreier Sprachen.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>55-75</pages>
<url>db/journals/acta/acta4.html#Hotz74</url>
<abstract>Sequential analysis of context-free languages. Since 1965 several methods to solve the word problem for context-free languages in no more than cn 3steps have been published where c is a constant and n the length of the word [2, 5, 7]. The procedure to be described is a sequential procedure that means that the word which is to be analyzed has to be read monotonic from left to right and that the word problem is decided for each partial word. The method consists in constructing a “growing” automaton whose wiring (in a physical way of speaking) grows only quadratically. From a monotonicity of property of signal propagation in our automata we can conclude that the procedure can be implemented on a RAM (random access machine) in such a way that the word problem is decided in at most cn 3steps.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288936</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/DolevGS99">
<author>Shlomi Dolev</author>
<author>Mohamed G. Gouda</author>
<author>Marco Schneider</author>
<title>Memory Requirements for Silent Stabilization.</title>
<pages>447-462</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036006/90360447.htm</ee>
<url>db/journals/acta/acta36.html#DolevGS99</url>
</article>
<article mdate="2003-11-25" key="journals/acta/KariPRSY98">
<author>Lila Kari</author>
<author>Gheorghe Paun</author>
<author>Grzegorz Rozenberg</author>
<author>Arto Salomaa</author>
<author>Sheng Yu</author>
<title>DNA Computing, Sticker Systems, and Universality.</title>
<pages>401-420</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta35.html#KariPRSY98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035005/80350401.htm</ee>
</article>
<article mdate="2012-09-23" key="journals/acta/LaurentLS97">
<author>Dominique Laurent</author>
<author>Viet Phan Luong</author>
<author>Nicolas Spyratos</author>
<title>The Use of Deleted Tuples in Database, Querying and Updating.</title>
<pages>905-925</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<url>db/journals/acta/acta34.html#LaurentLS97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034012/70340905.htm</ee>
<note>Erratum: Acta Informatica 35(6): 541 (1998)</note>
</article>
<article mdate="2011-01-11" key="journals/acta/TchaLL92">
<author>Dong-wan Tcha</author>
<author>Bum-il Lee</author>
<author>Toung-duck Lee</author>
<title>Processors Selection and Traffic Splitting in a Parallel Processors System.</title>
<pages>415-423</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#TchaLL92</url>
<abstract>This paper considers a general design problem for a parallel processors system which consists of a set of non-homogeneous potential processors and a set of traffic distributing points. For this problem, two levels of technology choice are made: 1) which candidate processors to establish with capacity option, 2) how to allocate the incoming traffic among established processors generated at each distributing point. The associated model is formulated as a linear fractional integer program whose objective is to minimize the maximum mean queue length on any established processor, while satisfying a side constraint such as budget constraint. Within the framework of branch and bound procedure, fractional subproblems are optimized by solving a sequence of linear programming problems. Computational experience with randomly generated 25 test problems is presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193575</ee>
</article>
<article mdate="2015-07-14" key="journals/acta/FulopV97">
<author>Zolt&aacute;n F&uuml;l&ouml;p 0001</author>
<author>S&aacute;ndor V&aacute;gv&ouml;lgyi</author>
<title>Minimal Equational Representations of Recognizable Tree Languages.</title>
<pages>59-84</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta34.html#FulopV97</url>
<abstract> A tree language is congruential if it is the union of finitely many classes of a finitely generated congruence on the term algebra. It is well known that congruential tree languages are the same as recognizable tree languages. An equational representation is an ordered pair (E, P) , where E is either a ground term equation system or a ground term rewriting system, and P is a finite set of ground terms. We say that (E, P) represents the congruential tree language L which is the union of those ?* E -classes containing an element of P, i.e., for which L=⋃{[p]? * E ∣p∈P}. We define two sorts of minimality for equational representations. We introduce the cardinality vector (∣E∣, ∣P∣) of an equational representation (E, P). Let ? l and ? a denote the lexicographic and antilexicographic orders on the set of ordered pairs of nonnegative integers, respectively. Let L be a congruential tree language. An equational representation (E, P) of L with ? l -minimal (? a -minimal) cardinality vector is called ? l -minimal (? a -minimal). We compute, for an L given by a deterministic bottom-up tree automaton, both a ? l -minimal and a ? a -minimal equational representation of L.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050073</ee>
</article>
<article mdate="2005-01-25" key="journals/acta/LiT04">
<author>Zheng-Zhu Li</author>
<author>Y. S. Tsai</author>
<title>Three-element codes with one d-primitive word.</title>
<pages>171-180</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>In the field of combinatorics on words, it is known that {u, v}, the language with two words is a code if and only if \(uv\neq vu\). But up to now general characterization for codes consisting of any three words has not been found. In 1998, Fan, Shyr and Yu provided a characterization for codes consisting of three d-primitive words. In this paper, we give characterizations for a code with three words in which one of the words is d-primitive.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0155-x</ee>
<url>db/journals/acta/acta41.html#LiT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Paul74"> 
<author>Wolfgang J. Paul</author>
<title>Boolesche Minimalpolynome und &Uuml;berdeckungsprobleme.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>321-336</pages>
<url>db/journals/acta/acta4.html#Paul74</url>
<abstract>The main difficulty in finding minimal Boolean polynomials for given switching functions comes from the evaluation of the table of prime implicants.Switching functions with “don't care”-points and those without yield essentially the same class of tables of prime implicants.A polynomial, which is minimal with respect to the costfunction, which counts the entries of conjunctions and disjunctions, must not be a polynomial with a minimal number of prime implicants.Each binary matrix with at least one 1 in each row and column is the prime implicant table of some switching-function. Moreover this function can be constructed such that its prime implicants have arbitrarily prescribed costs.Finally we make some remarks about the complexity of algorithms, which—given the graph of a switching function—find a minimal polynomial of this function.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289615</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/BayerM72"> 
<author>Rudolf Bayer</author>
<author>Edward M. McCreight</author>
<title>Organization and Maintenance of Large Ordered Indices.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>173-189</pages>
<url>db/journals/acta/acta1.html#BayerM72</url>
<abstract>Organization and maintenance of an index for a dynamic random access file is considered. It is assumed that the index must be kept on some pseudo random access backup store like a disc or a drum. The index organization described allows retrieval, insertion, and deletion of keys in time proportional to logk I where I is the size of the index and k is a device dependent natural number such that the performance of the scheme becomes near optimal. Storage utilization is at least 50% but generally much higher. The pages of the index are organized in a special datastructure, so-called B-trees. The scheme is analyzed, performance bounds are obtained, and a near optimal k is computed. Experiments have been performed with indexes up to 100000 keys. An index of size 15000 (100000) can be maintained with an average of 9 (at least 4) transactions per second on an IBM 360/44 with a 2311 disc.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288683</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/BrunoC97">
<author>John L. Bruno</author>
<author>Edward G. Coffman Jr.</author>
<title>Optimal Fault-Tolerant Computing on Multiprocessor Systems.</title>
<pages>881-904</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>12</number>
<url>db/journals/acta/acta34.html#BrunoC97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034012/70340881.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Diekert86">
<author>Volker Diekert</author>
<title>Investigations on Hotz Groups for Arbitrary Grammars.</title>
<pages>679-698</pages>
<year>1986</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta22.html#Diekert86</url>
<abstract>The Hotz group H(G) and the Hotz monoid M(G) of an arbitrary grammar G=(V, X, P, S) are defined by H(G)=F(V∪X)/P and M(G) =(V∪X)*/P respectively. A language L⊂X* is called a language with Hotz isomorphism if there exists a grammar G with L=L(G) such that the natural homomorphism F(X)/L→H(G) is an isomorphism. The main result of this paper states that homomorphic images of sentential form languages are languages with Hotz isomorphism. This is a generalization of a result of Frougny, Sakarovitch, and Valkema on context-free languages.Hotz groups are used to obtain lower bounds for the number of productions which are needed to generate a language. Further it is shown that there are languages with Hotz isomorphism without being a homomorphic image of a sentential form language, and there are context-sensitive languages without Hotz isomorphism. The theory of Hotz monoids is used to get some results on languages generated by grammars with a symmetric set of rules.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263651</ee>
</article>
<article mdate="2008-01-15" key="journals/acta/ScottJE07">
<author>Elizabeth Scott</author>
<author>Adrian Johnstone</author>
<author>Giorgios Economopoulos</author>
<title>BRNGLR: a cubic Tomita-style GLR parsing algorithm.</title>
<pages>427-461</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>Tomita-style generalised LR (GLR) algorithms extend the standard LR algorithm to non-deterministic grammars by performing all possible choices of action. Cubic complexity is achieved if all rules are of length at most two. In this paper we shall show how to achieve cubic time bounds for all grammars by binarising the search performed whilst executing reduce actions in a GLR-style parser. We call the resulting algorithm Binary Right Nulled GLR (BRNGLR) parsing. The binarisation process generates run-time behaviour that is related to that shown by a parser which pre-processes its grammar or parse table into a binary form, but without the increase in table size and with a reduced run-time space overhead. BRNGLR parsers have worst-case cubic run time on all grammars, linear behaviour on LR(1) grammars and produce, in worst-case cubic time, a cubic size binary SPPF representation of all the derivations of a given sentence.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0054-z</ee>
<url>db/journals/acta/acta44.html#ScottJE07</url>
</article>
<article mdate="2015-07-14" key="journals/acta/FulopV14">
<author>Zolt&aacute;n F&uuml;l&ouml;p 0001</author>
<author>Heiko Vogler</author>
<title>Forward and backward application of symbolic tree transducers.</title>
<pages>297-325</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We consider symbolic tree automata (sta) and symbolic regular tree grammars and their corresponding classes of tree languages: s-recognizable tree languages and s-regular tree languages. We prove that the following three classes are equal: the class of s-recognizable tree languages, the class of s-regular tree languages, and the class of images of classical recognizable tree languages under tree relabelings. Moreover, the sta and the recently introduced variable tree automata are incomparable with respect to their recognition power. Also, we consider symbolic tree transducers (stt) and prove the following theorems. The syntactic composition of two stt computes the composition of the tree transformations computed by each stt, provided that (1) the first one is deterministic or the second one is linear and (2) the first one is total or the second one is nondeleting. Backward application of an stt to any s-recognizable tree language yields an s-recognizable tree language. There is a linear stt of which the range is not an s-recognizable tree language. Forward application of simple and linear stt preserves s-recognizability. A restricted version of both the type checking problem of simple and linear stt, and the inverse type checking problem of arbitrary stt is decidable. Since we deal with trees over infinite alphabets, we require appropriate conditions on sta and stt such that all the proofs are constructive.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0197-7</ee>
<url>db/journals/acta/acta51.html#FulopV14</url>
</article>
<article mdate="2010-01-04" key="journals/acta/QuesadaS09">
<author>Argimiro Arratia Quesada</author>
<author>Iain A. Stewart</author>
<title>On the power of deep pushdown stacks.</title>
<pages>509-531</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract>Inspired by recent work of Meduna on deep pushdown automata, we consider the computational power of a class of basic program schemes, NPSDS s , based around assignments, while-loops and non-deterministic guessing but with access to a deep pushdown stack which, apart from having the usual push and pop instructions, also has deep-push instructions which allow elements to be pushed to stack locations deep within the stack. We syntactically define sub-classes of NPSDS s by restricting the occurrences of pops, pushes and deep-pushes and capture the complexity classes NP and PSPACE. Furthermore, we show that all problems accepted by program schemes of NPSDS s are in EXPTIME.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0103-x</ee>
<url>db/journals/acta/acta46.html#QuesadaS09</url>
</article>
<article mdate="2011-01-11" key="journals/acta/KamedaG77"> 
<author>Hisao Kameda</author>
<author>C. C. Gotlieb</author>
<title>A Feedback-Coupled Resource Allocation Policy for Multiprogrammed Computer Systems.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>341-357</pages>
<url>db/journals/acta/acta8.html#KamedaG77</url>
<abstract>An earlier paper on an adaptive workload balancing strategy to achieve efficient resource utilization is extended to include memory cost. The scheme corrects for the imbalance in resource utilization by bringing into play the “Invisible Hand” of classical economics. In this framework, the memory price and the bid, W ij, of each user program U jfor resource R iare calculated adaptively. These prices are not apparent to the users, but they are rather shadow prices determined from the characteristics of user programs, the current resource congestion, and the budget constraints of users. There emerge a set of effective priorities for user programs based on the bid prices, W ij, and these determine the scheduling of programs. An imbalance due to high congestion of some resource will result in a relative decrease of priority for heavy users ofthat resource and a relative increase for light users.Some ideas on an actual implementation scheme are described based on an approximation to the above abstract scheme. It is shown that this approximate scheme will also tend to balance resource utilization.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271343</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LatteuxT90">
<author>Michel Latteux</author>
<author>Paavo Turakainen</author>
<title>On Characterizations of Recursively Enumerable Languages.</title>
<pages>178-186</pages>
<year>1990</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta28.html#LatteuxT90</url>
<abstract>Geffert has shown that earch recursively enumerable languageL overΣ can be expressed in the formL{h(x) −1 g(x)∣x inΔ +}∩Σ * whereΔ is an alphabet andg, h is a pair of morphisms. Our purpose is to give a simple proof for Geffert's result and then sharpen it into the form where both of the morphisms are nonerasing. In our method we modify constructions used in a representation of recursively enumerable languages in terms of equality sets and in a characterization of simple transducers in terms of morphisms. As direct consequences, we get the undecidability of the Post correspondence problem and various representations ofL. For instance,L =ρ(L 0)∩Σ * whereL 0 is a minimal linear language and ρ is the Dyck reductionaā→ε, AĀ→ε.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01237236</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Maon86">
<author>Yael Maon</author>
<title>On the Equivalence of Some Transductions Involving Letter to Letter Morphisms on Regular Languages.</title>
<pages>585-596</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta23.html#Maon86</url>
<abstract>Equivalence problems of some transductions involving letter to letter morphisms on regular languages are discussed. In particular, we deal with finite substitutions and inverses of finite substitutions. Our main results are the following: (i) The equivalence problem of inverses of finite substitutions on regular languages is undecidable, (ii) The existential equivalence problem of finite substitutions on regular languages is undecidable, and (iii) The length-equivalence problem of finite substitutions on regular languages is decidable.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288471</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/DjidjevV97">
<author>Hristo Djidjev</author>
<author>Shankar M. Venkatesan</author>
<title>Reduced Constants for Simple Cycle Graph Separation.</title>
<pages>231-243</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta34.html#DjidjevV97</url>
<abstract> If G is an n vertex maximal planar graph and δ≤1 3, then the vertex set of G can be partitioned into three sets A, B, C such that neither A nor B contains more than (1−δ)n vertices, no edge from G connects a vertex in A to a vertex in B, and C is a cycle in G containing no more than (√2δ+√2−2δ)√n+O(1) vertices. Specifically, when δ=1 3, the separator C is of size (√2/3+√4/3)√n+O(1), which is roughly 1.97√n. The constant 1.97 is an improvement over the best known so far result of Miller 2√2≈2.82. If non-negative weights adding to at most 1 are associated with the vertices of G, then the vertex set of G can be partitioned into three sets A, B, C such that neither A nor B has weight exceeding 1−δ, no edge from G connects a vertex in A to a vertex in B, and C is a simple cycle with no more than 2√n+O(1) vertices.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050082</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Newton74"> 
<author>Glen E. Newton</author>
<title>Proving Properties of Interacting Processes.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>117-126</pages>
<url>db/journals/acta/acta4.html#Newton74</url>
<abstract>The Set of Interacting Procedures (SIP) model, a graph model suitable for representing interacting computations, is presented. It includes nótation for creating and destroying processes, permits well-defined critical sections, and facilitates examining the logical properties of the modeled procedures. The essential parts of a theory of correctness of interacting processes are informally presented. These include a definition of correctness with respect to an assertion, a non-interference condition which justifies the use of the SIP model, and a set of sufficient conditions for correctness. To illustrate the use of the model and theory, a solution to the reader-writer problem is presented and modeled. An assertion expressing the correctness of the solution is formulated, and the SIP model of the solution is shown to be correct with respect to the assertion. Finally, the non-interference condition shows that the conclusions about the model also apply to the solution itself.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288744</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Mitrana97">
<author>Victor Mitrana</author>
<title>On the Interdependence Between Shuffle and Crossing-Over Operations.</title>
<pages>257-266</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta34.html#Mitrana97</url>
<abstract> We investigate the link between the crossing-over operation on languages as a formal model of the linkage and recombination of genes in chromosomes, and the shuffle operation on languages. The obtained results indicate a strong connection between the two operations.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050084</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/DiekertG98">
<author>Volker Diekert</author>
<author>Paul Gastin</author>
<title>Approximating Traces.</title>
<pages>567-593</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta35.html#DiekertG98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035007/80350567.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kunde87">
<author>Manfred Kunde</author>
<title>Lower Bounds for Sorting on Mesh-Connected Architectures.</title>
<pages>121-130</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#Kunde87</url>
<abstract>Lower bounds for sorting on mesh-connected arrays of processors are presented. For sorting N=n1 n 2...n r elements on an n 1×n2×... ×n r array 2(n 1+...+n r−1)+n r data interchange steps are needed asymptotically. For two dimensions these bounds are asymptotically best possible provided that n 1 and n 2 are powers of 2. In this case the generalized s 2-way merge sort of Thompson and Kung turns out to be asymptotically optimal. The minimal asymptotic bound of 2 √2N interchange steps can be obtained only by sorting algorithms suitable for √N/2×√2N meshes. For r≧3 dimensions an analysis of aspect-ratios also demonstrates that there exist mesh-connected architectures which are better suited for sorting than simple r-dimensional cubes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264359</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Latteux79">
<author>Michel Latteux</author>
<title>Intersections de langages alg&eacute;briques born&eacute;s.</title>
<pages>233-240</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Latteux79</url>
<abstract>We study the family SLB of morphic images of the intersection of two bounded Context-free languages. In particular, we prove the equality between this family and the family of finite intersection of bounded Context-free languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289069</ee>
</article>
<article mdate="2008-11-18" key="journals/acta/KlaudelP08">
<author>Hanna Klaudel</author>
<author>Franck Pommereau</author>
<title>M-nets: a survey.</title>
<pages>537-564</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>This paper surveys the research related to the model of M-nets since it was introduced in 1995. M-nets are high-level labelled Petri nets which can be composed, like process algebra terms, using various operators. We present the core model, several of its extensions and the main applications.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0077-0</ee>
<url>db/journals/acta/acta45.html#KlaudelP08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RamanathanK81">
<author>Jayashree Ramanathan</author>
<author>Ken Kennedy</author>
<title>Pathlistings Applied to Data Flow Analysis.</title>
<pages>253-273</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#RamanathanK81</url>
<abstract>In this paper the pathlisting mechanism is developed as a new tool useful in performing efficient data flow analysis of programs for a wide variety of problems. An algorithm using this tool for forward flow, code improvement problems is presented. It is shown that for all practical purposes this algorithm is linear in the size of the input which is, generally speaking, a reducible flow graph modeling the given program. Pathlistings generalize the nodelisting approach, introduced by Kennedy, for solving data flow problems. The efficiency of the pathlisting algorithm is due to the reuse of intermediate values and due to the fact that the cycles of a reducible flow graph can be ordered. Other advantages of the approach are also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289306</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CoffmanLT78">
<author>Edward G. Coffman Jr.</author>
<author>Joseph Y.-T. Leung</author>
<author>D. W. Ting</author>
<title>Bin Packing: Maximizing the Number of Pieces Packed.</title>
<pages>263-271</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#CoffmanLT78</url>
<abstract>We consider a variant of the classical one-dimensional bin-packing problem: The number of bins is fixed and the object is to maximize the number of pieces packed from some given set. Both problems have applications in processor and storage allocation in computer systems in addition to a broad application in operations research.It can easily be shown that both problems are NP-complete; our approach will be to propose and analyze very fast heuristics. We consider a class of algorithms and bound the performance of an arbitrary algorithm in that class. Finally we propose an algorithm, the first-fit-increasing algorithm, and analyze its running time and relative performance.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288885</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BoothL81">
<author>Kellogg S. Booth</author>
<author>Richard J. Lipton</author>
<title>Computing Extremal and Approximate Distances in Graphs Having Unit Cost Edges.</title>
<pages>319-328</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#BoothL81</url>
<abstract>Using binary search and a Strassen-like matrix multiplication algorithm we obtain efficient algorithms for computing the diameter, the radius, and other distance-related quantities associated with undirected and directed graphs having unit cost (unweighted) edges. Similar methods are used to find approximate values for the distances between all pairs of vertices, and if the graph satisfies certain regularity conditions to find the exact distances.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264532</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Claus81">
<author>Volker Claus</author>
<title>The ( <i> n,k </i> )-Bounded Emptiness-Problem for Probabilistic Acceptors and Related Problems.</title>
<pages>139-160</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Claus81</url>
<abstract>This paper investigates some problems which change their status from being unsolvable to solvable when varying the values of parameters. Let EMPTY(n, k) be the problem to decide for all rational probabilistic acceptors B with at most n states and k input symbols and for all rational numbers λ, whether the accepted language L(B,λ) is empty. It turns out that EMPTY(2, k) is solvable for all k, while EMPTY (9,9) and EMPTY (65,2) are not. Some problems of the theory of ℤ-rational power series are shown to be unsolvable, too, even for small values of the problemparameters.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261257</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BernardeschiFV95"> 
<author>Cinzia Bernardeschi</author>
<author>Nicoletta De Francesco</author>
<author>Gigliola Vaglini</author>
<title>A Petri Nets Semantics for Data Flow Networks.</title>
<pages>347-374</pages>
<year>1995</year> 
<volume>32</volume> 
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta32.html#BernardeschiFV95</url>
<abstract>This work presents a truly concurrent operational semantics for nondeterministic data flow networks. We introduce a model, the df-process, which is a notion similar to that of non-sequential process for a Petri net: a df-process is defined as a mapping from an occurrence net K to a data flow net N, such that the places and the transitions of K are mapped onto the channels and the nodes of N. A df-process contains, by means of some labelling of the places, information on the value and the order in which data flow through the channels during a computation. Df-processes for a data flow network are characterized in an abstract way by a set of properties and in general a df-process corresponds to a set of computations of the network. We give a way to build the df-process corresponding to a computation incrementally at each event occurrence: a main result of the paper is that the incremental construction yields exactly the same set of df-processes as abstractly defined. We also show that df-processes are compositional. The model is intended to be used by distributed systems designers: it contains enough information to be a guideline for the designer and to be a base to develop dynamic checking tools. We outline how df-processes can be used in the design phase of a system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178383</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/EngelsPE83">
<author>Gregor Engels</author>
<author>Udo Pletat</author>
<author>Hans-Dieter Ehrich</author>
<title>An Operational Semantics for Specifications of Abstract Data Types with Error Handling.</title>
<pages>235-253</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#EngelsPE83</url>
<abstract>A new approach to an operational treatment of errors and exceptions in specifications of abstract data types is presented. Considering a specification as a term rewriting system, we define an operational semantics and give conditions that are sufficient for its well-definedness (Church-Rosser property). Also, we give conditions that are sufficient for the termination of reduction strategies, respecting the specified error and exception handling.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265557</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/GonczarowskiW89">
<author>Jakob Gonczarowski</author>
<author>Manfred K. Warmuth</author>
<title>Scattered Versus Context-Sensitive Rewriting.</title>
<pages>81-95</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta27.html#GonczarowskiW89</url>
<abstract>We study the relationship between scattered and context-sensitive rewriting. We prove that an extended version of scattered grammars produces exactly the context-sensitive languages. Also unordered scattered context languages are a proper subset of scattered context languages, and unordered scattered rewriting with erasing does not generate all scattered context (and thus not all context-sensitive) languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263503</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Bar-YehudaF98">
<author>Reuven Bar-Yehuda</author>
<author>Sergio Fogel</author>
<title>Partitioning a Sequence into Few Monotone Subsequences.</title>
<pages>421-440</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta35.html#Bar-YehudaF98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035005/80350421.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ValkJ85">
<author>R&uuml;diger Valk</author>
<author>Matthias Jantzen</author>
<title>The Residue of Vector Sets with Applications to Decidability Problems in Petri Nets.</title>
<pages>643-674</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#ValkJ85</url>
<abstract>A set K of integer vectors is called right-closed, if for any elementmεK all vectors m′≧m are also contained in K. In such a case K is a semilinear set of vectors having a minimal generating set res(K), called the residue of K. A general method is given for computing the residue set of a right-closed set, provided it satisfies a certain decidability criterion.Various right-closed sets wich are important for analyzing, constructing, or controlling Petri nets are studied. One such set is the set CONTINUAL(T) of all such markings which have an infinite continuation using each transition infinitely many times. It is shown that the residue set of CONTINUAL(T) can be constructed effectively, solving an open problem of Schroff. The proof also solves problem 24 (iii) in the EATCS-Bulletin. The new methods developed in this paper can also be used to show that it is decidable, whether a signal net is prompt [23] and whether certain ω-languages of a Petri net are empty or not.It is shown, how the behaviour of a given Petri net can be controlled in a simple way in order to realize its maximal central subbehaviour, thereby solving a problem of Nivat and Arnold, or its maximal live subbehaviour as well. This latter approach is used to give a new solution for the bankers problem described by Dijkstra.Since the restriction imposed on a Petri net by a fact [11] can be formulated as a right closed set, our method also gives a new general approach for „implementations” of facts.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289715</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Su94">
<author>Jianwen Su</author>
<title>Dependency Preservation in Semantic Databases.</title>
<pages>27-54</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta31.html#Su94</url>
<abstract>A simple semantic or object-based data model is considered, which includes objects and object identifiers, classes and class hierarchies, attributes ranging over atomic values. Transactions are composed from five, basic operators manipulating objects. Preservation of functional and acyclic inclusion dependencies by transactions is studied in such a context of semantic databases and update transactions. It is shown to be decidable whether a given transaction preserves a given set of functional dependencies, or acyclic inclusion dependencies, or both functional and acyclic inclusion dependencies. Time complexity (with respect to the sizes of transactions and database schemas) for testing preservation is also discussed. It turns out that the problem is co-NP-complete in the simplest cases where there is only one nontrivial dependency and transactions consist of only creations and deletions of objects. It implies that the problem is at least co-NP-hard in general.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178921</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/El-AffendiK83">
<author>M. A. El-Affendi</author>
<author>Demetres D. Kouvatsos</author>
<title>A Maximum Entropy Analysis of the <i> M/G/ </i> 1 and <i> G/M/ </i> 1 Queueing Systems at Equilibrium.</title>
<pages>339-355</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#El-AffendiK83</url>
<abstract>The M/G/1 and G/M/1 queueing models are of great interest in the performance analysis of computer systems. For both models, the equilibrium solution for the number of jobs in the system varies with the probability distribution function representing the general (G-type) distribution. Even in the presence of empirical data, the characterisation of this function involves a degree of arbitrariness that may cause some variation in the performance metrics.In this paper maximum entropy formalism is used to analyse the M/G/1- and G/M/1-queueing systems at equilibrium. A unique product form solution for the number of jobs in the M/G/1 system is derived and the corresponding service time distribution is determined. This solution is also presented as a limit of a sequence of maximum entropy solutions to two-stage M/G/1 systems. Furthermore, the maximum entropy solution to the G/M/1 queueing system is established and favourable comparisons with the method of stages and the diffusion approximation are made. It is also shown that the maximum entropy M/G/1- and G/M/1-systems satisfy local balance. Comments on the results so far obtained and their implications to the analysis of general queueing systems are included.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290731</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hennicker91">
<author>Rolf Hennicker</author>
<title>Observational Implementation of Algebraic Specifications.</title>
<pages>187-230</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta28.html#Hennicker91</url>
<abstract>An observational approach to the construction of implementations of algebraic specifications is presented. Based on the theory of observational specifications an implementation relation is defined which formalizes the intuitive idea that an implementation is correct if it produces correct observable output. To be useful in practice proof theoretic criteria for observational implementations are provided and a proof technique (called “context induction”) for the verification of implementation relations is presented. As an example an abstract specification of (the algebraic semantics of) a small imperative programming language is implemented by a state oriented specification of the language.In order to support the modular construction of implementations the approach is extended to parameterized observational specifications. Based on the notion of observable parameter context a proof theoretic criterion for parametrized observational implementations is presented and it is shown that under appropriate conditions observational implementations compose horizontally. The given implementation criteria are applied to examples.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178505</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nielson83">
<author>Hanne Riis Nielson</author>
<title>Computation Sequences: A Way to Characterize Classes of Attribute Grammars.</title>
<pages>255-268</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Nielson83</url>
<abstract>A computation sequence for a derivation tree specifies a way of walking through the tree evaluating all the attributes of all nodes. By requiring that each derivation tree has a computation sequence with a certain property, it is possible to give simple characterizations of wellknown subclasses of attribute grammars. Especially the absolutely noncircular attribute grammars are considered.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265558</ee>
</article>
<article mdate="2014-09-05" key="journals/acta/BertranBC14">
<author>Miquel Bertran</author>
<author>Francesc-Xavier Babot</author>
<author>August Climent</author>
<title>Formal communication elimination and sequentialization equivalence proofs for distributed system models.</title>
<pages>347-418</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>Equivalence reasoning with distributed system models, expressed directly as imperative programs with explicit parallelism, communication operations, storage variables and boolean conditions, remains virtually unexplored. Only reasoning with models expressed as process algebras has been amply dealt with in literature. However, these formalisms do not contemplate either storage variables or Boolean conditions as fundamental items, although these items become essential in most situations. This article develops the foundation of the until now non existent theory of equivalence reasoning with the aforementioned imperative notation and two novel equivalence proof techniques: communication elimination and sequentialization. The development is grounded on state systems and transition interleavings, as treated by Manna and Pnueli. Equivalence proofs safely transform a model via the application of a sequence of equivalence laws; aiming to obtain an equivalent model which is purely sequential, free from internal communication operations and parallelism, as a simplification of the initial model. After this, verification of the original model can be carried out, indirectly, in the simplified model, thus reducing complexity. Some of the presented novel notions are: (1) modular procedure for decomposition of both models and proofs, (2) interface behavior for statement semantics, (3) interface equivalence between behaviors, between statements and between procedures, (4) a set of communication elimination laws and (5) substitution rules of procedure references by their bodies or by references to equivalent procedures. An elimination proof construction algorithm is also presented; when it terminates, deadlock freedom of the original model can be decided. The main design lines of a computer aided equivalence reasoning tool are outlined as well. This is the foundation for a more widely applicable tool. As an illustration, the sequentialization proof of a simplified pipelined processor is overviewed. It is modeled as a distributed system with procedures and two levels of parallelism. The model obtained at the end of the equivalence proof is the sequential loop of a Von Neumann processor. This result establishes that the original model is deadlock-free, behaves as a processor and, as a consequence, the partition of processor functions among parallel processes is correct. The ratio of the upper bounds on the number of states of the final over the initial models, \(\frac{final}{initial}\), is \(\frac{1}{2^{672}}\).</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0203-0</ee>
<url>db/journals/acta/acta51.html#BertranBC14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Heise76">
<author>Werner Heise</author>
<title>Optimal Codes, n-Arcs and Laguerre Geometry.</title>
<pages>403-406</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Heise76</url>
<abstract>In this paper we give sharp bounds for the block-length n of optimal linear (n, k)-codes over GF(q).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268141</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/BoyarFLN03">
<author>Joan Boyar</author>
<author>Lene M. Favrholdt</author>
<author>Kim S. Larsen</author>
<author>Morten N. Nielsen</author>
<title>Extending the accommodating function.</title>
<pages>3-35</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The applicability of the accommodating function, a relatively new measure for the quality of on-line algorithms, is extended.The standard quality measure for on-line algorithms is the competitive ratio, which is, roughly speaking, the worst case ratio of the on-line performance to the optimal off-line performance. However, for many on-line problems, the competitive ratio gives overly pessimistic results and/or fails to distinguish between algorithms that are known to perform very differently in practice. Many researchers have proposed variations on the competitive ratio to obtain more realistic results. These variations are often tailor-made for specific on-line problems.The concept of the accommodating function applies to any on-line problem with some limited resource, such as bins, seats in a train, or pages in a cache. If a limited amount n of some resource is available, the accommodating function \(\mathcal{A}(\alpha)\) is the competitive ratio when input sequences are restricted to those for which the amount \(\alpha n\) of resources suffices for an optimal off-line algorithm. For all resource bounded problems, the standard competitive ratio is \(\lim_{\alpha\rightarrow\infty}\mathcal{A}(\alpha)\).The accommodating function was originally used only for \(\alpha\geq 1\). We focus on \(\alpha < 1\), observe that the function now appears interesting for a greater variety of problems, and use it to make new distinctions between known algorithms and to find new ones.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0124-9</ee>
<url>db/journals/acta/acta40.html#BoyarFLN03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ClintH72"> 
<author>Maurice Clint</author>
<author>C. A. R. Hoare</author>
<title>Program Proving: Jumps and Functions.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>214-224</pages>
<url>db/journals/acta/acta1.html#ClintH72</url>
<abstract>Proof methods adequate for a wide range of computer programs have been expounded in [1] and [2]. This paper develops a method suitable for programs containing functions, and a certain kind Of jump. The method is illustrated by the proof of a useful and efficient program for table lookup by logarithmic search.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288686</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/AgrawalD83">
<author>Rakesh Agrawal</author>
<author>Keith D. Detro</author>
<title>An Efficient Incremental LR Parser for Grammars With Epsilon Productions.</title>
<pages>369-376</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#AgrawalD83</url>
<abstract>This paper describes the implementation of an extension to Celentano's [2] incremental LR Parsing Algorithm that allows epsilon rules in the grammar.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290733</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PaunR94">
<author>Gheorghe Paun</author>
<author>Grzegorz Rozenberg</author>
<title>Prescribed Teams of Grammars.</title>
<pages>525-537</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta31.html#PaunR94</url>
<abstract>We consider sets of grammars (calledteams) which process strings by cooperating together; a single derivation step in a team is done in such a way that each grammar in the set rewrites a symbol in the string. A cooperating grammar system with prescribed teams (CPT) consists of a finite number of teams. In a maximal rewriting mode, a team in a CPT can take a string for rewriting whenever it can make a derivation step on it; it keeps it and rewrites as long as it can, and once a string is obtained that cannot be rewritten by the team anymore it is returned and becomes available to all other teams.In this paper we investigate the power of CPT in the maximal and other rewriting modes. We establish the relationships of CPT with other models of grammars cooperating together and with various kinds of controlled grammars. We also solve some open problems from [6] and provide alternative proofs for some results from [6].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01213205</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/CorradiniP01">
<author>Flavio Corradini</author>
<author>Marco Pistore</author>
<title>`Closed Interval Process Algebra' versus `Interval Process Algebra'.</title>
<pages>467-509</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037007/10370467.htm</ee>
<url>db/journals/acta/acta37.html#CorradiniP01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BosL91">
<author>Jan van den Bos</author>
<author>Chris Laffra</author>
<title>PROCOL: A Concurrent Object-Oriented Language with Protocols Delegation and Constraints.</title>
<pages>511-538</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#BosL91</url>
<abstract>PROCOL is an object-oriented language with distributed delegation. It strongly supports concurrency: many objects may be active simultaneously, they execute in parallel unless engaged in communication. An object has exported operations, called Actions. Only one Action can be active at a time, however special interrupt Actions may interrupt regular Actions. Communication is performed via remote procedure call, or via a one-way synchronous message with short-time binding. In communications both client and server can be specified, either by object instance identifiers, or by type. Therefore client-server mappings may be 1-1,n-1, or 1-n, though only 1 message is transferred. PROCOL controls object access by an explicit per-object protocol. This protocol is a specification of the legality and serialization of the interaction between the object and its clients. It also provides for client type checking. The use of protocols in object communication fosters structured, safer and potentially verifiable information exchange between objects. The protocol also plays an important role as a partial interface specification. In addition it acts as a composition rule over client objects, representing relations with the client objects. PROCOL's communication binding is dynamic (run-time); it functions therefore naturally in a distributed, incremental and dynamic object environment. PROCOL also supports constraints, without compromising information hiding. An implementation is available in the form of aC extension.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463943</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Taubner89">
<author>Dirk Taubner</author>
<title>Representing CCS Programs by Finite Predicate/Transition Nets.</title>
<pages>533-565</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta27.html#Taubner89</url>
<abstract>A construction is given which for CCS programs (in which every choice and recursion starts sequentially) yields a finite and strict predicate/ transition net. Consistency of this construction is proved not only with respect to the standard interleaving semantics but with respect to the distributed operational semantics of Degano, De Nicola, and Montanari which additionally models the concurrency explicitly.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00277389</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SpitzenW74"> 
<author>Jay M. Spitzen</author>
<author>Ben Wegbreit</author>
<title>The Verification and Synthesis of Data Structures.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>127-144</pages>
<url>db/journals/acta/acta4.html#SpitzenW74</url>
<abstract>The concept of machine extension is a commonly used technique for implementing complex software: sets of object classes and operations on these objects are defined and used, often in a layered fashion, to construct the system. This paper addresses the adaptation of this technique to automatic programming. It discusses how such sets of data structures may be precisely specified, presents an axiomatization of a programming language suitable for machine verification, and shows how programs which realize these data structures may be proved correct. A range of data type classes is treated—including arrays, records, and pointers. Some new verification rules are presented to handle programs which use assignments and structured objects.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288745</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Grassi94">
<author>Vincenzo Grassi</author>
<title>Dependability Evaluation of Hierarchical Systems.</title>
<pages>207-233</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta31.html#Grassi94</url>
<abstract>Hierarchical design represents a natural solution for managing the growing complexity of computing systems. This leads to systems that are hierarchically structured from a logical or physical viewpoint. Because of the inherent complexity of such systems, the incorporation of fault-tolerance features is highly recommended, to achieve the required dependability level. Hence, it is important to develop evaluation tools that allow to analyse the effectiveness of different fault-tolerance mechanisms. We present a systematic procedure for the construction and evaluation of Markov models for transient dependability analysis, which fully exploits the hierarchical structure of the system under evaluation. A thorough time/space complexity analysis of the proposed procedure shows that it allows a considerable time and space saving with respect to a “naive” approach to the same problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01218404</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MaurerSW80">
<author>Hermann A. Maurer</author>
<author>Arto Salomaa</author>
<author>Derick Wood</author>
<title>On Generators and Generative Capacity of EOL Forms.</title>
<pages>87-107</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#MaurerSW80</url>
<abstract>In this paper we study the generative capacity of EOL forms from two different points of view. On the one hand, we consider the generative capacity of special EOL forms which one could call ‘linear like’ and ‘context free like’, establishing the existence of a rich variety of non-regular sub-EOL language families. On the other hand, we propose the notion of a ‘generator’ L of a language family ℒ We mean by this that any synchronized EOL system generating L generates — if understood as an EOL form — all languages of ℒ. We characterize the generators of the family of regular languages, and prove that other well known language families do not have generators.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288538</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kamin87">
<author>Samuel N. Kamin</author>
<title>The Expressive Theory of Stacks.</title>
<pages>695-709</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta24.html#Kamin87</url>
<abstract>The usual theory of stacks is not expressive in the sense of Cook; that is, loop invariants needed to prove programs that use stacks cannot be stated in the logic. We first prove this assertion, then suggest ways of augmenting theories with new operators so as to achieve expressiveness. The main technique is to regard data types as function spaces. The technique is applied to stacks as well as to other data types.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00282622</ee>
</article>
<article mdate="2015-02-04" key="journals/acta/BernardoNL15">
<author>Marco Bernardo</author>
<author>Rocco De Nicola</author>
<author>Michele Loreti</author>
<title>Revisiting bisimilarity and its modal logic for nondeterministic and probabilistic processes.</title>
<pages>61-106</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The logic PML is a probabilistic version of Hennessy–Milner logic introduced by Larsen and Skou to characterize bisimilarity over probabilistic processes without internal nondeterminism. In this paper, two alternative interpretations of PML over nondeterministic and probabilistic processes as models are considered, and two new bisimulation-based equivalences that are in full agreement with those interpretations are provided. The new equivalences include as coarsest congruences the two bisimilarities for nondeterministic and probabilistic processes proposed by Segala and Lynch. The latter equivalences are instead known to agree with two versions of Hennessy–Milner logic extended with an additional probabilistic operator interpreted over state distributions in place of individual states. The new interpretations of PML and the corresponding new bisimilarities are thus the first ones to offer a uniform framework for reasoning on processes that are purely nondeterministic or reactive probabilistic or that mix nondeterminism and probability in an alternating/nonalternating way.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0210-1</ee>
<url>db/journals/acta/acta52.html#BernardoNL15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Poetzsch-Heffter97">
<author>Arnd Poetzsch-Heffter</author>
<title>Prototyping Realistic Programming Languages Based on Formal Specifications.</title>
<pages>737-772</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<url>db/journals/acta/acta34.html#Poetzsch-Heffter97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034010/70340737.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BeckerM86">
<author>Michael Becker</author>
<author>Kurt Mehlhorn</author>
<title>Algorithms for Routing in Planar Graphs.</title>
<pages>163-176</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#BeckerM86</url>
<abstract>A routing problem is given by a planar graph G= (V, E) with a given embedding into the plane and a set Ne of nets. A net is a pair of points on the boundary of the infinite face. The goal is to find a set of pairwise edge-disjoint paths connecting the terminals of the various nets. We assume that the degree of every vertex not on the boundary of the infinite face is even and call such routing problems half-even. We show that one can decide in time O(bn) whether a half-even problem is solvable and that a solution can be constructed in time O(n 2). Here n=¦V¦ and b is the number of vertices on the boundary of the infinite face. If the routing problem is even, i.e. every cut has even free capacity, and G is a subgraph of the planar grid then a solution can be found in time O(n 3/2).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289496</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Sedgewick77"> 
<author>Robert Sedgewick</author>
<title>The Analysis of Quicksort Programs.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>327-355</pages>
<url>db/journals/acta/acta7.html#Sedgewick77</url>
<abstract>The Quicksort sorting algorithm and its best variants are presented and analyzed. Results are derived which make it possible to obtain exact formulas describing the total expected running time of particular implementations on real computers of Quicksort and an improvement called the median-of-three modification. Detailed analysis of the effect of an implementation technique called loop unwrapping is presented. The paper is intended not only to present results of direct practical utility, but also to illustrate the intriguing mathematics which arises in the complete analysis of this important algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289467</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/KrishnaswamyB95"> 
<author>Vashudha Krishnaswamy</author>
<author>John L. Bruno</author>
<title>On the Complexity of Concurrency Control Using Semantic Information.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>3</number>
<year>1995</year> 
<pages>271-284</pages>
<url>db/journals/acta/acta32.html#KrishnaswamyB95</url>
<abstract>In the presence of semantic information, serializability is too strong a correctness criterion and unnecessarily restricts concurrency. Many researchers have investigated the use of semantic information to allow interleaving among transactions which are non-serializable, but which nonetheless preserves the consistency of the database and is acceptable to the users. In this paper we consider a class of schedules, calledconflict-correct schedules, first proposed by Farrag and Özsu, which enlarges upon the class of serializable schedules by taking semantic information of transactions into account. In this paper we show that the problem of recognizing schedules in this class is NP-complete. Thus it is unlikely that there exists an efficient scheduler which accepts the entire class of conflict-correct schedules.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178262</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/OlderogH86">
<author>Ernst-R&uuml;diger Olderog</author>
<author>C. A. R. Hoare</author>
<title>Specification-Oriented Semantics for Communicating Processes.</title>
<pages>9-66</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta23.html#OlderogH86</url>
<abstract>A process P satisfies a specification S if every observation we can make of the behaviour of P is allowed by S. We use this idea of process correctness as a starting point for developing a specific form of denotational semantics for processes, called here specification — oriented semantics. This approach serves as a uniform framework for generating and relating a series of increasingly sophisticated denotational models for Communicating Processes.These models differ in the underlying structure of their observations which influences both the number of representable language operators and the induced notion of process correctness. Safety properties are treated by all models; the more sophisticated models also permit proofs of certain liveness properties. An important feature of the models is a special hiding operator which abstracts from internal process activity. This allows large processes to be composed hierarchically from networks of smaller ones in such a way that proofs of the whole are constructed from proofs of its components. We also show the consistency of our denotational models w.r.t. a simple operational semantics based on transitions which make internal process activity explicit.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00268075</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Gimpel74"> 
<author>James F. Gimpel</author>
<title>Nonlinear Pattern Theory.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>213-229</pages>
<url>db/journals/acta/acta4.html#Gimpel74</url>
<abstract>The formal treatment of patterns is extended to include the nonlinear patterns ABORT and FENCE and their derivatives. Many results for linear patterns carry over to the nonlinear case and several new results are derived. The theory is applied to analyzing the behavior of a class of patterns to parse programming languages operating in back-up-free fashion. The development leads to considerations of the validity of certain forms of recursive pattern definition. Implications to the recognition of recursively-defined Formal Languages are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288727</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Eichner73"> 
<author>Lutz Eichner</author>
<title>Lineare Realisierbarkeit endlicher Automaten &uuml;ber endlichen K&ouml;rpern.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1973</year> 
<pages>75-100</pages>
<url>db/journals/acta/acta3.html#Eichner73</url>
<abstract>After having compiled basic concepts (§ 1) we give a necessary and sufficient condition under which a finite sequential machine a is K-linearly realizable where K is a finite field (§ 2, Erster Hauptsatz). This theorem enables us to define a system of linear equations with integer coefficients, the so-called characteristic system of a, which gives the possibility to decide whether or not a is K-linearly realizable (§ 3). Research about divisors of certain determinants constructed with the help of the characteristic system gives us a survey about all finite fields K having the property that a is K-linearly realizable (§§ 4, 5).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288654</ee>
</article>

<article mdate="2009-03-05" key="journals/acta/AravindH09">
<author>Alex A. Aravind</author>
<author>Wim H. Hesselink</author>
<title>A queue based mutual exclusion algorithm.</title>
<pages>73-86</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>A new elegant and simple algorithm for mutual exclusion of N processes is proposed. It only requires shared variables in a memory model where shared variables need not be accessed atomically. We prove mutual exclusion by reformulating the algorithm as a transition system (automaton), and applying simulation of automata. The proof has been verified with the higher-order interactive theorem prover PVS. Under an additional atomicity assumption, the algorithm is starvation free, and we conjecture that no competing process is passed by any other process more than once. This conjecture was verified by model checking for systems with at most five processes.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0086-z</ee>
<url>db/journals/acta/acta46.html#AravindH09</url>
</article>
<article mdate="2007-06-13" key="journals/acta/DerrickW07">
<author>John Derrick</author>
<author>Heike Wehrheim</author>
<title>On using data abstractions for model checking refinements.</title>
<pages>41-71</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this paper we investigate how standard model checkers can be applied to checking refinement relationships between Z specifications. The major obstacle to such a use are the (potentially) infinite data domains in specifications. Consequently, we examine the application of data abstraction techniques for reducing the infinite to a finite state space. Since data abstractions do, however, decrease the amount of information in a specification, refinement can—in general—not be proven on the abstractions anymore, it can only be disproved. The model checker can thus be used to generate counter examples to a refinement relationship. Here, we show how abstract specifications can be systematically constructed (from a given data abstraction) and how a standard model checker (FDR) can be applied to find counter examples in case when refinement is absent. We especially discuss the applicability of the construction method: it constructs abstract specifications which are either upward or downward simulations of the original specifications, and depending on the operations in the specification and the data abstraction chosen, such a construction might succeed or fail. The construction abstracts both the input/output as well as the state.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0042-3</ee>
<url>db/journals/acta/acta44.html#DerrickW07</url>
</article>
<article mdate="2004-03-03" key="journals/acta/EngelfrietM03">
<author>Joost Engelfriet</author>
<author>Sebastian Maneth</author>
<title>A comparison of pebble tree transducers with macro tree transducers.</title>
<pages>613-698</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>The n-pebble tree transducer was recently proposed as a model for XML query languages. The four main results on deterministic transducers are: First, (1) the translation \(\tau\) of an n-pebble tree transducer can be realized by a composition of n+1 0-pebble tree transducers. Next, the pebble tree transducer is compared with the macro tree transducer, a well-known model for syntax-directed semantics, with decidable type checking. The -pebble tree transducer can be simulated by the macro tree transducer, which, by the first result, implies that (2) \(\tau\) can be realized by an (n+1)-fold composition of macro tree transducers. Conversely, every macro tree transducer can be simulated by a composition of 0-pebble tree transducers. Together these simulations prove that (3) the composition closure of n-pebble tree transducers equals that of macro tree transducers (and that of 0-pebble tree transducers). Similar results hold in the nondeterministic case. Finally, (4) the output languages of deterministic n-pebble tree transducers form a hierarchy with respect to the number n of pebbles.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0120-0</ee>
<url>db/journals/acta/acta39.html#EngelfrietM03</url>
</article>
<article mdate="2006-05-10" key="journals/acta/Tatti06">
<author>Nikolaj Tatti</author>
<title>Safe projections of binary data sets.</title>
<pages>617-638</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>8-9</number>
<abstract>Selectivity estimation of a boolean query based on frequent itemsets can be solved by describing the problem by a linear program. However, the number of variables in the equations is exponential, rendering the approach tractable only for small-dimensional cases. One natural approach would be to project the data to the variables occurring in the query. This can, however, change the outcome of the linear program.We introduce the concept of safe sets: projecting the data to a safe set does not change the outcome of the linear program. We characterise safe sets using graph theoretic concepts and give an algorithm for finding minimal safe sets containing given attributes. We describe a heuristic algorithm for finding almost-safe sets given a size restriction, and show empirically that these sets outperform the trivial projection.We also show a connection between safe sets and Markov Random Fields and use it to furtherreduce the number of variables in the linear program, given some regularity assumptions on the frequent itemsets.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-006-0009-9</ee>
<url>db/journals/acta/acta42.html#Tatti06</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BijlsmaWM86">
<author>A. Bijlsma</author>
<author>J. G. Wiltink</author>
<author>P. A. Matthews</author>
<title>Equivalence of the Gries and Martin Proof Rules for Procedure Calls.</title>
<pages>357-360</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta23.html#BijlsmaWM86</url>
<abstract>In this note we prove the equivalence of the proof rules for procedure calls as given by D. Gries [1] and A.J. Martin [2]. We also discuss a modification of these proof rules for the case that the specification of a procedure contains free constants.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00267863</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KeesmaatK97">
<author>N. W. Keesmaat</author>
<author>H. C. M. Kleijn</author>
<title>Net-Based Control Versus Rational Control. The Relation Between ITNC Vector Languages and Rational Relations.</title>
<pages>23-57</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta34.html#KeesmaatK97</url>
<abstract> An Individual Token Net Controller (or ITNC) is a particular type of state-machine decomposable Petri net that can be used as a synchronization mechanism in concurrent systems consisting of a fixed number of sequential subsystems. In this paper the family of ITNC vector languages is compared to the well-known family of rational relations. On the one hand it is proved that the family of rational relations equals the family of vector languages of Generalized ITNCs, i.e. ITNCs in which the restriction of completeness is dropped. On the other hand a vector language property induced by completeness is identified that precisely characterizes the difference between ITNC vector languages and Generalized ITNC vector languages. In addition, the results are shown to carry over to the prefix-closed versions of the models.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050072</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/SchmidtBZ89">
<author>Gunther Schmidt</author>
<author>Rudolf Berghammer</author>
<author>Hans Zierer</author>
<title>Describing Semantic Domains with Sprouts.</title>
<pages>217-245</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta27.html#SchmidtBZ89</url>
<abstract>In denotational semantics the meaning of a construct of a programming language is modelled by an element of a (semantic) domain. Domains are essentially ordered sets, in which every element may be approximated by a directed set of compact elements. We propose a new approach to domain construction using directed systems of certain finite subsets of a domain called sprouts. Every element of the domain can be considered as growing out from the sprouts, i.e., it can be uniquely approximated by an element of any given sprout. Sprouts consist only of compact elements and every compact element is contained in some of the sprouts. The directed system of sprouts fits neatly to the usual domain constructions, so we are able to describe the approximations of an element of a composed domain by the corresponding approximations in the component domains very exactly. Furthermore, we get a constructive and less abstract description of profinite domains than given by C. Gunter with one added feature: Given a domain functional τ, the inverse limit of the retraction sequence1, τ[1,], τ2[1,], ... is indeed the least of a certain subset of fixed points of τ, namely of those being the vertex of a cone that is “definable” in some sense.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00572989</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/IwataKM93">
<author>Shigeki Iwata</author>
<author>Takumi Kasai</author>
<author>Etsuro Moriya</author>
<title>Relations among Simultaneous Complexity Classes of Nondeterministic and Alternating Turing Machines.</title>
<pages>267-278</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta30.html#IwataKM93</url>
<abstract>Ruzzo [Tree-size bounded alternation, J. Comput. Syst. Sci. 21] introduced the notion of tree-size for alternating Turing machines (ATMs) and showed that it is a reasonable measure for classification of complexity classes. We establish in this paper that computations by tree-size and space simultaneously bounded ATMs roughly correspond to computations by time and space simultaneously bounded nondeterministic TMs (NTMs).We also show that not every polynomial time bounded and sublinear space simultaneously bounded NTM can be simulated by any deterministic TM with a slightly increased time bound and a slightly decreased space bound simultaneously.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01179374</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Peterson95"> 
<author>W. Wesley Peterson</author>
<title>Variance of Storage Requirements for B+-trees.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>7</number>
<year>1995</year> 
<pages>611-625</pages>
<url>db/journals/acta/acta32.html#Peterson95</url>
<abstract>Equations are derived for the variance of the number of leaf nodes in a B-tree or B+-tree with records inserted in random order. These show that the variance is asymptotically proportional to the number of records. Calculated values of the ratio are included.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01186643</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/AndreiM98">
<author>Stefan Andrei</author>
<author>Cristian Masalagiu</author>
<title>About the Collatz Conjecture.</title>
<pages>167-179</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta35.html#AndreiM98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035002/80350167.htm</ee>
</article>
<article mdate="2013-01-09" key="journals/acta/BlazewiczKRS87">
<author>Jacek Blazewicz</author>
<author>Wieslaw Kubiak</author>
<author>Hans R&ouml;ck</author>
<author>Jayme Luiz Szwarcfiter</author>
<title>Minimizing Mean Flow-Time with Parallel Processors and Resource Constraints.</title>
<pages>513-524</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta24.html#BlazewiczKRS87</url>
<abstract>The problem to be considered is one of scheduling nonpreemptable tasks in multiprocessor systems when tasks need for their processing processors and other limited resources, and when mean flow time is the system performance measure. For each task the time required for its processing and the amount of each resource which it requires, are given. Special attention is paid to the computational complexity of algorithms for determining the optimal schedules for different assumptions concerning the environment. For the case of scheduling independent, arbitrary length tasks when each task may require a unit of an additional resource of one type, an O(n 3) algorithm is given. For more complicated resource requirements, however, it is proved that the problem under consideration is NP-hard in the strong sense, even for the case of two processors.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263292</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bussche93">
<author>Jan Van den Bussche</author>
<title>On Minimizing the Forall-Not Degree of a Connective-Free Formula.</title>
<pages>489-502</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#Bussche93</url>
<abstract>Within a restricted class of predicate logic formulas, which we call theconnective-free formulas, we address the following optimization problem: Given a formula, find all equivalent formulas in which the number of occurring negations and universal quantifiers is minimal. We present algorithms that solve the problem, as well as the associated decision, search and enumeration problems, efficiently.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210598</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Sangiorgi96">
<author>Davide Sangiorgi</author>
<title>A Theory of Bisimulation for the pi-Calculus.</title>
<pages>69-97</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta33.html#Sangiorgi96</url>
<abstract>We study a new formulation of bisimulation for the π-calculus [MPW92], which we have called open bisimulation ( ∼ ). In contrast with the previously known bisimilarity equivalences, ∼ is preserved by all π-calculus operators, including input prefix. The differences among all these equivalences already appear in the sublanguage without name restrictions: Here the definition of ∼ can be factorised into a “standard” part which, modulo the different syntax of actions, is the CCS bisimulation, and a part specific to the π-calculus, which requires name instantiation. Attractive features of ∼ are: A simple axiomatisation (of the finite terms), with a completeness proof which leads to the construction of minimal canonical representatives for the equivalence classes of ∼; an “efficient” characterisation, based on a modified transition system. This characterisation seems promising for the development of automated-verification tools and also shows the call-by-need flavour of ∼. Although in the paper we stick to the π-calculus, the issues developed may be relevant to value-passing calculi in general.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050036</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/ParedaensV77">
<author>Jan Paredaens</author>
<author>R. Vyncke</author>
<title>A Class of Measures on Formal Languages.</title>
<pages>73-86</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#ParedaensV77</url>
<abstract>In this paper we introduce a class of measures on formal languages. These measures are based on the number of different ways a string of a specified finite length can be completed to obtain strings of the language. The relation with automata and grammars is established, and the polynomial measure, a special case of the general notion, is studied in detail. We give some closure properties for well-known operations on languages, and finally, we prove that the class of polynomial measurable languages is a Pre-AFL.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263766</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/Cieslik08">
<author>Iwona Cieslik</author>
<title>On-line graph coloring of P<sub>5</sub>-free graphs.</title>
<pages>79-91</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>Kierstead et al. (SIAM J Discret Math 8:485–498, 1995) have shown 1 that the competitive function of on-line coloring for \({\mathbb{P}}_5\) -free graphs (i.e., graphs without induced path on 5 vertices) is bounded from above by the exponential function \({\left( 4^{\chi (\mathbb{G})} - 1\right) / 3}\) . No nontrivial lower bound was known. In this paper we show the quadratic lower bound \(\tiny{\left( {\begin{array}{*{20}c} {{\chi ({\mathbb{G}}) + 1}} \\ {2} \\ \end{array} } \right) }\) . More precisely, we prove that \(\tiny{\left( {\begin{array}{*{20}c} {{\chi ({\mathbb{G}}) + 1}} \\ {2} \\ \end{array} } \right) }\) is the exact competitive function for (\({\mathbb{C}}_4, {\mathbb{P}}_5\))-free graphs. In this paper we also prove that 2\(\kappa({\mathbb{G})}\) - 1 is the competitive function of the best clique covering on-line algorithm for (\({\mathbb{C}}_4, {\mathbb{P}}_5\))-free graphs.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0064-x</ee>
<url>db/journals/acta/acta45.html#Cieslik08</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Akdag83">
<author>Herman Akdag</author>
<title>Performances of an Algorithm Constructing a Nearly Optimal Binary Tree.</title>
<pages>121-132</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#Akdag83</url>
<abstract>Binary search trees are used in medical diagnostic, species identification, computer decision making, coding, sorting, etc. They are built by applying a sequence of binary tests, when it is required to identify some unknown object or condition, belonging to a given set of possibilities. We search to minimize the path length of a binary tree, giving the probabilities of events. We propose an algorithm which builds the binary tree from the root to the terminal vertices. In this paper, we point out the different properties of that algorithm and the conditions on the probability distribution so that the algorithm becomes nearly optimal.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289410</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ChaudhuriKW00">
<author>Soma Chaudhuri</author>
<author>Martha J. Kosa</author>
<author>Jennifer L. Welch</author>
<title>One-write algorithms for multivalued regular and atomic registers.</title>
<pages>161-192</pages>
<year>2000</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0037003/00370161.htm</ee>
<url>db/journals/acta/acta37.html#ChaudhuriKW00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Heide83">
<author>Friedhelm Meyer auf der Heide</author>
<title>Efficiency of Universal Parallel Computers.</title>
<pages>269-296</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#Heide83</url>
<abstract>We consider parallel computers (PC's) with fixed communication network and bounded degree. We deal with the following question: How efficiently can one PC, a so-called universal PC, simulate each PC with n processors? This question is asked in [1] where a universal PC with O(n) processors and time loss O(log(n)) is constructed. We improve this result in two ways by construction two universal PC's which many users can efficiently work with at the same time. The first has the same number of processors and the same time loss as that one above. The second has O(O 1 + ɛ) processors for an arbitrary ɛ>0 but only time loss O(loglog(n)). Finally we define three types of simulations the most general of which includes all known simulations. We prove non-linear time-processor tradeoffs for universal PC's associated with the above types.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265559</ee>
</article>
<article mdate="2007-06-13" key="journals/acta/Kahrs07">
<author>Stefan Kahrs</author>
<title>Infinitary rewriting: meta-theory and convergence.</title>
<pages>91-121</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>When infinitary rewriting was introduced by Kaplan et al. (Principles of Programming Languages, ACM, New York, pp. 250–259, 1989) at the beginning of the 1990s, its term universe was explained as the metric completion of a metric on finite terms. The motivation for this connection to topology was that it allowed to import other well-studied notions from metric spaces, in particular the notion of convergence as a replacement for normalisation. This paper generalises the approach by parameterising it with a term metric, and applying the process of metric completion not only to terms but also to operations on and relations between terms. The resulting meta-theory is studied, leading to a revised notion of infinitary rewrite system. For these systems a method is devised to prove their convergence.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0043-2</ee>
<url>db/journals/acta/acta44.html#Kahrs07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RothKS89">
<author>Mark A. Roth</author>
<author>Henry F. Korth</author>
<author>Abraham Silberschatz</author>
<title>Null Values in Nested Relational Databases.</title>
<pages>615-642</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta26.html#RothKS89</url>
<abstract>The desire to extend the applicability of the relational model beyond traditional data-processing applications has stimulated interest in nested or non-first normal form relations in which the attributes of a relation can take on values which are sets or even relations themselves. In this paper, we study the role of null values in the nested relational model using an open world assumption. We extend the traditional theory and study the properties of extended operators for nested relations containing nulls. The no-information, unknown, and non-existent interpretation of nulls are discussed and the meaning of “empty set” is clarified. Finally, contrary to several previous results, we determine that the traditional axiomatization of functional and multivalued dependencies is valid in the presence of nulls.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288974</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nicola87">
<author>Rocco De Nicola</author>
<title>Extensional Equivalences for Transition Systems.</title>
<pages>211-237</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta24.html#Nicola87</url>
<abstract>Various notions of systems equivalence based on the reactions of systems to stimuli from the outside world are presented and compared. These notions have been proposed in the literature to allow abstraction from unwanted details in models of concurrent and communicating systems. The equivalences, already defined for different theories of concurrency, will be compared by adapting their definitions to labelled transition systems, a model which underlies many others. In the presentation of each equivalence, the aspects of system behaviours which are ignored and the identifications which are forced will be stressed. It will be shown that many equivalences, although defined very differently by following different intuitions about systems behaviour, turn out to be the same or to differ only in minor detail for a large class of transition systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264365</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nielson82">
<author>Flemming Nielson</author>
<title>A Denotational Framework for Data Flow Analysis.</title>
<pages>265-287</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Nielson82</url>
<abstract>It is shown how to express data flow analysis in a denotational framework by means of abstract interpretation. A continuation style formulation naturally leads to the MOP (Meet Over all Paths) solution, whereas a direct style formulation leads to the MFP (Maximal Fixed Point) solution.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263194</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CulikK94">
<author>Karel Culik II</author>
<author>Jarkko Kari</author>
<title>On the Power of L-Systems in Image Generation.</title>
<pages>761-773</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta31.html#CulikK94</url>
<abstract>Image generation with DOL-systems is discussed. It is shown that, if either the vector or the turtle geometry interpretation is used, DOL-systems can produce step-by-step all images that can be generated by regular languages (or by equivalent Iterative Matrix Homomorphisms of Shallit and Stolfi). An extension of turtle geometry interpretation is introduced that enables L-systems to generate gray-tone images. It is shown that with our extension every Weighted Finite Automaton can be simulated step-by-step by a DOL-system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178734</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kessels82">
<author>Joep L. W. Kessels</author>
<title>Arbitration Without Common Modifiable Variables.</title>
<pages>135-141</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Kessels82</url>
<abstract>The binary arbitration problem (or, the problem of mutual exclusion between two competitors) is the problem of preventing two competitors from simultaneously possessing the same token. A solution to this problem is presented together with a formal correctness proof. The solution is specific in that it combines the absence of common modifiable variables with the absence of auxiliary activities. Hence, its implementation does not require an arbiter on a lower level or a degree of concurrency of more than two. The solution is generalized for any arbitrary number of competitors by applying the binary solution in a binary arbitration tree.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288966</ee>
</article>
<article mdate="2010-02-16" key="journals/acta/BerghammerW10">
<author>Rudolf Berghammer</author>
<author>Michael Winter</author>
<title>Embedding mappings and splittings with applications.</title>
<pages>77-110</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We present relation-algebraic specifications of injective embedding mappings and splittings of partial equivalence relations and show in each case that the axioms characterize these constructions up to isomorphism, i.e., in an essentially unique way. Based on the specifications, we develop a relational program for computing splitting and demonstrate some applications. The examples originate from a relation-algebraic treatment of processes, graph theory, and the decomposition of specific relations.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0109-4</ee>
<url>db/journals/acta/acta47.html#BerghammerW10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MoritoS80">
<author>Susumu Morito</author>
<author>Harvey M. Salkin</author>
<title>Using the Blankinship Algorithm to Find the General Solution of a Linear Diophantine Equation.</title>
<pages>379-382</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#MoritoS80</url>
<abstract>This paper shows that the Blankinship algorithm, originally proposed to find the greatest common divisor of several integers and a solution of the associated linear diophantine equation, can be used to find the general solution of the equation. This yields a more efficient method to find the general solution than the one proposed by Bond. The modification of Blankinship's algorithm to avoid generating vectors with huge component values is also proposed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288771</ee>
</article>
<article mdate="2007-09-11" key="journals/acta/IwamotoHNMI07">
<author>Chuzo Iwamoto</author>
<author>Naoki Hatayama</author>
<author>Yoshiaki Nakashiba</author>
<author>Kenichi Morita</author>
<author>Katsunobu Imai</author>
<title>Translational lemmas for DLOGTIME-uniform circuits, alternating TMs, and PRAMs.</title>
<pages>345-359</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We present translational lemmas for the three standard models of parallel computation, and apply them to obtain tight hierarchy results. It is shown that, for arbitrarily small rational constant \(\epsilon > 0\) , (i) there is a language which can be accepted by a \(U_{\rm E}\) -uniform circuit family of depth \(c(1+\epsilon)(\log n)^{r_1}\) and size \(dn^{r_2(1+\epsilon)}\) but not by any \(U_{\rm E}\) -uniform circuit family of depth \(c(\log n)^{r_1}\) and size \(dn^{r_2}\) , (ii) there is a language which can be accepted by a \(c(9+\epsilon)(\log n)^{r_1}\) -time \(d(4+\epsilon)\log n\)-space ATM with l worktapes but not by any \(c(\log n)^{r_1}\) -time \(d\log n\) -space ATM with the same l worktapes if the number of tape symbols is fixed, and (iii) there is a language which can be accepted by a \(c(1+\epsilon)(\log n)^{r_1}\) -time PRAM with \(dn^{r_2(1+\epsilon)}\) processors but not by any \(c(\log n)^{r_1}\) -time PRAM with \(dn^{r_2}\) processors. Here, c > 0, d ≥ 1, r 1 > 1, and r 2 ≥ 1 are arbitrary rational constants, and l ≥ 2 is an arbitrary integer.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0051-2</ee>
<url>db/journals/acta/acta44.html#IwamotoHNMI07</url>
</article>
<article mdate="2004-06-28" key="journals/acta/AkkermanBJT04">
<author>Thorsten Akkerman</author>
<author>Christoph Buchheim</author>
<author>Michael J&uuml;nger</author>
<author>Daniel Teske</author>
<title>On the complexity of drawing trees nicely: corrigendum.</title>
<pages>603-607</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>In this journal, Supowit and Reingold [1] have given a proof that it is NP-complete to decide whether a binary tree can be drawn on a grid with width 24 if certain æsthetic requirements are obeyed. We identify and repair a mistake in their proof.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0138-y</ee>
<url>db/journals/acta/acta40.html#AkkermanBJT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/WijngaardenMPKSLMF75"> 
<author>Adriaan van Wijngaarden</author>
<author>B. J. Mailloux</author>
<author>J. E. L. Peck</author>
<author>Cornelis H. A. Koster</author>
<author>Michel Sintzoff</author>
<author>C. H. Lindsey</author>
<author>Lambert G. L. T. Meertens</author>
<author>R. G. Fisker</author>
<title>Revised Report on the Algorithmic Language ALGOL 68</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>1-236</pages>
<url>db/journals/acta/acta5.html#WijngaardenMPKSLMF75</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265077</ee>
</article>

<article mdate="2004-06-28" key="journals/acta/BacchelliBGP04">
<author>Silvia Bacchelli</author>
<author>Elena Barcucci</author>
<author>Elisabetta Grazzini</author>
<author>Elisa Pergola</author>
<title>Exhaustive generation of combinatorial objects by ECO.</title>
<pages>585-602</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>The problem of exhaustively generating combinatorial objects can currently be applied to many disciplines, such as biology, chemistry, medicine and computer science. A well known approach to the exhaustive generation problem is given by the Gray code scheme for listing n-bit binary numbers in such a way that successive numbers differ in exactly one bit position. In this work, we introduce an exhaustive generation algorithm, which is general for the classes of succession rules considered in [1]. We also show that our algorithm is efficient in an amortized sense; it actually uses only a constant amount of computation per object.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0139-x</ee>
<url>db/journals/acta/acta40.html#BacchelliBGP04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RozenbergV82">
<author>Grzegorz Rozenberg</author>
<author>R. Verraedt</author>
<title>Completeness of <i> E </i> 0 <i> L </i> Forms is Decidable.</title>
<pages>69-87</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#RozenbergV82</url>
<abstract>It is proved that given an E0L form F it is decidable whether or not F is vomplete. The concept of n-completeness, n a positive integer, is introduced and it is shown that for an E0L form F and an integer n≧2 vompleteness is equivalent with n-completeness.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262977</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Latteux80">
<author>Michel Latteux</author>
<title>Sur les g&eacute;n&eacute;rateurs alg&eacute;briques et lin&eacute;aires.</title>
<pages>347-363</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Latteux80</url>
<abstract>Nous étudions certaines propriétés des générateurs algébriques et linéaires. Nous montrons que le langage algébrique E engendré par la grammaire: S → aSbSc + d domine tous les langages algébriques par applications séquentielles fidèles. Nous en déduisons que pour tout langage algébrique L′ et tout générateur algébrique L, il existe une transduction rationnelle τ fonctionnelle et fidèle telle que L′=τ(L). Ce résultat, qui n'est pas vérifié pour la famille, Lin, des langages algébriques linéaires, nous permet de montrer qu'aucun générateur algébrique n'appartient à la famille EDTOL. Enfin, nous établissons que si L est un générateur linéaire, L # est un générateur ‘séquentiel’ pour Lin.We study some properties of algebraic and linear generators. We show that the algebraic language E generated by the grammar: S → aSbSc + d dominates every algebraic language by faithful sequential mappings. We deduce that, for every algebraic language L′ and every algebraic generator L, there exists a faithful rational function τ such that L′=τ(L). This result, which does not hold for the family of linear languages, permits us to show that no algebraic generator belongs to the family EDTOL. Also, we prove if L is a linear generator then L # is a ‘sequential’ generator for Lin.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288769</ee>
</article>
<article mdate="2013-02-25" key="journals/acta/Xu12">
<author>Xian Xu 0001</author>
<title>Distinguishing and relating higher-order and first-order processes by expressiveness.</title>
<pages>445-484</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>This is a paper on distinguishing and relating two important kinds of calculi through expressiveness, settling some critical but long unanswered questions. The delimitation of higher-order and first-order process calculi is a basic and pivotal topic in the study of process theory. Particularly, expressiveness studies mutual encodability, which helps decide whether process-passing or name-passing is more fundamental, and the way they ought to be used in both theory and practice. In this paper, we contribute to such demarcation with three major results. Firstly \(\pi \) (first-order pi-calculus) can faithfully express \(\varPi \) (basic higher-order pi-calculus). The calculus \(\varPi \) has the elementary operators (input, output, composition and restriction). This actually is a corollary of a more general result, that \(\pi \) can encode \(\varPi ^r\) (\(\varPi \) enriched with the relabelling operator). Secondly \(\varPi \) cannot interpret \(\pi \) reasonably. This is of more significance since it separates \(\varPi \) and \(\pi \) by drawing a well-defined boundary. Thirdly an encoding from \(\pi \) to \(\varPi ^r\) is revisited and discussed, which not only implies how to make \(\varPi \) more useful but also stresses the importance of name-passing in \(\pi \).</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0168-9</ee>
<url>db/journals/acta/acta49.html#Xu12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LiuL78">
<author>Jane W.-S. Liu</author>
<author>C. L. Liu</author>
<title>Performance Analysis of Multiprocessor Systems Containing Functionally Dedicated Processors.</title>
<pages>95-104</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#LiuL78</url>
<abstract>General models of multiprocessor systems in which processors are functionally dedicated are described. In these models, processors are divided into different types. A task can be assigned only to a processor of certain types. Clearly, the model of multiprocessor systems with identical processors is a special case of our models. These models also include the job shop problem in which there is exactly one processor of each type. Worst case performance bounds of priority-driven schedules are obtained.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260927</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BeversL93">
<author>Eddy Bevers</author>
<author>Johan Lewi</author>
<title>Proving Termination of (Conditional) Rewrite Systems. A Semantic Approach.</title>
<pages>537-568</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta30.html#BeversL93</url>
<abstract>In this paper an important problem in the domain of term rewriting, the termination of (conditional) rewrite systems, is dealt with. We show that in many applications, well-founded orderings on terms which only make use of syntactic information of a rewrite systemR, do not suffice for proving termination ofR. Indeed sometimes semantic information is needed to orient a rewrite rule. Therefore we integrate a semantic interpretation of rewrite systems and terms into a well-founded ordering on terms: the notion ofsemantic ordering is the first main contribution of this paper. The use and usefulness of the semantic ordering in proving termination is illustrated by means of some realistic examples.Furthermore the concept of semantic information induces a novel approach for proving termination inconditional rewrite systems. The idea is to employ not only semantic information contained in the terms that are to be compared, but also extra (semantic) information contained in the premiss of the conditional equation in which the terms appear. This leads to our second contribution in the termination problem area: the notion ofcontextual ordering andcontextual semantic ordering. Thecontextual approach allows to prove termination of conditional rewrite systems where all classical partial orderings would fail.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209624</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/CharpentierC04">
<author>Michel Charpentier</author>
<author>K. Mani Chandy</author>
<title>Specification transformers: a predicate transformer approach to composition.</title>
<pages>265-301</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>This paper explores theories that help in (i) proving that a system composed from components satisfies a system specification given only specifications of components and the composition operator, and (ii) deducing desirable properties of components from the system specification and properties of the composition operator. The paper studies compositional systems in general without making assumptions that components are computer programs. The results obtained from such abstract representations are general but also weaker than results that can be obtained from more restrictive assumptions such as assuming that systems are parallel compositions of concurrent programs. Explorations of general theories of composition can help identify fundamental issues common to many problem domains. The theory presented here is based on predicate transformers.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0130-y</ee>
<url>db/journals/acta/acta40.html#CharpentierC04</url>
</article>
<article mdate="2003-11-25" key="journals/acta/HayesU01">
<author>Ian J. Hayes</author>
<author>Mark Utting</author>
<title>A sequential real-time refinement calculus.</title>
<pages>385-448</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037006/10370385.htm</ee>
<url>db/journals/acta/acta37.html#HayesU01</url>
</article>
<article mdate="2003-11-25" key="journals/acta/CorradiniVJ02">
<author>Flavio Corradini</author>
<author>Walter Vogler</author>
<author>Lars Jenner</author>
<title>Comparing the worst-case efficiency of asynchronous systems with PAFAS.</title>
<pages>735-792</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>11/12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038011/20380735.htm</ee>
<url>db/journals/acta/acta38.html#CorradiniVJ02</url>
</article>
<article mdate="2004-07-14" key="journals/acta/CorderoEG02">
<author>Pablo Cordero</author>
<author>Manuel Enciso</author>
<author>Inman P. de Guzm&aacute;n</author>
<title>Bases for closed sets of implicants and implicates in temporal logic.</title>
<pages>599-619</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038009/20380599.htm</ee>
<url>db/journals/acta/acta38.html#CorderoEG02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Soisalon-SoininenW82">
<author>Eljas Soisalon-Soininen</author>
<author>Derick Wood</author>
<title>On a Covering Relation for Context-Free Grammars.</title>
<pages>435-449</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Soisalon-SoininenW82</url>
<abstract>Given a grammar for translation or compiling purposes, the structure of the grammar reflects the semantics of the language rather than good properties for parsing the language. Thus the language is often parsed with respect to another grammar which satisfies the property that the derivation trees in the original grammar can be recovered from those of the parsing grammar. ‘Undercover’ is introduced as a new concept for the formal treatment of such grammatical relations and properties of this relation are explored with an emphasis on decidability results and the relationship to existing concepts such as ‘cover’ and ‘Reynolds cover’. Some decidability questions can be related to language theoretic results on inclusion problems for simple deterministic languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264162</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Agerwala77"> 
<author>Tilak Agerwala</author>
<title>Some Extended Semaphore Primitives.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>201-220</pages>
<url>db/journals/acta/acta8.html#Agerwala77</url>
<abstract>This paper presents a proposal for synchronizing primitives obtained as an extension of Dijkstra's P, V primitives. The extended primitives are shown to be complete: they can represent any desired interaction between processes without the use of conditionals. The usefulness of these primitives is illustrated by presenting simple solutions to a series of coordination problems of increasing complexity. Two selected problems are used to illustrate disadvantages of existing synchronizing mechanisms. The extended primitives shift some of the burden from the programmer to the system since they are easier to use but more difficult to implement. However, even though each primitive operation may take longer to execute (as compared to the simple P, V primitives) the total system overhead can be substantially less especially for complex coordination problems. The paper presents a straightforward but efficient implementation of the extended primitives.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264467</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/CarpiL01">
<author>Arturo Carpi</author>
<author>Aldo de Luca</author>
<title>Periodic-like words, periodicity, and boxes.</title>
<pages>597-618</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037008/10370597.htm</ee>
<url>db/journals/acta/acta37.html#CarpiL01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/ArefS93">
<author>Walid G. Aref</author>
<author>Hanan Samet</author>
<title>Decomposing a Window into Maximal Quadtree Blocks.</title>
<pages>425-439</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#ArefS93</url>
<abstract>Window operations serve as the basis of a number of queries that can be posed in a spatial database. Examples of window-based queries include the exist query (i.e., determining whether or not a spatial feature exists inside a window), the report query (i.e., report the identity of all the features that exist inside a window), and the select query (i.e., determine the locations covered by a given feature inside a window). Often spatial databases make use of a quadtree decomposition, which yields a set of maximal blocks, to enable the features to be accessed quickly without having to search the entire database. One way to perform a window query is to decompose the window into its maximal quadtree blocks. An algorithm is described for decomposing a two-dimensional window into its maximal quadtree blocks inO(nlog logT) time for a window of sizen×n in a feature space (e.g., an image) of sizeT×T (e.g., pixel elements).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210594</ee>
</article>
<article mdate="2004-06-28" key="journals/acta/GrumbachRT04">
<author>St&eacute;phane Grumbach</author>
<author>Maurizio Rafanelli</author>
<author>Leonardo Tininini</author>
<title>On the equivalence and rewriting of aggregate queries.</title>
<pages>529-584</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract>We introduce a first-order language with real polynomial arithmetic and aggregation operators (count, iterated sum and multiply), which is well suited for the definition of aggregate queries involving complex statistical functions. It offers a good trade-off between expressive power and complexity, with a tractable data complexity. Interestingly, some fundamental properties of first-order with real arithmetic are preserved in the presence of aggregates. In particular, there is an effective quantifier elimination for formulae with aggregation. We then consider the problem of querying data that has already been aggregated in aggregate views, and focus on queries with an aggregation over a conjunctive query (namely single-block aggregate group-by queries without having clause). Our main conceptual contribution is the introduction of a new equivalence relation among conjunctive queries, the isomorphism modulo a product. We prove that the equivalence of aggregate queries such as for instance averages reduces to it. Deciding if two queries are isomorphic modulo a product is shown to be NP-complete. We then analyze the equivalence problem in the case of aggregate conjunctive queries with comparisons. We introduce the concept of cross isomorphic linear expansions, which generalizes isomorphim modulo a product, and we show that equivalence reduces to it and that it can be decided in PSPACE. Finally, we show that the problem of complete rewriting of count queries using count views is NP-complete, and we introduce new rewriting techniques based on the isomorphism modulo a product. to recover the values of counts by complex arithmetical computation from the views.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-004-0101-y</ee>
<url>db/journals/acta/acta40.html#GrumbachRT04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LondonGHLMP78">
<author>Ralph L. London</author>
<author>John V. Guttag</author>
<author>James J. Horning</author>
<author>Butler W. Lampson</author>
<author>James G. Mitchell</author>
<author>Gerald J. Popek</author>
<title>Proof Rules for the Programming Language Euclid.</title>
<pages>1-26</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#LondonGHLMP78</url>
<abstract>In the spirit of the previous axiomatixation of the programming language Pascal, this paper describes Hoare-style proof rules for Euclid, a programming language intended for the expression of system programs which are to be verified. All constructs of Euclid are covered except for storage allocation and machine dependencies.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00260921</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Gillett84">
<author>Will D. Gillett</author>
<title>On Binary Tree Encodements.</title>
<pages>183-192</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Gillett84</url>
<abstract>A data encoding scheme involving binary tree encodements is presented and analyzed. A closed-form formula for the number of n-bit legal memory configurations is developed. It is shown that the storage capacity loss due to the use of this scheme is not significant for large n.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289239</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hoare72"> 
<author>C. A. R. Hoare</author>
<title>Proof of Correctness of Data Representations.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>271-281</pages>
<url>db/journals/acta/acta1.html#Hoare72</url>
<abstract>A powerful method of simplifying the proofs of program correctness is suggested; and some new light is shed on the problem of functions with side-effects.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289507</ee>
</article>


<article mdate="2006-11-22" key="journals/acta/LiST06">
<author>Zheng-Zhu Li</author>
<author>Huei-Jan Shyr</author>
<author>Y. S. Tsai</author>
<title>Classifications of Dense Languages.</title>
<pages>173-194</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Let X be a finite alphabet containing more than one letter. A dense language over X is a language containing a disjunctive language. A language L is an n-dense language if for any distinct n words \(w_1, w_2, \ldots,w_n \in X^+,\) there exist two words\(u, v \in X^*\) such that\(uw_1v, uw_2v, \ldots uw_nv \in L.\) In this paper we classify dense languages into strict n-dense languages and study some of their algebraic properties. We show that for each n  ≥  0, the n-dense language exists. For an n-dense language L, n  ≠  1, the language L ∩ Q is a dense language, where Q is the set of all primitive words over X. Moreover, for a given n  ≥  1, the language L is such that \(L \cap Q\in D_n(X)\), then \(L\in D_m(X)\) for some m, n  ≤  m  ≤  2n + 1. Characterizations on 0-dense languages and n-dense languages are obtained. It is true that for any dense language L, there exist \(w_1\neq w_2\in X^+\) such that\(uw_1v,uw_2v\in L\) for some\(u,v\in X^\ast\). We show that everyn-dense language, n ≥  0, can be split into disjoint union of infinitely many n-dense languages.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0015-y</ee>
<url>db/journals/acta/acta43.html#LiST06</url>
</article>
<article mdate="2010-10-24" key="journals/acta/LanotteMT10">
<author>Ruggero Lanotte</author>
<author>Andrea Maggiolo-Schettini</author>
<author>Angelo Troina</author>
<title>Reachability results for timed automata with unbounded data structures.</title>
<pages>279-311</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>Systems of Data Management Timed Automata (SDMTAs) are networks of communicating timed automata with structures to store messages and functions to manipulate them. We prove the decidability of the reachability problem for a subclass of SDMTAs which assumes an unbounded knowledge, and we analyze the expressiveness of the model and the considered subclass. In particular, while SDMTAs can simulate a Turing machine, and hence the reachability problem is in general undecidable, the subclass for which reachability is decidable, when endowed with a concept of recognized language, accepts languages that are not regular. As an application, we model and analyze a variation of the Yahalom protocol.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0121-8</ee>
<url>db/journals/acta/acta47.html#LanotteMT10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/CoffmanS76">
<author>Edward G. Coffman Jr.</author>
<author>Ravi Sethi</author>
<title>Algorithms Minimizing Mean Flow Time: Schedule-Length Properties.</title>
<pages>1-14</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#CoffmanS76</url>
<abstract>The mean flow time of a schedule provides a measure of the average time that a task spends within a computer system, and also the average number of unfinished tasks in the system. The mean flow time of a schedule is defined to be the sum of the finishing times of all tasks in the system. On a system of identical processors O(nlog n) algorithms exist for determining minimal mean flow time schedules for n independent tasks. In general, there will be a large class C of schedules, of widely differing lengths, that all minimize mean flow time. The problem of finding the shortest schedule in C is NP-complete. We give heuristics that find schedules in C that are no more than 25% longer than the shortest schedule in C. The advantage of a short schedule is that processor utilization is high.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263740</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kemp81">
<author>Rainer Kemp</author>
<title><i> LR </i> (0) Grammars Generated by <i> LR </i> (0) Parsers.</title>
<pages>265-280</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Kemp81</url>
<abstract>Let Π be an LR(0) parser of a given LR(0) grammar G. Generally, Π does not only parse the words generated by G but also the words of some other LR(0) grammars different from G. In this paper we shall define a class of LR(0) parsers and shall present a characterization and a method for the construction of all LR(0) grammars which can be parsed by a given LR(0) parser.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289265</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Petit93">
<author>Antoine Petit</author>
<title>Recognizable Trace Languages, Distributed Automata and the Distribution Problem.</title>
<pages>89-101</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta30.html#Petit93</url>
<abstract>We introduce new finite state “parallel machines,” the (ℕ-)distributed automata, for trace languages. We prove that these machines give a new characterization of recognizable trace languages: a trace language is recognizable if and only if it is recognized by a (ℕ-)distributed automaton. At last, we show how the classical problem of distribution of uninterpreted tasks on several processors can be straightforward modelized by recognizable trace languages and solved using (ℕ-)distributed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01200264</ee>
</article>
<article mdate="2005-12-14" key="journals/acta/GeertsSB05">
<author>Floris Geerts</author>
<author>Lieven Smits</author>
<author>Jan Van den Bussche</author>
<title>N-dimensional versus (N-1)-dimensional connectivity testing of first-order queries to semi-algebraic sets.</title>
<pages>43-56</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper addresses the question whether one can determine the connectivity of a semi-algebraic set in three dimensions by looking only at two-dimensional “samples” of the set, where these samples are defined by first-order queries. The question is answered negatively for two classes of first-order queries: cartesian-product-free, and positive one-pass.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0171-5</ee>
<url>db/journals/acta/acta42.html#GeertsSB05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Lengauer81">
<author>Thomas Lengauer</author>
<title>Black-White Pebbles and Graph Separation.</title>
<pages>465-475</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Lengauer81</url>
<abstract>We exhibit a close relationship between two topics in computational complexity. One topic is the analysis of storage requirements for nondeterministic computations. The corresponding mathematical model is a well known black-white pebble game on directed acyclic graphs. The other topic is the search for small separators of undirected graphs. We model a dynamic version of the concept of a separator with a vertex separator game. This game is closely related to graph layout and searching problems. We show that instances of the black-white pebble game and the vertex separator game can easily be transformed into each other. As an application of this result both games are shown to be NP-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264496</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Diaconescu96">
<author>Razvan Diaconescu</author>
<title>Category-Based Modularisation for Equational Logic Programming.</title>
<pages>477-510</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta33.html#Diaconescu96</url>
<abstract>Although modularisation is basic to modern computing, it has been little studied for logic-based programming. We treat modularisation for equational logic programming using the institution of categorybased equational logic in three different ways: (1) to provide a generic satisfaction condition for equational logics; (2) to give a category-based semantics for queries and their solutions; and (3) as an abstract definition of compilation from one (equational) logic programming language to another.Regarding (2), we study soundness and completeness for equational logic programming queries and their solutions. This can be understood as ordinary soundness and completeness in a suitable “non-logical” institution. Soundness holds for all module imports, but completeness only holds for conservative module imports. Category-based equational signatures are seen as modules, and morphisms of such signatures as module imports. Regarding (3), completeness corresponds to compiler correctness.The results of this research applies to languages based on a wide class of equational logic systems, including Horn clause logic, with or without equality; all variants of order and many sorted equational logic, including working modulo a set of axioms; constraint logic programming over arbitrary user-defined data types; and any combination of the above. Most importantly, due to the abstraction level, this research gives the possibility to have semantics and to study modularisation for equational logic programming developed over non-conventional structures.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050054</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BergstraT84">
<author>Jan A. Bergstra</author>
<author>J. V. Tucker</author>
<title>The Axiomatic Semantics of Programs Based on Hoare's Logic.</title>
<pages>293-320</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#BergstraT84</url>
<abstract>This paper is about the Floyd-Hoare Principle which says that the semantics of a programming language can be formally specified by axioms and rules of inference for proving the correctness of programs written in the language. We study the simple language WP of while-programs and Hoare's system for partial correctness and we calculate the relational semantics of WP as this is determined by Hoare's logic. This calculation is possible by using relational semantics to build a completeness theorem for the logic. The resulting semantics AX we call the axiomatic relational semantics for WP. This AX is not the conventional semantics for WP: it need not be effectively computable or deterministic, for example. A large number of elegant properties of AX are proved and the Floyd-Hoare Principle is reconsidered.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264252</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/KonikowskaB99">
<author>Beata Konikowska</author>
<author>Marcin Bialasik</author>
<title>Reasoning with First Order Nondeterministic Specifications.</title>
<pages>375-403</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036005/90360375.htm</ee>
<url>db/journals/acta/acta36.html#KonikowskaB99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Mehlhorn75"> 
<author>Kurt Mehlhorn</author>
<title>Nearly Optimal Binary Search Trees.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>287-295</pages>
<url>db/journals/acta/acta5.html#Mehlhorn75</url>
<abstract>We discuss two simple strategies for constructing binary search trees: “Place the most frequently occurring name at the root of the tree, then proceed similary on the subtrees “and” choose the root so as to equalize the total weight of the left and right subtrees as much as possible, then proceed similarly on the subtres.” While the former rule may yield extremely inefficient search trees, the latter rule always produces nearly optimal trees.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264563</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Langmaack74"> 
<author>Hans Langmaack</author>
<title>On Procedures as Open Subroutines. II.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>227-241</pages>
<url>db/journals/acta/acta3.html#Langmaack74</url>
<abstract>In part I [11] of the paper elimination of global procedure parameters and modularity of programming languages have been investigated. The methods developed there are used in the present part II to prove that the so called macro program problem for ALGOL 60 and other ALGOL-like languages is algorithmically unsolvable (Theorem 4.3 and 4.4). Macro grammars theory is applied in order to determine sublanguages for which the macro program problem is solvable (Theorem 4.1, 5.2–5.5).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288636</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/LewiVHH78">
<author>Johan Lewi</author>
<author>Karel De Vlaminck</author>
<author>J. Huens</author>
<author>M. Huybrechts</author>
<title>The ELL(1) Parser Generator and the Error Recovery Mechanism.</title>
<pages>209-228</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#LewiVHH78</url>
<abstract>A syntactic error recovery technique is presented that is simple and at the same time very powerful. It has the main property that it is phrase marker oriented, where phrase markers are considered symbols delimiting language constructions, e.g., begin and end for blocks, (and) for expressions, and [and] for indices. The basic idea of this error recovery technique originates from P. Branquart and has been worked out in the Algol 68 compiler project, see [8] and [9]. Here, we are especially concerned with the generation aspects of error recovery. In particular, it is investigated how error recovery can be mechanised in an ELL(1) and LALR(1) syntax directed translation scheme and which conditions the syntax must satisfy. Both the ELL(1) and LALR(1) generators are implemented and are part of the system LILA: a Language Implementation LAboratory [28, 29, 30]. Only the ELL(1) generator is described here.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264317</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BalcazarB86">
<author>Jos&eacute; L. Balc&aacute;zar</author>
<author>Ronald V. Book</author>
<title>Sets with Small Generalized Kolmogorov Complexity.</title>
<pages>679-688</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#BalcazarB86</url>
<abstract>We study the class of sets with small generalized Kolmogorov complexity. The following results are established: 1. A set has small generalized Kolmogorov complexity if and only if it is “semi-isomorphic” to a tally set. 2. The class of sets with small generalized Kolmogorov complexity is properly included in the class of “self-p-printable” sets. 3. The class of self-p-printable sets is properly included in the class of sets with “selfproducible circuits”. 4. A set S has self-producible circuits if and only if there is a tally set T such that P(T)=P(S). 5. If a set S has self-producible circuits, then NP(S)=NP B(S), where NP B( ) is the restriction of NP( ) studied by Book, Long, and Selman [4]. 6. If a set S is such that NP(S) =NP B(S), then NP(S) \( \subseteq\) P(S⊕SAT).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264313</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Otto86">
<author>Friedrich Otto</author>
<title>On Deciding Whether a Monoid is a Free Monoid or is a Group.</title>
<pages>99-110</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta23.html#Otto86</url>
<abstract>In general it is undecidable whether or not the monoid described by a given finite presentation is a free monoid or a group. However, these two decision problems are reducible to a very restricted form of the uniform word problem. So whenever a class of presentations is considered for which this restricted form of the uniform word problem is decidable, then the above decision problems become decidable. This holds in particular for the class of all presentations involving finite string-rewriting systems that are noetherian and confluent.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00268077</ee>
</article>
<article mdate="2006-11-22" key="journals/acta/AlhazovMR06">
<author>Artiom Alhazov</author>
<author>Carlos Mart&iacute;n-Vide</author>
<author>Yurii Rogozhin</author>
<title>On the number of nodes in universal networks of evolutionary processors.</title>
<pages>331-339</pages>
<year>2006</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>We consider the networks of evolutionary processors (NEP) introduced by J. Castellanos, C. Martí n-Vide, V. Mitrana and J. Sempere recently. We show that every recursively enumerable (RE) language can be generated by an NEP with three nodes modulo a terminal alphabet and moreover, NEPs with four nodes can generate any RE language. Thus, we improve existing universality result from five nodes down to four nodes. For mNEPs (a variant of NEPs where operations of different kinds are allowed in the same node) we obtain optimal results: each RE language can be generated by an mNEP with one node modulo a terminal alphabet, and mNEPs with two nodes can generate any RE language; this is not possible for mNEPs with one node. Some open problems are formulated.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0024-x</ee>
<url>db/journals/acta/acta43.html#AlhazovMR06</url>
</article>
<article mdate="2015-01-08" key="journals/acta/EngelfrietJ89">
<author>Joost Engelfriet</author>
<author>Willem de Jong</author>
<title>Attribute Storage Optimization by Stacks.</title>
<pages>567-581</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta27.html#EngelfrietJ89</url>
<abstract>Storage optimization is considered for evaluators of simple multivisit, or (ℓ-)ordered, attribute grammars. A necessary and sufficient condition is formulated which has to be satisfied by such an evaluator to enable it to store the instances of a given attribute on a global stack. A simple algorithm is given that decides this condition in polynomial time. A similar algorithm can be used to decide whether the instances of the attribute can be stored in a global variable. These algorithms are static, i.e., they are used at evaluator construction time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00277390</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RothKS91">
<author>Mark A. Roth</author>
<author>Henry F. Korth</author>
<author>Abraham Silberschatz</author>
<title>Addendum to Null Values in Nested Relational Databases.</title>
<pages>607-610</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta28.html#RothKS91</url>
<abstract>We define a new operator, decomposition projection, and show that extended projection is a precise generalization of decomposition projection with respect to unnesting, and that null-extended projection is a precise generalization of decomposition projection with respect to unnesting and PNF possibility function POSS.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01463949</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/BenesKLMSS15">
<author>Nikola Benes</author>
<author>Jan Kret&iacute;nsk&yacute;</author>
<author>Kim G. Larsen</author>
<author>Mikael H. M&oslash;ller</author>
<author>Salomon Sickert</author>
<author>Jir&iacute; Srba</author>
<title>Refinement checking on parametric modal transition systems.</title>
<pages>269-297</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>Modal transition systems (MTS) is a well-studied specification formalism of reactive systems supporting a step-wise refinement methodology. Despite its many advantages, the formalism as well as its currently known extensions are incapable of expressing some practically needed aspects in the refinement process like exclusive, conditional and persistent choices. We introduce a new model called parametric modal transition systems (PMTS) together with a general modal refinement notion that overcomes many of the limitations. We investigate the computational complexity of modal and thorough refinement checking on PMTS and its subclasses and provide a direct encoding of the modal refinement problem into quantified Boolean formulae, allowing us to employ state-of-the-art QBF solvers for modal refinement checking. The experiments we report on show that the feasibility of refinement checking is more influenced by the degree of nondeterminism rather than by the syntactic restrictions on the types of formulae allowed in the description of the PMTS.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0215-4</ee>
<url>db/journals/acta/acta52.html#BenesKLMSS15</url>
</article>
<article mdate="2015-02-04" key="journals/acta/BruniMS15">
<author>Roberto Bruni</author>
<author>Ugo Montanari</author>
<author>Matteo Sammartino</author>
<title>Revisiting causality, coalgebraically.</title>
<pages>5-33</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this paper we recast the classical Darondeau–Degano’s causal semantics of concurrency in a coalgebraic setting, where we derive a compact model. Our construction is inspired by the one of Montanari and Pistore yielding causal automata, but we show that it is instance of an existing categorical framework for modeling the semantics of nominal calculi, whose relevance is further demonstrated. The key idea is to represent events as names, and the occurrence of a new event as name generation. We model causal semantics as a coalgebra over a presheaf, along the lines of the Fiore–Turi approach to the semantics of nominal calculi. More specifically, we take a suitable category of finite posets, representing causal relations over events, and we equip it with an endofunctor that allocates new events and relates them to their causes. Presheaves over this category express the relationship between processes and causal relations among the processes’ events. We use the allocation operator to define a category of well-behaved coalgebras: it models the occurrence of a new event along each transition. Then we turn the causal transition relation into a coalgebra in this category, where labels only exhibit maximal events with respect to the source states’ poset, and we show that its bisimilarity is essentially Darondeau–Degano’s strong causal bisimilarity. This coalgebra is still infinite-state, but we exploit the equivalence between coalgebras over a class of presheaves and History Dependent automata to derive a compact representation, where states only retain the poset of the most recent events for each atomic subprocess, and are isomorphic up to order-preserving permutations. Remarkably, this reduction of states is automatically performed along the equivalence.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0207-9</ee>
<url>db/journals/acta/acta52.html#BruniMS15</url>
</article>
<article mdate="2011-01-11" key="journals/acta/MatsumotoHT96">
<author>Aki Matsumoto</author>
<author>Dong-Soo Han</author>
<author>Takao Tsuda</author>
<title>Alias Analysis of Pointers in Pascal and Fortran 90: Dependence Analysis Between Pointer References.</title>
<pages>99-130</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta33.html#MatsumotoHT96</url>
<abstract>Vectorization and parallelization of programs written in languages where pointers are used is now a subject of increasing interest. The presence of pointers in programs, however, poses new problems to dependence analysis in vectorizing and parallelizing compilers which had been designed to target only at FORTRAN77 programs. In this paper, a new method to analyze dependencies between pointer references in Pascal is proposed, which can also be applied to Fortran 90. It is designed to handle programs with dynamic data structures, such as linear linked lists or trees, which are the most common use of pointers. The method divides into two stages. The first stage is a safe alias analysis which handles any kind of dynamic data structures. The second stage focuses on the specific data structures. It first detects linear linked lists, and then performs dependence analysis between pointer references to the same list. The paper also proposes ways to enhance the second stage. Tree structures are handled here. Loops which manipulate linked lists can now be considered for vectorization by the proposed analysis. Techniques to vectorize such loops are presented in this paper. Some of the proposed algorithms are implemented in V-Pascal, the automatic vectorizing Pascal compiler of our laboratory. The effectiveness of the vectorization of list operations is proved by an experiment on HITAC S-820/80.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050037</ee>
</article>
<article mdate="2013-09-11" key="journals/acta/AczelE97">
<author>J&aacute;nos Acz&eacute;l</author>
<author>Wolfgang Ertel</author>
<title>A New Formula for Speedup and its Characterization.</title>
<pages>637-652</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta34.html#AczelE97</url>
<abstract>We address the task of measuring the relative speed (speedup) of two systems \(A\) and \(B\) for solving the same problem. For example, \(B\) may be a parallel algorithm, parametrized by the number of processors used, whose running time has to be related to a serial standard algorithm \(A\). If \(A\) and/or \(B\) are randomized or if we are interested in their performance on a (discrete) probability distribution of problem instances, the running times are described by random variables \(T^A\) and \(T^B\). The speedup of \(B\) over \(A\) is usually defined as \(E(T^A)/E(T^B)\) where \(E\) denotes the expected value. In many cases this definition is not appropriate for the user of \(A\) or \(B\), because the summation in \(E(T^A)\) and \(E(T^B)\) hides information about the speedup of individual runs. We propose an alternative speedup definition of the form \(M(T^A/ T^B)\) and present a set of intuitive functional equations, which any such function \(M(T^A/T^B)\) should fulfill. Finally, we prove that the weighted geometric mean is the only solution of these equations.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050100</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hoogewijs87">
<author>Albert Hoogewijs</author>
<title>Partial-Predicate Logic in Computer Science.</title>
<pages>381-393</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta24.html#Hoogewijs87</url>
<abstract>In “A Logic Covering Undefinedness in Program Proofs” [1], Barringer, Cheng and Jones present a 3-valued logic designed for Program-Verification and Computer Science applications in general. In this paper we want to add some the oretical background to their arguments for the need for such a system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00292109</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TomarasK91">
<author>Panagiotis J. Tomaras</author>
<author>Demetres D. Kouvatsos</author>
<title>MRE Hierarchical Decomposition of General Queueing Network Models.</title>
<pages>265-295</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta28.html#TomarasK91</url>
<abstract>The principle of Minimum Relative Entropy (MRE), given fully decomposable subset and aggregate mean queue length, utilisation and flow-balance constraints, is used in conjunction with asymptotic connections to infinite capacity queues, to derive new analytic approximations for the conditional and marginal state probabilities of single class general closed queueing network models (QNMs) in the context of a multilevel variable aggregation scheme. The concept of subparallelism is applied to preserve the flow conservation and a universal MRE hierarchical decomposition algorithm is proposed for the approximate analysis of arbitrary closed queueing networks with single server queues and general service-times. Heuristic criteria towards an optimal coupling of network's units at each level of aggregation are suggested. As an illustration, the MRE algorithm is implemented iteratively by using the Generalised Exponential (GE) distributional model to approximate the service and asymptotic flow processes in the network. This algorithm captures the exact solution of separable queueing networks, while for general queueing networks it compares favourably against exact solutions and known approximations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178507</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hernandez93">
<author>H&eacute;ctor J. Hern&aacute;ndez</author>
<title>Extended Nested Relations.</title>
<pages>741-771</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta30.html#Hernandez93</url>
<abstract>This paper describes a conceptual framework for nested relational query processing using “tuple identifiers.” It does this by introducing extended nested relations, relations in which “tuple identifiers” are allowed as attribute values, and by defining two primitives,Index andLookup, that allow query processing based on extensive use of tuple identifiers. Some properties ofIndex and of the flat relational database that it induces are studied in detail.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01191810</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Martinez82">
<author>Michel Martinez</author>
<title>Program Behavior Prediction and Prepaging.</title>
<pages>101-120</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Martinez82</url>
<abstract>The design and evaluation of a prepaging technique is presented. It consists in the preloading, at instants at which page-faults occur, of those pages whose use in the future is the most likely. These pages are determined as a function of an a-priori knowledge of program behavior. We shall first present two tools for predicting that behavior. The first is based on a Markov memory reference transition model, the second on a semi-Markov model of page-fault transitions. Both methods are successively experimented by a paging algorithm allowing prepaging. Experimentation shows that prepaging can significantly improve the performance of the paging algorithm, especially when the prediction is based on the transitions between page-faults. The sensitivity of prepaging performance to various working conditions is tested. Implementation of prepaging is examined and is shown to be feasible without the use of special hardware devices. The study is completed by an evaluation of the influence of prepaging on global system performance. Some common cases of system architecture experimentation show a non-negligible increase in CPU utilization.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262979</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Nicola86">
<author>Victor F. Nicola</author>
<title>A Single Server Queue with Mixed Types of Interruptions.</title>
<pages>465-486</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta23.html#Nicola86</url>
<abstract>The single server M/G/1 queue subject to Poisson interruptions has many useful applications in computer systems modeling. The interruptions are usually characterized by their type of service-preemption discipline. This paper deals with this model in its most general setting, allowing the simultaneous presence of all types of interruptions that may be encountered in real systems. Inspite of the inherent complexity of the analysis, it is possible to derive analytic closed form expressions for interesting performance measures. The results obtained are of theoretical interest as well as of practical significance. In particular, we derive the Laplace Stieltjes transform of the completion time associated with a customer's Śervice and obtain the steady-state average number of customers in the system. An application to the modeling of checkpointing and recovery in a transactional system is considered.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00267867</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Soisalon-Soininen80">
<author>Eljas Soisalon-Soininen</author>
<title>On the Space Optimizing Effect of Eliminating Single Productions from <i> LR </i> Parsers.</title>
<pages>157-174</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Soisalon-Soininen80</url>
<abstract>Single productions in the syntax of a programming language usually have no semantic significance, and thus parsers can be modified so that they do not perform reductions by single productions. In this paper we show that the basic method developed by Pager for eliminating all undesired single productions from LR parsers can cause a quadratic increase in the number of states of the parser. We then define an improvement of Pager's basic method such that generally smaller parsers are produced; in fact, even a quadratic decrease in the number of states is possible. This improvement is further evaluated by giving a sequence of practically motivated grammars for which substantial savings in space are obtained. We also characterize this improvement by a grammatical condition under which it is guaranteed that no increase in the number of states can occur. This condition is compared with a similar condition derivable in the case of Pager's original method.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288542</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MakowskyV86">
<author>Johann A. Makowsky</author>
<author>Moshe Y. Vardi</author>
<title>On the Expressive Power of Data Dependencies.</title>
<pages>231-244</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta23.html#MakowskyV86</url>
<abstract>The class of data dependencies is a class of first-order sentences that seem to be suitable to express semantic constraints for relational databases. We deal with the question of which classes of databases are axiomatizable by data dependencies. (A class Γ of databases is said to be axiomatizable by sentences of a certain kind if there exists a set of sentences of that kind such that Γ is the class of all models of that set.) Our results characterize, by algebraic closure conditions, classes of databases that are axiomatizable by dependencies of different kinds. Our technique is model-theoretic, and the characterization easily entails all previously known results on axiomatizability by dependencies.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289111</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Monien77a"> 
<author>Burkhard Monien</author>
<title>Corrigenda: Transformational Methods and Their Application to Complexity Problems</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>383-384</pages>
<url>db/journals/acta/acta8.html#$</url>
<abstract></abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00271346</ee>
</article>

<article mdate="2012-09-18" key="journals/acta/TanWZR12">
<author>Zhiyi Tan</author>
<author>Long Wan</author>
<author>Qi Zhang</author>
<author>Wei Ren</author>
<title>Inefficiency of equilibria for the machine covering game on uniform machines.</title>
<pages>361-379</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>This paper studies a scheduling game on uniform machines with social cost of maximizing the minimum machine load. For the game with two machines, we present the (Strong) Price of Stability and (Strong) Price of Anarchy as a function of s, the ratio of the speeds of the two machines. These bounds are all tight for any value of s, thus the problem of measuring the inefficiency of equilibria on two uniform machines is completely solved. We also give the tight Price of Anarchy for a special case of three machines. From the results above, we achieve some new and interesting insights of scheduling games.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0163-1</ee>
<url>db/journals/acta/acta49.html#TanWZR12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/QueilleS83">
<author>Jean-Pierre Queille</author>
<author>Joseph Sifakis</author>
<title>Fairness and Related Properties in Transition Systems - A Temporal Logic to Deal with Fairness.</title>
<pages>195-220</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#QueilleS83</url>
<abstract>In this paper we propose a notion of fairness for transition systems and a logic for proving properties under the fairness assumption corresponding to this notion.We start from an informal characterization of the unfairness as the situation where some event becomes possible infinitely often but has only a finite number of occurrences, which induces various definitions of fairness by considering different classes of events. It results from the comparison of these definitions that the concept of fairness which is useful is “fair reachability” of a given set of states P in a system, i.e. reachability of states of P when considering only the computations such that if, during their execution, reaching states of P is possible infinitely often, then states of P are visited infinitely often.This definition of fairness suggests the introduction of a branching time logic FCL, the temporal operators of which express, for a given set of states P, the modalities “it is possible that P” and “it is inevitable that P” by considering fair reachability of P. The main result is that, given a transition system S and a formula f of FCL expressing some property of S under the assumption of fairness, there exists a formula f′ belonging to a branching time logic CL such that: f is valid for S in FCL iff f′ is valid for S in CL. This result shows that proving a property under the assumption of fairness is equivalent to proving some other property without this assumption and that the study of FCL can be made via the “unfair” logic CL, easier to study and for which several results already exist.Finally, the proposed notion of fairness is compared to other related notions such as the absence of livelock, the absence of starvation and the finite delay property.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265555</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Shapiro97">
<author>Alexander Shapiro</author>
<title>A Generalized Distribution Model for Random Recursive Trees.</title>
<pages>211-216</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta34.html#Shapiro97</url>
<abstract> A random tree T n of order n is constructed by choosing in a random tree T n-1 of order n−1 a vertex at random and connecting it to a new vertex labeled n. In the usual constraint we assume that the n−1 vertices of T n-1 are equally likely to be chosen. We introduce and research a more general case in which a distribution of choosing vertices is defined by a sequence α1, α2, ….</abstract>
<ee>http://dx.doi.org/10.1007/s002360050080</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kern77"> 
<author>Walter Kern</author>
<title>Speicheroptimale Formel&uuml;bersetzung.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>269-287</pages>
<url>db/journals/acta/acta7.html#Kern77</url>
<abstract>We investigate the problem of translating expressions optimally, i.e. such that at running time they need as few memory cells as possible and that they can be evaluated fast. An efficient (recursive) algorithm is presented (there is always one based on “trial and error”-methods) for the case of independent inputs and operators to an expression. This includes the case that the result of an operation needs not only one but an arbitrary nonnegative number of auxiliary memory cells which may be determined at compile-time.In [5, 7, 8 and 1] it is shown that it is always possible to compose an optimal translation of an expression α1 o α2 by arbitrary but optimal translations of α1 and α2 if this number is constant. We prove now the existence of special optimal translations of α1 and α2 which always can be composed to an optimal translation of α1 o α2 in the general case. This is the hinge for a recursive algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290337</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/BottoniMPR02">
<author>Paolo Bottoni</author>
<author>Carlos Mart&iacute;n-Vide</author>
<author>Gheorghe Paun</author>
<author>Grzegorz Rozenberg</author>
<title>Membrane systems with promoters/inhibitors.</title>
<pages>695-720</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038010/20380695.htm</ee>
<url>db/journals/acta/acta38.html#BottoniMPR02</url>
</article>
<article mdate="2015-01-08" key="journals/acta/YuR89">
<author>Lin Yu</author>
<author>Daniel J. Rosenkrantz</author>
<title>Minimizing Time-Space Cost for Database Version Control.</title>
<pages>627-663</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta27.html#YuR89</url>
<abstract>We introduce the concept of a version graph to model the problem of minimizing the combined cost of storage space and version regeneration time for database version control systems. We show that, in general, this problem and several of its variations are NP-complete. Several heuristics are developed, and performance guarantees for these heuristics are obtained. We also present linear time algorithms for special classes of version graphs; these special classes are likely to apply in many version control systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00259470</ee>
</article>
<article mdate="2009-06-22" key="journals/acta/SubramaniLG09">
<author>K. Subramani</author>
<author>Hong-Jian Lai</author>
<author>Xiaofeng Gu</author>
<title>Random walks for selected boolean implication and equivalence problems.</title>
<pages>155-168</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>This paper is concerned with the design and analysis of a random walk algorithm for the 2CNF implication problem (2CNFI). In 2CNFI, we are given two 2CNF formulas \({\phi_{1}}\) and \({\phi_{2}}\) and the goal is to determine whether every assignment that satisfies \({\phi_{1}}\) , also satisfies \({\phi_{2}}\) . The implication problem is clearly coNP-complete for instances of kCNF, k ≥ 3; however, it can be solved in polynomial time, when k ≤ 2. The goal of this paper is to provide a Monte Carlo algorithm for 2CNFI with a bounded probability of error. The technique developed for 2CNFI is then extended to derive a randomized, polynomial time algorithm for the problem of checking whether a given 2CNF formula Nae-implies another 2CNF formula.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0089-4</ee>
<url>db/journals/acta/acta46.html#SubramaniLG09</url>
</article>
<article mdate="2006-11-22" key="journals/acta/Gravell07">
<author>Andrew M. Gravell</author>
<title>Verification conditions are code.</title>
<pages>431-447</pages>
<year>2007</year>
<volume>43</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>This paper presents a new theoretical result concerning Hoare Logic. It is shown here that the verification conditions that support a Hoare Logic program derivation are themselves sufficient to construct a correct implementation of the given pre-, and post-condition specification. This property is mainly of theoretical interest, though it is possible that it may have some practical use, for example if predicative programming methodology is adopted. The result is shown to hold for both the original, partial correctness, Hoare logic, and also a variant for total correctness derivations.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-006-0029-5</ee>
<url>db/journals/acta/acta43.html#Gravell07</url>
</article>
<article mdate="2007-09-11" key="journals/acta/Okhotin07">
<author>Alexander Okhotin</author>
<title>Recursive descent parsing for Boolean grammars.</title>
<pages>167-189</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>The recursive descent parsing method for the context-free grammars is extended for their generalization, Boolean grammars, which include explicit set-theoretic operations in the formalism of rules and which are formally defined by language equations. The algorithm is applicable to a subset of Boolean grammars. The complexity of a direct implementation varies between linear and exponential, while memoization keeps it down to linear.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0045-0</ee>
<url>db/journals/acta/acta44.html#Okhotin07</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Qian93">
<author>Zhenyu Qian</author>
<title>An Algebraic Semantics of Higher-Order Types with Subtypes.</title>
<pages>569-607</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta30.html#Qian93</url>
<abstract>This paper extends order-sorted algebras with higher-order functions. The aim is to present a new semantics for higher-order order-sorted types in functional programming, data type specification and program transformation. Our framework unifies higher-order functions, equational deduction, overloading and subtype polymorphism.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01209625</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/EfeE97">
<author>Kemal Efe</author>
<author>Nancy Eleser</author>
<title>An Optimal Emulator and VLSI Layout for Complete Binary Trees.</title>
<pages>429-447</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta34.html#EfeE97</url>
<abstract>How complex does a graph need to be in order to emulate an arbitrary size complete binary tree with the same level of efficiency as would be obtained by a directed complete graph? In this paper, this question is answered by showing that any \(N=2^n\)-node graph needs to have at least \({3N-2\over 2}\) edges in order to perform this emulation. Subsequently, a graph is presented which meets this bound, and it is shown how to optimally embed an arbitrary size complete binary tree in the proposed graph. It is also shown how to optimally embed a \(kN\) node cycle in the proposed graph of \(N\) nodes with unit dilation, unit congestion and uniform load of \(k\). Finally optimal VLSI layouts are presented for the proposed graph which require asymptotically same area as the corresponding layouts for complete binary trees.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050093</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NielsenRSS74"> 
<author>Mogens Nielsen</author>
<author>Grzegorz Rozenberg</author>
<author>Arto Salomaa</author>
<author>Sven Skyum</author>
<title>Nonterminals, Homomorphisms and Codings in Different Variations of OL-Systems. II. Nondeterministic Systems.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>357-364</pages>
<url>db/journals/acta/acta3.html#NielsenRSS74</url>
<abstract>Continuing the work begun in Part I of this paper, we consider now variations of nondeterministic OL-systems. The present Part II of the paper contains a systematic classification of the effect of nonterminals, codings, weak codings, nonerasing homomorphisms and homomorphisms for all basic variations of non-deterministic OL-languages, including table languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263589</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Martin81">
<author>Alain J. Martin</author>
<title>An Axiomatic Definition of Synchronization Primitives.</title>
<pages>219-235</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Martin81</url>
<abstract>The semantics of a pair of synchronization primitives is characterized by three fundamental axioms: boundedness, progress, and fairness. The class of primitives fulfilling the three axioms is semantically defined. Unbuffered communication primitives, the symmetrical P and V operations, and the usual P and V operations are proved to be the three instances of this class. The definitions obtained are used to prove a series of basic theorems on mutual exclusion, producer-consumer coupling, deadlock, and linear and circular arrangements of communicating buffer-processes. An implementation of P and V operations fulfilling the axioms is proposed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00261260</ee>
</article>
<article mdate="2010-02-17" key="journals/acta/BroutinDM08">
<author>Nicolas Broutin</author>
<author>Luc Devroye</author>
<author>Erin McLeish</author>
<title>Weighted height of random trees.</title>
<pages>237-277</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>We consider a model of random trees similar to the split trees of Devroye (SIAM J. Comput. 28(2), 409–432, 1998) in which a set of items is recursively partitioned. Our model allows for more flexibility in the choice of the partitioning procedure, and has weighted edges. We prove that for this model, the height H n of a random tree is asymptotic to c log n in probability for a constant c that is uniquely characterized in terms of multivariate large deviations rate functions. This extension permits us to obtain the height of pebbled tries, pebbled ternary search tries, d-ary pyramids, and to study geometric properties of partitions generated by k-d trees. The model also includes all polynomial families of increasing trees recently studied by Broutin et al. (The height of increasing trees. Random Structures and Algorithms, 2007, in press).</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0069-0</ee>
<url>db/journals/acta/acta45.html#BroutinDM08</url>
</article>
<article mdate="2007-09-11" key="journals/acta/GeeraertsRB07">
<author>Gilles Geeraerts</author>
<author>Jean-Fran&ccedil;ois Raskin</author>
<author>Laurent Van Begin</author>
<title>Well-structured languages.</title>
<pages>249-288</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>This paper introduces the notion of well-structured language. A well-structured language can be defined by a labelled well-structured transition system, equipped with an upward-closed set of accepting states. That peculiar class of transition systems has been extensively studied in the field of computer-aided verification, where it has direct an important applications. Petri nets, and their monotonic extensions (like Petri nets with non-blocking arcs or Petri nets with transfer arcs), for instance, are special subclasses of well-structured transition systems. We show that the class of well-structured languages enjoy several important closure properties. We propose several pumping lemmata that are applicable respectively to the whole class of well-structured languages and to the classes of languages recognized by Petri nets or Petri nets with non-blocking arcs. These pumping lemmata allow us to characterize the limits in the expressiveness of these classes of language. Furthermore, we exploit the pumping lemmata to strictly separate the expressive power of Petri nets, Petri nets with non-blocking arcs and Petri nets with transfer arcs.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0050-3</ee>
<url>db/journals/acta/acta44.html#GeeraertsRB07</url>
</article>
<article mdate="2004-03-03" key="journals/acta/BauerB03">
<author>Friedrich L. Bauer</author>
<author>Manfred Broy</author>
<title>Edsger W. Dijkstra - Acta Informatica and Marktoberdorf.</title>
<pages>141-142</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract></abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0109-8</ee>
<url>db/journals/acta/acta39.html#BauerB03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hoffmann78">
<author>Christoph M. Hoffmann</author>
<title>Design and Correctness of a Compiler for a Non-Procedural Language.</title>
<pages>217-241</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#Hoffmann78</url>
<abstract>Design and correctness proof of a compiler for Lucid, a non-procedural proof-oriented programming language, are given. Starting with the denotational semantics of Lucid, an equivalent operational semantics is derived, and from it the design of compiling algorithms. The algorithms are proved to compile correctly a subset of the language. A discussion of the design choices and of the subset restrictions gives insight into the nature of Lucid as well as into the problem of compiling related non-procedural languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288883</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Vianu87">
<author>Victor Vianu</author>
<title>Database Survivability Under Dynamic Constraints.</title>
<pages>55-84</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta25.html#Vianu87</url>
<abstract>The connection between static constraints satisfied by a database and its future evolution under dynamic constraints is investigated using the notions of survivability and survivability-closure. The static constraints considered here are functional dependencies (fd's). The dynamic constraints are restricted to commonly arising analogs of fd's, called “dynamic” fd's. The results provide new tools for the design of database schemes containing both static and dynamic constraints.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF00268845</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Berzins86">
<author>Valdis Berzins</author>
<title>On Merging Software Extensions.</title>
<pages>607-619</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta23.html#Berzins86</url>
<abstract>The problem of combining independent updates to a program is examined in the context of applicative programs. A partial semantic merge rule is given together with the conditions under which it is guaranteed to be correct, and the conditions under which a string merge corresponds to a semantic merge are examined. The theoretical work reported here contains initial steps towards a solution of the software merging problem and is not sufficient for producing a practical system.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264309</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KouvatsosA89">
<author>Demetres D. Kouvatsos</author>
<author>John Almond</author>
<title>Erratum: Maximum Entropy Two-Station Cyclic Queues with Multiple General Servers.</title>
<pages>501</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta26.html#KouvatsosA89</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289149</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Spuler93">
<author>David Spuler</author>
<title>The Optimal Binary Search Tree for Andersson's Search Algorithm.</title>
<pages>405-407</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta30.html#Spuler93</url>
<abstract>Andersson [1] presented a search algorithm for binary search trees that uses only two-way key comparisons by deferring equality comparisons until the leaves are reached. The use of a different search algorithm means that the optimal tree for the traditional search algorithm, which has been shown to be computable inO(n 2) time by Knuth [3], is not optimal with respect to the different search algorithm. This paper shows that the optimal binary search tree for Andersson's search algorithm can be computed inO(nlogn) time using existing algorithms for the special case of zero successful access frequencies, such as the Hu-Tucker algorithm [2].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01210592</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TripathiFG88">
<author>Satish K. Tripathi</author>
<author>David Finkel</author>
<author>Erol Gelenbe</author>
<title>Load Sharing in Distributed Systems with Failures.</title>
<pages>677-689</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta25.html#TripathiFG88</url>
<abstract>An approximate model is presented for the mean response time in a distributed computer system in which components may fail. Each node in the system periodically performs a checkpoint, and also periodically tests the other nodes to determine whether they are failed or not. When a node fails, it distributes its workload to other nodes which appear to be operational, based on the results of its most recent test. An approximate response time model is developed, explicitly allowing for the delays caused by transactions being incorrectly transferred to failed nodes, because of out-of-date testing results. For the case when all nodes are identical, a closed form solution is derived for the optimal testing rate minimizing the average response time. Numerical results are presented illustrating the relationships among the problem parameters.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00291054</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Benson74"> 
<author>David B. Benson</author>
<title>An Abstract Machine Theory for Formal Language Parsers.</title>
<pages>187-202</pages>
<year>1974</year> 
<volume>3</volume> 
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta3.html#Benson74</url>
<abstract>The usual data necessary for any abstract machine theory is given in categorical terminology. In these terms, an abstract machine theory for formal language parsers is developed, exposing the essential nature of any left-to-right parsing scheme. A weak classification of all parsers for a given language is developed and the usual notions of initial machine, reachable machine and minimal machine apply. Minimality is an extremely weak notion in this theory, although it is equivalent to a simple form of immediate error detection for parsers. Remarks on the construction of parsing procedures are given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264037</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/RangarajanHT97">
<author>Sampath Rangarajan</author>
<author>Yennun Huang</author>
<author>Satish K. Tripathi</author>
<title>On the Scalability and Mean-Time to Failure of k Resilient Protocols.</title>
<pages>543-556</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta34.html#RangarajanHT97</url>
<abstract>Consider a distributed system with \(n\) nodes. A protocol running on this system is \(k\) resilient if it could tolerate up to \(k\) failures and operate correctly. The reliability of such a protocol is defined as the probability that no more than \(k\) nodes have failed. In the first part of the paper, we study the scalability of systems running such protocols. We show the existence of a threshold time of operation for these protocols which we call the scalable mission time (SMT). This scalable mission time is the maximum time until which an asymptotic increase in the system size leads to an asymptotic increase in the reliability of the protocol. We show that beyond this scalable mission time, an asymptotic increase in system size leads to an asymptotic decrease in reliability. We also show techniques to compute the scalable mission time. In the second part of the paper, we show that the scalable mission time for a \(k\) resilient protocol can be used as a good approximation to the mean-time to failure (MTTF) of the protocol, even when the failure distributions are non-exponential and the nodes fail at different rates (a heterogeneous system). We also show that the MTTF asymptotically approaches the SMT with an increase in system size \(n\). Computation of the MTTF is quite difficult when the system is heterogeneous even if the failure distribution of the nodes is exponential. Using experimental results, we show that the SMT approximation to the MTTF gives values very close to the real MTTF. Further, we consider the maintenance interval of systems running \(k\) resilient protocols and show that if the maintenance interval is larger than the scalable mission time, then there is a maximum scalability value beyond which it is undesirable to scale up the size of the system.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050096</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/TsudaUS83">
<author>Takao Tsuda</author>
<author>Akira Urano</author>
<author>Takashi Sato</author>
<title>Transposition of Large Tabular Data Structures with Applications to Physical Database Organization.</title>
<pages>167-182</pages>
<year>1983</year>
<volume>19</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta19.html#TsudaUS83</url>
<abstract>With the use of results in Part I, the organization of physical data structures of relational databases, together with their manipulative aspects, are discussed. The approach is based on the V-storage organization of Part I. Resulting gain and drawbacks are reviewed; in particular, exclusion of inverted files that usually meet only the static retrieval systems raises the problem of effective compensation for speed losses in V-storage search. To resolve this problem, use can be made of (1) order-preserving internal codes so that the data space on which to operate is efficiently compacted, and/or (2) the special page-prefetching algorithm that considers the sequentiality of data search in relational operations. The effect of this page-prefetching policy is demonstrated by computer simulation. Finally, applications of the transposition algorithm of Part I to file inversions are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264474</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ChakaravarthyH02">
<author>Venkatesan T. Chakaravarthy</author>
<author>Susan Horwitz</author>
<title>On the non-approximability of points-to analysis.</title>
<pages>587-598</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038008/20380587.htm</ee>
<url>db/journals/acta/acta38.html#ChakaravarthyH02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/EhrenfeuchtPR96">
<author>Andrzej Ehrenfeucht</author>
<author>Gheorghe Paun</author>
<author>Grzegorz Rozenberg</author>
<title>The Linear Landscape of External Contextual Languages.</title>
<pages>571-593</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta33.html#EhrenfeuchtPR96</url>
<abstract>The class of external contextual languages isstrictly included in the class of linear languages. A reason for the strict inclusion in linear languages is that external contextual grammars generate languages in the exhaustive way: each sentential form belongs to the language of a grammar.In this paper we study the effect of adding various squeezing mechanisms to the basic classes of exhaustive contextual grammars. We obtain in this way a characterization of linear languages and a whole landscape of sublinear families. By restricting the contexts to be one-sided (only left-sided or only right-sided) we obtain a characterization of regular languages — here the subregular landscape reduces to two families.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF03036464</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bulyonkov84">
<author>Mikhail A. Bulyonkov</author>
<title>Polyvariant Mixed Computation for Analyzer Programs.</title>
<pages>473-484</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Bulyonkov84</url>
<abstract>A polyvariant mixed computation algorithm for low-level non-structured programs is presented. A subclass of so called analyser programs has been chosen for which all partial computation that becomes possible during mixed computation is defined over a finite domain of nonsuspended variables. This not only provides termination of mixed computation but allows also to embody in the residual program a control structure encoded in the data.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00271642</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NymeyerK97">
<author>Albert Nymeyer</author>
<author>Joost-Pieter Katoen</author>
<title>Code Generation Based on Formal BURS Therory and Heuristic Search.</title>
<pages>597-635</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta34.html#NymeyerK97</url>
<abstract>BURS theory provides a powerful mechanism to efficiently generate pattern matches in a given expression tree. BURS, which stands for bottom-up rewrite system, is based on term rewrite systems, to which costs are added. We formalise the underlying theory, and derive an algorithm that computes all pattern matches. This algorithm terminates if the term rewrite system is finite. We couple this algorithm with the well-known search algorithm A\(^*\) that carries out pattern selection. The search algorithm is directed by a cost heuristic that estimates the minimum cost of code that has yet to be generated. The advantage of using a search algorithm is that we need to compute only those costs that may be part of an optimal rewrite sequence (and not the costs of all possible rewrite sequences as in dynamic programming). A system that implements the algorithms presented in this work has been built.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050099</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Huwig82">
<author>Hagen Huwig</author>
<title>Ein Modell des <i>P=NP</i> -Problems mit einer positiven L&ouml;sung.</title>
<pages>221-243</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Huwig82</url>
<abstract>Wir diskutieren die Sprachmittel, die zur Formalisierung des P = N P-Problems in einer naiven Mengenlehre benötigt werden. Die Kategorie der kommutativen, idempotenten Semigruppen verfügt über genügend Struktur, daß diese Formalisierung in ihr vorgenommen werden kann. Sie besitzt also ihr eigenes P = N P-Problem. Für dieses Problem gilt P = N P.We discuss the language necessary to give a formalization of the P = N P-question in a Cantor's style set-theory. The internal structure of the category of idempotent, commutative semigroups is rich enough, to carry out this constructions. Hence this category has its own P = N P-question. The answer to this question is: P = N P.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288972</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Yen91">
<author>Hsu-Chun Yen</author>
<title>Priority Systems with many Identical Processes.</title>
<pages>681-692</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#Yen91</url>
<abstract>In this paper, we consider the termination problem for systems with an arbitrary number of identical priority finite-state processes. In our model, the number of finite-state processes involved in the computation is arbitrary, and a priority is assigned to each transition of a process to indicate the degree of importance or urgency. We show that the termination problem is undecidable for such systems, even when the underlying interprocess communication structure is a star. The undecidability result holds for systems with acyclic processes as well. However, if we require that no two processes reside in the same state (except the starting state) during the course of the computation, the termination problem is PSPACE-complete. Finally, we show that if the priority relation is empty, the problem becomes PTIME-complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178682</ee>
</article>
<article mdate="2013-11-28" key="journals/acta/Stos73"> 
<author>Hans-J&ouml;rg Sto&szlig;</author> 
<title>Rangierkomplexit&auml;t von Permutationen</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>80-96</pages>
<url>db/journals/acta/acta2.html#Stos73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Spirn76"> 
<author>Jeffrey R. Spirn</author>
<title>Multi-Queue Scheduling of Two Tasks.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1976</year> 
<pages>217-226</pages>
<url>db/journals/acta/acta7.html#Spirn76</url>
<abstract>Scheduling in the central server queueing model, consisting of a “CPU” server and m “I/O” servers, is considered for the case of two customers. Optimal (maximal CPU utilization) CPU and I/O schedules are obtained. The best CPU schedule depends on the I/O schedule in effect; and is either Longest or Shortest-Expected-Remaining-Processing-Time-First. However, for certain I/O schedules the CPU schedule is immaterial. The best I/O schedule is always to process the longer CPU customer first.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265772</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/MorrisB01">
<author>Joseph M. Morris</author>
<author>Alexander Bunkenburg</author>
<title>A theory of bunches.</title>
<pages>541-561</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037008/10370541.htm</ee>
<url>db/journals/acta/acta37.html#MorrisB01</url>
</article>
<article mdate="2004-03-03" key="journals/acta/Ben-AmramBP03">
<author>Amir M. Ben-Amram</author>
<author>Omer Berkman</author>
<author>Holger Petersen</author>
<title>Element distinctness on one-tape Turing machines: a complete solution.</title>
<pages>81-94</pages>
<year>2003</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We give a complete characterization of the complexity of the element distinctness problem for n elements of \(m\ge\log n\) bits each on deterministic and nondeterministic one-tape Turing machines. We present an algorithm running in time \(O(n^2m(m+2-\log n))\) for deterministic machines and nondeterministic solutions that are of time complexity \(O(nm(n + \log m))\). For elements of logarithmic size \(m = O(\log n)\), on nondeterministic machines, these results close the gap between the known lower bound \(\Omega(n^2\log n)\) and the previous upper bound \(O(n^2(\log n)^{3/2}(\log\log n)^{1/2})\). Additional lower bounds are given to show that the upper bounds are optimal for all other possible relations between m and n. The upper bounds employ hashing techniques, while the lower bounds make use of the communication complexity of set disjointness.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0125-8</ee>
<url>db/journals/acta/acta40.html#Ben-AmramBP03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Reutenauer80">
<author>Christophe Reutenauer</author>
<title>An Ogden-Like Iteration Lemma for Rational Power Series.</title>
<pages>189-197</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Reutenauer80</url>
<abstract>An Ogden-like iteration lemma for languages that are support of rational power series is proved; it is a generalization of Jacob's iteration lemma. The new bound we obtain is much smaller than the one of Jacob and does no more depend on the cardinality of the alphabet. The proof consists in studying how pseudo-regular matrices appear as subproducts of long products of square matrices.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263993</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hoffmann80">
<author>Christoph M. Hoffmann</author>
<title>Semantic Properties of Lucid's Compute Clause and its Compilation.</title>
<pages>9-20</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Hoffmann80</url>
<abstract>Compilation algorithms for a subset of the programming language Lucid are extended so that programs with nested compute clauses can be compiled.The extension is derived from the semantic properties of the compute clause construct, and is applicable to a broad class of compilation algorithms for a subset of Lucid. A correctness proof of the extension is also given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288532</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Soundararajan86">
<author>Neelam Soundararajan</author>
<title>Total Correctness of CSP Programs.</title>
<pages>193-215</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#Soundararajan86</url>
<abstract>In this paper we propose an axiomatic system for proving the total correctness of CSP programs. The system is based on the partial correctness system of [6, 7]. We use the proposed system to prove the total correctness of a program for set partitioning.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289498</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BestDK01">
<author>Eike Best</author>
<author>Raymond R. Devillers</author>
<author>Maciej Koutny</author>
<title>Recursion and Petri nets.</title>
<pages>781-829</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>11-12</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037011/10370781.htm</ee>
<url>db/journals/acta/acta37.html#BestDK01</url>
</article>
<article mdate="2003-11-25" key="journals/acta/KestenMP00">
<author>Yonit Kesten</author>
<author>Zohar Manna</author>
<author>Amir Pnueli</author>
<title>Verification of Clocked and Hybrid Systems.</title>
<pages>837-912</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036011/00360837.htm</ee>
<url>db/journals/acta/acta36.html#KestenMP00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/HuddlestonM82">
<author>Scott Huddleston</author>
<author>Kurt Mehlhorn</author>
<title>A New Data Structure for Representing Sorted Lists.</title>
<pages>157-184</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#HuddlestonM82</url>
<abstract>In this paper we explore the use of weak B-trees to represent sorted lists. In weak B-trees each node has at least a and at most b sons where 2a≦b. We analyse the worst case cost of sequences of insertions and deletions in weak B-trees. This leads to a new data structure (level-linked weak B-trees) for representing sorted lists when the access pattern exhibits a (time-varying) locality of reference. Our structure is substantially simpler than the one proposed in [7], yet it has many of its properties. Our structure is as simple as the one proposed in [5], but our structure can treat arbitrary sequences of insertions and deletions whilst theirs can only treat non-interacting insertions and deletions. We also show that weak B-trees support concurrent operations in an efficient way.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288968</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/KleijnR83">
<author>H. C. M. Kleijn</author>
<author>Grzegorz Rozenberg</author>
<title>On the Generative Power of Regular Pattern Grammars.</title>
<pages>391-411</pages>
<year>1983</year>
<volume>20</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta20.html#KleijnR83</url>
<abstract>It is shown that for every recursively enumerable language L \( \subseteq \)∑* there exists a selective substitution grammar with a regular selector over a binary alphabet that generates L¢5, where ¢∉∑.By requiring additional structural properties of the (already simple) selectors the language generating power is reduced in such a way that the resulting class lies strictly in between the family of EOL languages and the family of context-sensitive languages.For this class of languages some decision problems and normal forms are considered.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264281</ee>
</article>
<article mdate="2008-01-15" key="journals/acta/Calders07">
<author>Toon Calders</author>
<title>The complexity of satisfying constraints on databases of transactions.</title>
<pages>591-624</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>Computing frequent itemsets is one of the most prominent problems in data mining. Recently, a new related problem, called FREQSAT, was introduced and studied: given some itemset–interval pairs, does there exist a database such that for every pair, the frequency of the itemset falls in the interval? In this paper, we extend this FREQSAT-problem by further constraining the database by giving other characteristics as part of the input as well. These characteristics are the maximal transaction length, the maximal number of transactions, and the maximal number of duplicates of a transaction. These extensions and all their combinations are studied in depth, and a hierarchy w.r.t. complexity is given. To make a complete picture, also the cases where the characteristics are constant; i.e., bounded and the bound being a fixed constant that is not a part of the input, are studied.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0060-1</ee>
<url>db/journals/acta/acta44.html#Calders07</url>
</article>
<article mdate="2010-02-16" key="journals/acta/Merro10">
<author>Massimo Merro</author>
<title>On the observational theory of the CPS-calculus.</title>
<pages>111-132</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We apply powerful proof-techniques of concurrency theory to study the observational theory of Thielecke’s CPS-calculus, a distillation of the target language of Continuation-Passing Style transforms. We define a labelled transition system from which we derive a (weak) labelled bisimilarity that completely characterises Morris’ context-equivalence. We prove a context lemma showing that Morris’ context-equivalence coincides with a simpler context-equivalence closed under a smaller class of contexts. Then we profit of the determinism of the CPS-calculus to give a simpler labelled characterisation of Morris’ equivalence, in the style of Abramsky’s applicative bisimilarity. We enhance our bisimulation proof-methods with up to bisimilarity and up to context proof techniques. We use our bisimulation proof techniques to investigate a few algebraic properties on diverging terms that cannot be proved using the original axiomatic semantics of the CPS-calculus.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0112-9</ee>
<url>db/journals/acta/acta47.html#Merro10</url>
</article>
<article mdate="2003-11-25" key="journals/acta/KourieO98">
<author>Derrick G. Kourie</author>
<author>G. Deon Oosthuizen</author>
<title>Lattices in Machine Learning: Complexity Issues.</title>
<pages>269-292</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta35.html#KourieO98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035004/80350269.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Fisher85">
<author>A. J. Fisher</author>
<title>Practical LL(1)-Based Parsing of van Wijngaarden Grammars.</title>
<pages>559-584</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Fisher85</url>
<abstract>An LL(1)-based algorithm is described for parsing a class of van Wijngaarden grammars. The algorithm has been implemented in the concurrent programming language Occam, and is well suited to execution on a multi-processor computer.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289711</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Dijkstra71"> 
<author>Edsger W. Dijkstra</author>
<title>Hierarchical Ordering of Sequential Processes.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1971</year> 
<pages>115-138</pages>
<url>db/journals/acta/acta1.html#Dijkstra71</url>
<abstract>One of the primary functions of an operating system is to rebuild a machine that must be regarded as non-deterministic (on account of cycle stealing and interrupts) into a more or less deterministic automaton. Taming the degree of indeterminacy in steps will lead to a layered operating system. A bottom layer will be discussed and so will the adequacy of the interface it presents. An analysis of the requirements of the correctness proofs will give us an insight into the logical issues at hand. A “director-secretary” relationship will be introduced to reflect a possible discipline in the use of sequencing primitives.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289519</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/AndersonBB76">
<author>E. R. Anderson</author>
<author>F. C. Belz</author>
<author>Edward K. Blum</author>
<title>SEMANOL (73) A Metalanguage for Programming the Semantics of Programming Languages.</title>
<pages>109-131</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#AndersonBB76</url>
<abstract>SEMANOL is a practical programming system for writing readable formal specifications of the syntax and semantics of programming languages. SEMANOL is based on a theory of semantics which embraces algorithmic (operational) and extensional (input/output) semantics. Specifications for large contemporary languages have been constructed in the formal language, SEMANOL (73), which is a readable high-level notation. A SEMANOL (73) specification can be executed (by an existing interpreter program); when given a program from the specified language, and its input, the execution of the SEMANOL (73) specification produces the program's output. The demonstrated executability of SEMANOL (73) provides important practical advantages. This paper includes discussions of the theory of semantics underlying SEMANOL, the syntax and semantics of the SEMANOL (73) language, the use of the SEMANOL (73) language in the SEMANOL method for describing programming languages, and the contrast between the Vienna definition method (VDL) and SEMANOL.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268496</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Thomsen93">
<author>Bent Thomsen</author>
<title>Plain CHOCS: A Second Generation Calculus for Higher Order Processes.</title>
<pages>1-59</pages>
<year>1993</year>
<volume>30</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta30.html#Thomsen93</url>
<abstract>In this paper we present a calculus of communicating systems which allows one to express sending and receiving processes. We call this calculus Plain CHOCS. The calculus is a refinement of our earlier work on the calculus of higher order communicating systems (CHOCS).Essential to the new calculus is the treatment of restriction as a static binding operator on port names. The new calculus is given an operational semantics using labelled transition systems which combines ideas from the applicative transition systems described by Abramsky and the transition systems used for CHOCS. The new calculus enjoys algebraic properties which are similar to those of CHOCS only needing obvious extra laws for the static nature of the restriction operator.Processes as first class objects enable description of networks with changing interconnection structure, and there is a close connection between the Plain CHOCS calculus and the π-Calculus described by Milner, Parrow and Walker: the two calculi can simulate one another.Recently object oriented programming has grown into a major discipline in computational practice as well as in computer science. From a theoretical point of view object oriented programming presents a challenge to any metalanguage since most object oriented languages have no formal semantics. We show how Plain CHOCS may be used to give a semantics to a prototype object oriented language calledO.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01200262</ee>
</article>
<article mdate="2015-01-08" key="journals/acta/Lautemann89">
<author>Clemens Lautemann</author>
<title>The Complexity of Graph Languages Generated by Hyperedge Replacement.</title>
<pages>399-421</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta27.html#Lautemann89</url>
<abstract>Although in many ways, hyperedge replacement graph grammars (HRGs) are, among all graph generating mechanisms, what context-free Chomsky grammars are in the realm of string rewriting, their parsing problem is known to be, in general, NP-complete. In this paper, the main difficulty in HRG parsing is analysed and some conditions on either grammar or input graphs are developed under which parsing can be done in polynomial time. For some of the cases, the parsing problem is shown to be log-space reducible to context-free string parsing.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289017</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CauC96">
<author>Antonio Cau</author>
<author>Pierre Collette</author>
<title>Parallel Composition of Assumption-Commitment Specifications: A Unifying Approach for Shared Variable and Distributed Message Passing Concurrency.</title>
<pages>153-176</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta33.html#CauC96</url>
<abstract>We unify the parallel composition rule of assumption-commitment specifications for respectively state-based and message-based concurrent processes. Without providing language-dependent definitions, we first assume that the model of a process can be given as a set of ‘sequences’ (e.g., traces, state sequences). Then we assume the existence of a merging operator that captures the compositionality of that model. On this basis, we formulate a semantic parallel composition rule for assumptioncommitment specifications wherein the merging operator behaves as a parameter. Then, by providing suitable language-specific definitions for the model of a process and the merging operator, we transform the semantic rule into syntactic ones, both for the state-based and message-based approaches to concurrency.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050039</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Leguy82">
<author>Jeannine Leguy</author>
<title>Langages satur&eacute;s et cones d&eacute;croissants Langages et cones bifid&egrave;les.</title>
<pages>65-78</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Leguy82</url>
<abstract>C(ℒ) (resp.C d (−),C f (−)) est la plus petite famille de langages contenant ℒ et fermée par homomorphisme (resp. homomorphisme alphabétique, homomorphisme non effaçant), homomorphisme inverse (resp. homomorphisme strictement alphabétique inverse, homomorphisme inverse) et par intersection rationnelle.C d (−) etC f (−) sont donc des cônes restreints deC(−). Nous donnons des relations entre cônes restreints deC(−) etC(−). Ce qui nous permet de construire une hiérarchie infinie de langages algébriques non effaçables (L est effaçable ⇔C({L})=C f ({L})).C(ℒ) (resp.C d (−),C f (−)) is the smallest family of languages containing ℒ and closed under morphism (resp. alphabetic morphism, non erasing morphism), inverse morphism (resp. inverse alphabetic non erasing morphism, inverse morphism) and intersection with regular sets.C d (−) andC f (−) are restricted cones ofC(ℒ). We give relations between restricted cones ofC(ℒ) andC(ℒ), that allows us to construct an infinite hierarchy of no-erasable context-fee languages (L is erasable⇔C({L})=C f ({L}))</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625281</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wanke96">
<author>Egon Wanke</author>
<title>Undecidability of Restricted Uniform Recurrence Equations.</title>
<pages>463-475</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta33.html#Wanke96</url>
<abstract>This paper shows that the computability of uniform systems of recurrence equations is undecidable even if the number of indices, the number of recurrence equations, the number of variables, and the number of different index domains are bounded by a constant.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050053</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/LenfantT85">
<author>Jacques Lenfant</author>
<author>Serge Tah&eacute;</author>
<title>Permuting Data with the Omega Network.</title>
<pages>629-641</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#LenfantT85</url>
<abstract>Introduced by Lawrie, the Omega network is a powerful device to connect processing elements in a SIMD computer or in a multiprocessor architecture. Unfortunately it is not rearrangeable and some permutations that are frequently used to align data in a SIMD computer cannot be performed in one pass. Such is the case with the class of permutations induced by a permutation of index digits (PIPID) which includes the perfect shuffle, the bit reversal, etc. ... Using the techniques of linear algebra over the two-element field, we show that PIPIDs can be achieved by the Omega network through which the vector of data is routed twice.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289714</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Giegerich88">
<author>Robert Giegerich</author>
<title>Composition and Evaluation of Attribute Coupled Grammars.</title>
<pages>355-423</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta25.html#Giegerich88</url>
<abstract>With attribute coupled grammars, descriptions of subsequent compilation phases can be composed to a single phase on the description level. This creates the opportunity for independent compiler modularization on the description versus the implementation level. The composition introduces a nontrivial reshaping of attribute dependencies, and hence affects the overall strategy for attribute evaluation. For a hierarchy of evaluation classes reaching from S-attributed to noncircular attribute couplings (ACs), we investigate whether they are closed under composition. Where closure does not hold, we identify subclasses which have the closure property. We show that closure of 1-ordered and simpler classes can only be achieved when there is only a single syntactic attribute allowed, while in the case of absolutely noncircular attribute couplings, an arbitrary number of synthesized syntactic attributes can be used. We show how (suboptimal) evaluators for the composed description are obtained directly from the evaluators of the separate phases. We also investigate the complementary problem of reducing the attribute evaluation complexity of a given, monolithic phase specification by finding an appropriate decomposition into subphases which all belong to simpler evaluation classes. In particular, we find that the closed subclass of sweep-evaluable ACs is generated by a proper subclass ofL-attributed ACs, while a similar characterization of 1-ordered ACs is proved to be impossible. Finally, we relate our observations to known results about descriptive power of attribute grammars and tree transducers.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02737108</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CartwrightO81">
<author>Robert Cartwright</author>
<author>Derek C. Oppen</author>
<title>The Logic of Aliasing.</title>
<pages>365-384</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#CartwrightO81</url>
<abstract>We present a new version of Hoare's logic that correctly handles programs with aliased variables. The central proof rules of the logic (procedure call and assignment) are proved sound and complete.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264535</ee>
</article>
<article mdate="2015-01-07" key="journals/acta/Konig05">
<author>Barbara K&ouml;nig 0001</author>
<title>A general framework for types in graph rewriting.</title>
<pages>349-388</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract>We investigate a general framework which can be instantiated in order to obtain type systems for graph rewriting, allowing us to statically infer behavioural properties of a graph. We describe conditions such as the subject reduction property and compositionality that should be satisfied by such a framework. We present a methodology for proving these conditions, specifically we prove that it is sufficient to show properties that are local to graph transformation rules. In order to show the applicability of this framework, we describe in several case studies how to integrate existing type systems (for the π-calculus and the λ-calculus) and a system for typing acyclic graphs.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0180-4</ee>
<url>db/journals/acta/acta42.html#Konig05</url>
</article>
<article mdate="2005-12-14" key="journals/acta/Cieslik05">
<author>Iwona Cieslik</author>
<title>On-line coloring and cliques covering for K<i>K</i><sub>s, t</sub>-free graphs.</title>
<pages>1-20</pages>
<year>2005</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>The problem of on-line coloring of an arbitrary graphs is known to be hard. Here we consider the problem of on-line coloring in the simplified situation where the input graph is KK s,t -free. We show that the on-line coloring algorithm with the First Fit strategy of proposed by Capponi and Pilotto in [1] is the best one for KK 1,t -free graphs (t≥3). A.Capponi and C.Pilotto have shown that this algorithm achieves a competitive ratio of t−1 while we show that it is the best possible. However for the family of KK s,t -free graphs (s≥2, t≥2) there exists no on-line coloring algorithm with a competitive function. The problem of an on-line cliques covering for these families is hard. There exists no on-line cliques covering algorithm with a competitive function for the family of KK s,t -free graphs (s≥ 1, t≥3). The additional assumption that the input graph is given in a connected way does not help a lot and does not change our results described above.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0167-1</ee>
<url>db/journals/acta/acta42.html#Cieslik05</url>
</article>
<article mdate="2010-12-28" key="journals/acta/BoyarEKL10">
<author>Joan Boyar</author>
<author>Martin R. Ehmsen</author>
<author>Jens S. Kohrt</author>
<author>Kim S. Larsen</author>
<title>A theoretical comparison of LRU and LRU-K.</title>
<pages>359-374</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The paging algorithm Least Recently Used Second Last Request (LRU-2) was proposed for use in database disk buffering and shown experimentally to perform better than Least Recently Used (LRU). We compare LRU-2 and LRU theoretically, using both the standard competitive analysis and the newer relative worst order analysis. The competitive ratio for LRU-2 is shown to be 2k for cache size k, which is worse than LRU’s competitive ratio of k. However, using relative worst order analysis, we show that LRU-2 and LRU are comparable in LRU-2’s favor, giving a theoretical justification for the experimental results. Many of our results for LRU-2 also apply to its generalization, Least Recently Used Kth Last Request.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0123-6</ee>
<url>db/journals/acta/acta47.html#BoyarEKL10</url>
</article>
<article mdate="2004-03-03" key="journals/acta/Wabenhorst03">
<author>Axel Wabenhorst</author>
<title>Stepwise development of fair distributed systems.</title>
<pages>233-271</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>A theory of fairness which supports the specification and development of a wide variety of “fair” systems is developed. The definition of fairness presented is much more general than the standard forms of weak and strong fairness, allowing the uniform treatment of many different kinds of fairness within the same formalism, such as probabilistic behaviour, for example. The semantic definition of fairness consists of a safety condition on finite sequences of actions and a liveness or termination condition on the fair infinite sequences of actions. The definition of the predicate transformer of a fair action system permits the use of the existing framework for program development, including the existing definitions of refinement and data refinement, thus avoiding an ad hoc treatment of fairness. The theory includes results that support the modular development of fair action systems, like monotonicity, adding skips, and data refinement. The weakest precondition and the weakest errorfree precondition are unified, so that in particular a standard action system is a special case of a fair action system. The results are illustrated with the development from specification of an unreliable buffer.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-002-0103-6</ee>
<url>db/journals/acta/acta39.html#Wabenhorst03</url>
</article>
<article mdate="2003-11-25" key="journals/acta/Sibeyn98">
<author>Jop F. Sibeyn</author>
<title>List Ranking on Meshes.</title>
<pages>543-566</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta35.html#Sibeyn98</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035007/80350543.htm</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Kaufholz72"> 
<author>Gerd Kaufholz</author>
<title>Der programmierbare endliche Automat.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>225-241</pages>
<url>db/journals/acta/acta1.html#Kaufholz72</url>
<abstract>The paper deals with finite automata with two tapes, the second tape of which is interpreted as programme tape. For fixed automata those classes: of languages are considered, which can be accepted by variation of the programmes. The representation of all regular sets over some alphabet X by a fixed one-way automaton proves to be impossible. This problem has not yet been solved for automata with rewind instructions and two-way automata, which are strongly more powerful than one-way automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288687</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/Dijkstra80">
<author>Edsger W. Dijkstra</author>
<title>Some Beautiful Arguments Using Mathematical Induction.</title>
<pages>1-8</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Dijkstra80</url>
<abstract>Three elegant proofs and an efficient algorithm are derived. The derivations evolve smoothly from the choice to apply mathematical induction, the pattern of reasoning that has been chosen as the ‘Leitmotiv’ for this small collection. The last proof is the by-product of the algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288531</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/Hesselink02">
<author>Wim H. Hesselink</author>
<title>An assertional criterion for atomicity.</title>
<pages>343-366</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038005/20380343.htm</ee>
<url>db/journals/acta/acta38.html#Hesselink02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Hayes92">
<author>Ian J. Hayes</author>
<title>Multi-Relations in Z.</title>
<pages>33-62</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta29.html#Hayes92</url>
<abstract>Both the theories of binary relations and multi-sets (or bags) in Z have been usefully applied to software specification and development. In this paper we examine a useful theory—multi-relations—which is a cross between these two theories. One way of viewing relations is as sets of pairs. Here, by analogy, we view multi-relations as multi-sets of pairs, and we define multirelation equivalents of most of the traditional operators defined on binary relations. Multi-relations can also be viewed as graphs or two-dimensional matrices (with indices over arbitrary sets).The use of multi-relations is illustrated by specifying a bill-of-materials system. This provides a good example of the paradigm of building a suitable mathematical theory first and then developing a specification in terms of the theory.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178565</ee>
</article>
<article mdate="2005-04-25" key="journals/acta/Vansummeren05">
<author>Stijn Vansummeren</author>
<title>On the complexity of deciding typability in the relational algebra.</title>
<pages>367-381</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<abstract>We investigate the complexity of the typability problem for the relational algebra. This problem consists of deciding, for a given relational algebra expression, whether there exists an assignment of types to variables occurring in the expression such that the expression is well-typed under the assignment. We obtain that the problem is NP-complete in general. In particular, we show that the problem becomes NP-hard due to (1) the cartesian product operator, (2) the selection operator on arbitrary sets of typed predicates, (3) the selection operator on “well-behaved” sets of typed predicates together with join and projection or renaming. However, the problem is in P when (1) we only allow union, difference, join and selection on “well-behaved” sets of typed predicates, or (2) we allow all operators except cartesian product, where the set of selection predicates can mention at most one base type. Most of these results follow from a close connection of the typability problem to non-uniform constraint satisfaction.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0162-6</ee>
<url>db/journals/acta/acta41.html#Vansummeren05</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Csirik89">
<author>J&aacute;nos Csirik</author>
<title>An On-Line Algorithm for Variable-Sized Bin Packing.</title>
<pages>697-709</pages>
<year>1989</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta26.html#Csirik89</url>
<abstract>An on-line algorithm for variable-sized bin packing with an asymptotical worst-case ratio of <1.7 is given. The method is derived from the Harmonic Fit proposed by Lee and Lee. It is proven that, if it is allowed to choose any bin sizes, then with an appropriately chosen second bin size we can have an asymptotical worst-case ratio of 1.4, even with the same algorithm and two bin sizes.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289157</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Rego92">
<author>Vernon Rego</author>
<title>Naive Asymptotics for Hitting Time Bounds in Markov Chains.</title>
<pages>579-594</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>6/7</number>
<url>db/journals/acta/acta29.html#Rego92</url>
<abstract>A set of sufficient conditions is obtained for Markov chains to yield upper and lower passage time bounds. While obtaining expected passage times is strictly a numerical procedure for general Markov chains, the results presented here outline a simple approach to bound expected passage times provided the chains satisfy certain easy to check criteria. The results may be useful in modelling situations, such as in the analysis of algorithms, where simple ways of obtaining average complexity estimates are required.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185562</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Sonnenschein85">
<author>Michael Sonnenschein</author>
<title>Global Storage Cells for Attributes in an Attribute Grammar.</title>
<pages>397-420</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta22.html#Sonnenschein85</url>
<abstract>Very much space is needed to store the values of all attribute instances in an attributed tree at the corresponding nodes; for that reason “global cells” are often used to store values of attribute instances. But these global cells must contain “the right value at the right time”, and, therefore, not all evaluation sequences of attribute instances are admissible, if one uses global cells.In this paper we will study first the problem arising during the construction of such admissible evaluation sequences for attributed trees, if no special property of an underlying ag is presumed. This will lead to a number of restrictions on the “practically allowed” use of global cells. After that we will provide a method for the construction of admissible evaluation sequences for arbitrary attribute trees of given attribute grammars, if global cells are used in the restricted sense. The proposed method is independent of special classes of attribute grammars and can be used with arbitrary evaluator generators.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288775</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Snelting91">
<author>Gregor Snelting</author>
<title>The Calculus of Context Relations.</title>
<pages>411-445</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#Snelting91</url>
<abstract>We present the theory of context relations. Context relations are a method for incremental semantic analysis in language-specific editors, which is able to handle incomplete program fragments. The algorithm is generated from the definition of a language's static semantics and is based on inference rules and order-sorted unification. The paper presents the underlying mathematical theory, optimal incremental analysis algorithms, handling of user-defined polymorphism and overloading, and implementation issues. It is intended as the concluding report on a by now mature concept, which has successfully been used to generate efficient incremental type inferencers for languages like ADA and Fortran 8x.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178581</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/GrecoSZ01">
<author>Sergio Greco</author>
<author>Domenico Sacc&agrave;</author>
<author>Carlo Zaniolo</author>
<title>Extending stratified datalog to capture complexity classes ranging from P to QH.</title>
<pages>699-725</pages>
<year>2001</year>
<volume>37</volume>
<journal>Acta Inf.</journal>
<number>10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1037010/10370699.htm</ee>
<url>db/journals/acta/acta37.html#GrecoSZ01</url>
</article>
<article mdate="2003-11-25" key="journals/acta/CaporasoZ98">
<author>Salvatore Caporaso</author>
<author>Michele Zito</author>
<title>On a Relation Between Uniform Coding and Problems of the Form DTIMEF(<i>F</i>) =? DSPACEF(<i>F</i>).</title>
<pages>665-672</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035008/80350665.htm</ee>
<url>db/journals/acta/acta35.html#CaporasoZ98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Heckmann86">
<author>Reinhold Heckmann</author>
<title>An Efficient ELL(1)-Parser Generator.</title>
<pages>127-148</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#Heckmann86</url>
<abstract>Extended context-free grammars also called regular right part grammars allow for compact and readable descriptions of the syntax of programming languages. Recursion in conventional context-free grammars can in most cases be replaced by iteration. Parser tables of predictive LL-parsers for extended grammars can be generated very efficiently if the length of look-ahead is 1. The generation time is proportional to the size of the parser table, that is the product of grammar size and number of terminal symbols.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289494</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/RudnickiD85">
<author>Piotr Rudnicki</author>
<author>Wlodzimierz Drabent</author>
<title>Proving Properties of Pascal Programs in MIZAR 2.</title>
<pages>311-331</pages>
<year>1985</year>
<volume>22</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta22.html#RudnickiD85</url>
<abstract>In this paper we present the so called natural semantics for a subset of Pascal programming language. A set of sentences of first order predicate calculus defines the meaning of the Pascal language constructs. The meaning of a specific program is defined separately by another set of sentences which can be generated automatically. Both these sets together constitute axiomatics of a theory, called the theory of a specific program. The axiomatics is built in such a way that its logical consequences describe all the computational processes defined by the program. Proofs of properties for two small programs are discussed in detail. These properties and their proofs are recorded in the MIZAR 2 language — a computer formalization of predicate calculus. MIZAR 2 proof checker was used to verify the proofs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265684</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wu94">
<author>Hongzhong Wu</author>
<title>On <i>n</i>-Column 0, 1-Matrices with all <i>k</i>-Projections Surjective.</title>
<pages>285-299</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta31.html#Wu94</url>
<abstract>This paper presents a new approach to construct a smalln-column 0, 1-matrix for two given integersn andk(k<n), such that everyk-column projection contains all 2 k possible row vectors, namely surjective on {0, 1} k . The number of the matrix's rows does not exceed\(2^k \left\lceil {\log (k^2 + 4)} \right\rceil ^{k - 1} \left( {\frac{{2 log n}}{{log(0.25k^2 + 1)}}} \right)^{\left\lceil {\log (0.25k^2 + 1)} \right\rceil } \). This approach has considerable advantage for smallk and practical sizes ofn. It can be applied to the test generation of VLSI circuits, the design of fault tolerant systems and other fields.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01218407</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Yamazaki97">
<author>Koichi Yamazaki</author>
<title>A Hierarchy of the Class of Apex NLC Graph Languages by Bounds on the Number of Nonterminal Nodes in Productions.</title>
<pages>325-335</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta34.html#Yamazaki97</url>
<abstract> In this paper, we consider derivation trees in apex NLC graph languages. We show that for every graph H in arbitrary apex NLC graph language, a decomposition tree of H can be constructed from a derivation tree of H. We also show that there exists a hierarchy in the class of apex NLC graph languages when we restrict the number of nonterminals in the right-hand sides of productions in apex NLC graph grammars.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050087</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CasanovaB81">
<author>Marco A. Casanova</author>
<author>Philip A. Bernstein</author>
<title>General Purpose Schedulers for Database System.</title>
<pages>471</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#CasanovaB81</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264539</ee>
</article>
<article mdate="2012-06-14" key="journals/acta/BozzelliLP12">
<author>Laura Bozzelli</author>
<author>Axel Legay</author>
<author>Sophie Pinchinat</author>
<title>On timed alternating simulation for concurrent timed games.</title>
<pages>249-279</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>We address the problem of alternating simulation refinement for concurrent timed games (TG). We show that checking timed alternating simulation between TG is EXPTIME-complete, and provide a logical characterization of this preorder in terms of a meaningful fragment of a new logic, TAMTL*. TAMTL* is an action-based timed extension of standard alternating-time temporal logic ATL*, which allows to quantify over strategies where the designated coalition of players is not responsible for blocking time. While for full TAMTL*, model-checking TG is undecidable, we show that for its fragment TAMTL, corresponding to the timed version of ATL, the problem is instead decidable and in EXPTIME.</abstract>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0158-y</ee>
<url>db/journals/acta/acta49.html#BozzelliLP12</url>
</article>
<article mdate="2010-10-24" key="journals/acta/KimY10">
<author>Ik-Soon Kim</author>
<author>Kwangkeun Yi</author>
<title>LR error repair using the A* algorithm.</title>
<pages>179-207</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>This article presents a local LR error repair method that repairs syntax errors quickly by adoption of the A* algorithm that helps remove unproductive configurations. The new method also enhances the repair quality by adoption of a flexible edit strategy to support shifting symbols unrestrictedly, as well as inserting and deleting symbols, in order to repair invalid input strings. Experimental results show that the new method excels existing works in repair quality and efficiency.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0115-6</ee>
<url>db/journals/acta/acta47.html#KimY10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/OwickiG76">
<author>Susan S. Owicki</author>
<author>David Gries</author>
<title>An Axiomatic Proof Technique for Parallel Programs I.</title>
<pages>319-340</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#OwickiG76</url>
<abstract>A language for parallel programming, with a primitive construct for synchronization and mutual exclusion, is presented. Hoare's deductive system for proving partial correctness of sequential programs is extended to include the parallelism described by the language. The proof method lends insight into how one should understand and present parallel programs. Examples are given using several of the standard problems in the literature. Methods for proving termination and the absence of deadlock are also given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268134</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AvenhausM77">
<author>J&uuml;rgen Avenhaus</author>
<author>Klaus Madlener</author>
<title>Subrekursive Komplexit&auml;t bei Gruppen: I. Gruppen mit vorgeschriebener Komplexit&auml;t.</title>
<pages>87-104</pages>
<year>1977</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#AvenhausM77</url>
<abstract>A finitely presented (f.p.) group has a K-decidable word problem for a complexity class K if the group operations are K-functions. Using a construction of Boone and Britton [15] we show that for two complexity classes K and K with K a f.p. group can be constructed with K but not K-decidable word problem.As a consequence of this result it is shown that there is a f.p. K-decidable group with generalized word problem of complexity K, there is no universal K-decidable f.p. group, there is a r.p. not K-decidable simple group (K≠ℛ).</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263767</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Munch-AndersenZ77"> 
<author>Bo Munch-Andersen</author>
<author>Torben U. Zahle</author>
<title>Scheduling According to Job Priority with Prevention of Deadlock and Permanent Blocking.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>153-175</pages>
<url>db/journals/acta/acta8.html#Munch-AndersenZ77</url>
<abstract>New low priority jobs will never block older higher priority jobs.Requests are always granted if they cannot delay higher priority jobs.Any priority rule may be chosen.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289247</ee>
</article>

<article mdate="2003-11-25" key="journals/acta/Shen99">
<author>Hong Shen</author>
<title>Finding the <i>k</i> Most Vital Edges with Respect to Minimum Spanning Tree.</title>
<pages>405-424</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036005/90360405.htm</ee>
<url>db/journals/acta/acta36.html#Shen99</url>
</article>
<article mdate="2003-11-25" key="journals/acta/FiatW99">
<author>Amos Fiat</author>
<author>Gerhard J. Woeginger</author>
<title>On-Line Scheduling on a Single Machine: Minimizing the Total Completion Time.</title>
<pages>287-293</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036004/90360287.htm</ee>
<url>db/journals/acta/acta36.html#FiatW99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ming-Hua88">
<author>Zhang Ming-Hua</author>
<title>A Second Order Theory of Data Types.</title>
<pages>283-303</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta25.html#Ming-Hua88</url>
<abstract>A specification method for abstract data types based on manysorted second order logic is presented. In our approach the specification is composed of two parts: the first part specifies a set of objects and a set of fundamental operations; the other part specifies an arbitrary number of augmenting operations. The fundamental operations are called constructors. On the basis of constructors the axioms can be put into schematic forms and the resulting theory is categorical.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00283330</ee>
</article>
<article mdate="2005-11-14" key="journals/acta/Zuliani05">
<author>Paolo Zuliani</author>
<title>Compiling quantum programs.</title>
<pages>435-474</pages>
<year>2005</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>In this paper we study a possible compiler for a high-level imperative programming language for quantum computation, the quantum Guarded-Command Language (qGCL). It is important because it liberates us from thinking of quantum algorithms at the data-flow level, in the same way as happened for standard computation a few decades ago.We make use of the normal-form approach to compiler design, introduced by Hoare, Jifeng and Sampaio. In this approach a source program is transformed, by means of algebraic manipulations, into a particular form which can be directly executed by a target machine. This entails the definition of a simple quantum hardware architecture, derived from Hoare et al.’s computing model.Our work provides a general framework for the construction of a compiler for qGCL, focusing mainly on the correctness of the design. Here we do not deal with other topics such as efficiency of compiled code, factorisation of unitary transformations and compilation of quantum data structures.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-005-0165-3</ee>
<url>db/journals/acta/acta41.html#Zuliani05</url>
</article>
<article mdate="2013-08-30" key="journals/acta/ChristFL13">
<author>Marie G. Christ</author>
<author>Lene M. Favrholdt</author>
<author>Kim S. Larsen</author>
<title>Online multi-coloring on the path revisited.</title>
<pages>343-357</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>Multi-coloring on the path is a model for frequency assignment in linear cellular networks. Two models have been studied in previous papers: calls may either have finite or infinite duration. For hexagonal networks, a variation of the models where limited frequency reassignment is allowed has also been studied. We add the concept of frequency reassignment to the models of linear cellular networks and close these problems by giving matching upper and lower bounds in all cases. We prove that no randomized algorithm can have a better competitive ratio than the best deterministic algorithms. In addition, we give an exact characterization of the natural greedy algorithms for these problems. All of the above results are with regard to competitive analysis. Taking steps towards a more fine-grained analysis, we consider the case of finite calls and no frequency reassignment and prove that, even though randomization cannot bring the competitive ratio down to one, it seems that the greedy algorithm is expected optimal on uniform random request sequences. We prove this for small paths and indicate it experimentally for larger graphs.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0184-4</ee>
<url>db/journals/acta/acta50.html#ChristFL13</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Tarjan76">
<author>Robert Endre Tarjan</author>
<title>Edge-Disjoint Spanning Trees and Depth-First Search.</title>
<pages>171-185</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#Tarjan76</url>
<abstract>This paper presents an algorithm for finding two edge-disjoint spanning trees rooted at a fixed vertex of a directed graph. The algorithm uses depthfirst search and an efficient method for computing disjoint set unions. It requires O (eα(e, n)) time and O(e) space to analyze a graph with n vertices and e edges, where α (e, n) is a very slowly growing function related to a functional inverse of Ackermann's function.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268499</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/HoareW73"> 
<author>C. A. R. Hoare</author>
<author>Niklaus Wirth</author>
<title>An Axiomatic Definition of the Programming Language PASCAL</title>
<journal>Acta Inf.</journal>
<volume>2</volume> 
<year>1973</year> 
<pages>335-355</pages>
<url>db/journals/acta/acta2.html#HoareW73</url>
</article>


<article mdate="2011-01-11" key="journals/acta/Wurgers81">
<author>Harald W&uuml;rgers</author>
<title>A Specification Technique Based on Predicate Transformers.</title>
<pages>425-445</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Wurgers81</url>
<abstract>This paper proposes a formal specification technique based on the notion of predicate transformers. Several approaches to showing the completeness are investigated. A method for proving the correctness of an implementation with respect to a formal specification is described.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264537</ee>
</article>
<article mdate="2011-08-18" key="journals/acta/Vagvolgyi11">
<author>S&aacute;ndor V&aacute;gv&ouml;lgyi</author>
<title>CHAP and rewrite components.</title>
<pages>317-361</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>We present an additional feature to the Challenge Handshake Authentication Protocol. It makes the protocol resilient to offline brute-force/dictionary attacks. We base our contribution to the protocol on the concept of a rewrite complement for ground term rewrite systems (GTRSs). We also introduce and study the notion of a type-based complement which is a special case of a rewrite complement. We show the following decision results. Given GTRSs A, C, and a reduced GTRS B over some ranked alphabet Σ, one can decide whether C is a type-based complement of A for B. Given a GTRS A and a reduced GTRS B over some ranked alphabet Σ, one can decide whether there is a GTRS C such that C is a type-based complement of A for B. If the answer is yes, then we can construct such a GTRS C.</abstract>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0141-z</ee>
<url>db/journals/acta/acta48.html#Vagvolgyi11</url>
</article>
<article mdate="2003-11-25" key="journals/acta/SimoviciCC02">
<author>Dan A. Simovici</author>
<author>Dana Cristofor</author>
<author>Laurentiu Cristofor</author>
<title>Impurity measures in databases.</title>
<pages>307-324</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038005/20380307.htm</ee>
<url>db/journals/acta/acta38.html#SimoviciCC02</url>
</article>
<article mdate="2015-01-08" key="journals/acta/HehnerM87">
<author>Eric C. R. Hehner</author>
<author>Andrew J. Malton</author>
<title>Termination Conventions and Comparative Semantics.</title>
<pages>1-14</pages>
<year>1988</year>
<volume>25</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta25.html#HehnerM87</url>
<abstract>The notion of termination is examined, first for its physical observability, then for its part in six semantic formalisms, with emphasis on predicative semantics.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF00268842</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Koutny86">
<author>Maciej Koutny</author>
<title>The Merlin-Randell Problem of Train Journeys.</title>
<pages>429-463</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta23.html#Koutny86</url>
<abstract>The following synchronization problem is studied: “There is a finite set of trains, a finite set of stations, and the engine house. Each station can hold only one train. Each train has a route to follow starting and ending at the engine house. The route may be repeated one or more times. A train may leave a station (or the engine house) only when its immediate destination is an empty station or the engine house. At the beginning all trains are placed at the engine house. The problem is to find a synchronization among train movements which allows parallel movements of trains where possible and enables the completion of each train journey”.A formal model of the train system is proposed assuming that each train route is deterministic and contains no repeated stations. The model is based on the notion of a movement graph being a labeled directed multigraph, the nodes of which represent stations, the arcs of which represent possible train movements. The solution proposed is based on a characterization of inadmissible situations by means of some subgraphs of the movement graph. The properties of these subgraphs, called minimal critical patterns, are investigated. Optimal and suboptimal synchronization strategies are defined. A specification of the optimal strategy in the basic COSY notation is included, and its correctness is demonstrated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00267866</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MikouT79">
<author>N. Mikou</author>
<author>S. Tucci</author>
<title>Analyse et optimisation d'une proc&eacute;dure de reprise dans un syst&egrave;me de gestion de donn&eacute;es centralis&eacute;es.</title>
<pages>321-338</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#MikouT79</url>
<abstract>Le sujet de cet article est l'étude d'un système de gestion de données qui opère en présence de pannes intermittentes et dans lequel des points de reprise (PR) sont établis pour permettre la reprise après une défaillance du système. Un PR est établi après le traitement de N transactions, N étant un nombre entier fixe.Nous proposons un modèle mathématique qui nous permet de calculer la disponibilité du système. Des simulations sont également faites pour valider ces résultats. Nous comparons nos résultats à ceux de Gelenbe [10] qui suppose qu'un PR est établi après un temps fixe de fonctionnement normal du système et nous montrons que, sous certaines conditions, les deux approches sont équivalentes aussi bien du point de vue de la disponibilité du système que des valeurs optimales du temps entre PR successifs.We have investigated a transaction oriented computer system operating in the presence of intermittent failures. The system integrity is maintained by a built-in checkpoint and roll-back recovery schema. The analytical results, concerning system availability and stability, are compared with those of Gelenbe [10] and validated through simulation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268319</ee>
</article>
<article mdate="2015-03-19" key="journals/acta/HennickerK15">
<author>Rolf Hennicker</author>
<author>Alexander Knapp</author>
<title>Moving from interface theories to assembly theories.</title>
<pages>235-268</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>We show how interface theories supporting pairwise component analysis can be extended in a generic way to a multi-component environment. This leads to the abstract framework of an assembly theory which captures notions of assembly refinement and communication-safety in assemblies of interacting components. An assembly theory supports also encapsulation of assemblies into interfaces and hence hierarchical constructions. We propose general rules that should be satisfied by any concrete assembly theory, like compositional construction and refinement of communication-safe assemblies. We discuss general procedures how to construct an assembly theory on top of a given interface theory such that (some of) the laws of an assembly theory are automatically guaranteed by the properties of an underlying interface theory. As a proof of concept we consider two instances of our approach. The first one starts from the (optimistic) interface theory of interface automata proposed by de Alfaro and Henzinger, and the second one from the (pessimistic) interface theory of modal I/O-interfaces. In the latter case, we propose a new notion of modal assembly refinement which has all the required properties, in particular it preserves modal communication-safety of assemblies. A small case-study illustrates how our concepts can be methodologically applied.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0220-7</ee>
<url>db/journals/acta/acta52.html#HennickerK15</url>
</article>
<article mdate="2003-11-25" key="journals/acta/SernadasSC98">
<author>Am&iacute;lcar Sernadas</author>
<author>Cristina Sernadas</author>
<author>Carlos Caleiro</author>
<title>Denotational Semantics of Object Specification.</title>
<pages>729-773</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035009/80350729.htm</ee>
<url>db/journals/acta/acta35.html#SernadasSC98</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Buzen76"> 
<author>Jeffrey P. Buzen</author>
<title>Fundamental Operational Laws of Computer System Performance.</title>
<pages>167-182</pages>
<year>1976</year> 
<volume>7</volume> 
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta7.html#Buzen76</url>
<abstract>A number of laws are derived which establish relationships between throughput, response time, device utilization, space-time products and various other factors related to computer system performance. These laws are obtained through the operational method of computer system analysis. The operational method, which is formally introduced in this paper, differs significantly from the conventional stochastic modeling approach and is based on a set of concepts that correspond naturally and directly to observed properties of real computer systems. The operational laws presented in this paper apply with complete precision to all collections of observational data, and they are similar to fundamental laws found in other areas of engineering and applied science.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265769</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/GinsburgS75"> 
<author>Seymour Ginsburg</author>
<author>Edwin H. Spanier</author>
<title>Substitution of Grammar Forms.</title>
<journal>Acta Inf.</journal>
<volume>5</volume> 
<year>1975</year> 
<pages>377-386</pages>
<url>db/journals/acta/acta5.html#GinsburgS75</url>
<abstract>Given grammar forms F and F′, the grammar form Sûb (F, Ft') is defined as that obtained by substituting the start variable of F′ for every occurrence of a terminal in F. The main result is that if F is a nontrivial grammar form, then the grammatical family defined by Sûb (F, F′) is the set of languages obtained by substituting languages in the family defined by F′ into the family defined by F. Thus the substitution of one grammatical family into another is a grammatical family. It follows as a corollary that the full AFL generated by a grammatical family is a grammatical family.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264567</ee>
</article>

<article mdate="2005-11-16" key="journals/acta/CastellanosMMS03">
<author>Juan Castellanos</author>
<author>Carlos Mart&iacute;n-Vide</author>
<author>Victor Mitrana</author>
<author>Jos&eacute; M. Sempere</author>
<title>Networks of evolutionary processors.</title>
<pages>517-529</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract><ee>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0001-5903&amp;volume=39&amp;issue=6&amp;spage=517</ee>
<url>db/journals/acta/acta39.html#CastellanosMMS03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SutnerM88">
<author>Klaus Sutner</author>
<author>Wolfgang Maass</author>
<title>Motion Planning Among Time Dependent Obstacles.</title>
<pages>93-122</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#SutnerM88</url>
<abstract>In this paper we study the problem of motion planning in the presence of time dependent, i.e. moving, obstacles. More specifically, we will consider the problem: given a bodyB and a collection of moving obstacles inD-dimensional space decide whether there is a continuous, collision-free movement ofB from a given initial position to a target position subject to the condition thatB cannot move any faster than some fixed top-speedc. As a discrete, combinatorial model for the continuous, geometric motion planning problem we introduce time-dependent graphs. It is shown that a path existence problem in time-dependent graphs is PSPACE-complete. Using this result we will demonstrate that a version of the motion planning problem (where the obstacles are allowed to move periodically) is PSPACE-hard, even ifD=2, B is a square and the obstacles have only translational movement. ForD=1 it is shown that motion planning is NP-hard. Furthermore we introduce the notion of thec-hull of an obstacle: thec-hull is the collection of all positions in space-time at which a future collision with an obstacle cannot be avoided. In the low-dimensional situationD=1 andD=2 we develop polynomial-time algorithms for the computation of thec-hull as well as for the motion planning problem in the special case where the obstacles are polyhedral. In particular forD=1 there is aO(n lgn) time algorithm for the motion planning problem wheren is the number of edges of the obstacle.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915447</ee>
</article>
<article mdate="2013-02-05" key="journals/acta/DassowMT13">
<author>J&uuml;rgen Dassow</author>
<author>Florin Manea</author>
<author>Bianca Truthe</author>
<title>Networks of evolutionary processors: the power of subregular filters.</title>
<pages>41-75</pages>
<year>2013</year>
<volume>50</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this paper, we propose a hierarchy of families of languages generated by networks of evolutionary processors where the filters belong to several special classes of regular sets. More precisely, we show that the use of filters from the class of ordered, non-counting, power-separating, circular, suffix-closed regular, union-free, definite, and combinational languages is as powerful as the use of arbitrary regular languages and yields networks that can generate all the recursively enumerable languages. On the other hand, the use of filters that are only finite languages allows only the generation of regular languages, but not every regular language can be generated. If we use filters that are monoids, nilpotent languages, or commutative regular languages, we obtain one and the same family of languages which contains non-context-free languages but not all regular languages. These results seem to be of interest because they provide both upper and lower bounds on the families of languages that one can use as filters in a network of evolutionary processors in order to obtain a complete computational model.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0172-0</ee>
<url>db/journals/acta/acta50.html#DassowMT13</url>
</article>
<article mdate="2005-01-25" key="journals/acta/FriscoH04">
<author>Pierluigi Frisco</author>
<author>Hendrik Jan Hoogeboom</author>
<title>P systems with symport/antiport simulating counter automata.</title>
<pages>145-170</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>The generative capability of several variants of P systems with symport/antiport is studied via the simulation of counter automata. This leads to the reduction of the complexity, expressed in number of membranes and weight of rules, of P systems generating recursively enumerable sets.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-004-0154-y</ee>
<url>db/journals/acta/acta41.html#FriscoH04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Ben-Ari78">
<author>Mordechai Ben-Ari</author>
<title>Ianov Pushdown Schemes Are Contained in Boolean Recursive Schemes.</title>
<pages>117-125</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Ben-Ari78</url>
<abstract>The class of Ianov schemes augmented by a pushdown memory is effectively translatable into the class of right linear boolean monadic recursive schemes. This proves a conjecture of Tokura, Kasami and Furuta [3].</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289151</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Hamlet81">
<author>Richard G. Hamlet</author>
<title>Reliability Theory of Program Testing.</title>
<pages>31-43</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#Hamlet81</url>
<abstract>Augment program specifications so that the equivalence problem for programs meeting a given specification is solvable by testing;Restrict the class of errors a test must expose so that within this class testing can distinguish the correct programs.In both variations a new idea arises naturally. Test data “determines” programs for which it is reliable (in the variations defined): given the data there is an algorithm for deciding if programs satisfying it have unique behavior. Any variation of the reliability idea which can be effectively recognized can be used to determine programs in this way.A testing methodology is proposed based on any effective reliability notion. A human being, using noneffective methods, attempts to satisfy a mechanical judgement of reliability. If the person succeeds, the resulting test can be attached to the program, where it is useful when the program is changed. Confidence in the program/test combination is based on the knowledge that no program can satisfy the test yet differ from the given one. That is, the test itself is an unambiguous specification of the program.It is proposed that testing theory seek out modified reliability ideas with this effective, determining property, and that noneffective ideas of program correctness may find their practical place in aiding people to discover the necessary tests.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289588</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Penttonen74"> 
<author>Martti Penttonen</author>
<title>On Derivation Languages Corresponding to Context-Free Grammars.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>285-291</pages>
<url>db/journals/acta/acta3.html#Penttonen74</url>
<abstract>A derivation language associated with a context-free grammar is the set of all terminating derivations. Hierarchy and closure properties of these languages are considered. In addition to the formerly known solvability of the emptiness and finiteness problems the equivalence problem is shown to be solvable for derivation languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288639</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Wegner80">
<author>Lutz Michael Wegner</author>
<title>On Parsing Two-Level Grammars.</title>
<pages>175-193</pages>
<year>1980</year>
<volume>14</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta14.html#Wegner80</url>
<abstract>Making use of the fact that two-level grammars (TLGs) may be thought of as finite specification of context-free grammars (CFGs) with “infinite” sets of productions, known techniques for parsing CFGs are applied to TLGs by first specifying a canonical CFG G′ — called skeleton grammar — obtained from the “cross-reference” of the TLG G. Under very natural restrictions it can be shown that for these grammar pairs (G, G′) there exists a 1 — 1 correspondence between leftmost derivations in G and leftmost derivations in G′. With these results a straightforward parsing algorithm for restricted TLGs is given.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288543</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/Meduna03a">
<author>Alexander Meduna</author>
<title>Erratum: Coincidental extension of scattered context languages.</title>
<pages>699</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<abstract>All the results given in the paper hold true. In the proof of Theorem 1, change steps IV, V, and VI toIV. for every \(a,b,c \in T\), add \((\langle a\rangle,\langle b \rangle,\langle c \rangle,\$) \rightarrow (\langle 0a \rangle,\langle 0b \rangle,\langle 0c \rangle,\S)\) to P;V. for every \(a,b,c,d \in T\), add \((Y, \langle 0a \rangle, Y, \langle 0b \rangle, Y, \langle 0c \rangle, \S) \rightarrow \# , \langle 0a \rangle, X, \langle 0b \rangle, Y, \langle 0c \rangle, \S)\), \((\langle 0a\rangle, \langle 0b \rangle, \langle 0c \rangle, \S) \rightarrow (\langle 4a \rangle, \langle 1b \rangle, \langle 2c \rangle, \S)\), \((\langle 4a \rangle, X, \langle 1b \rangle, Y, \langle 2c \rangle, \S) \rightarrow (\langle 4a \rangle, \# , \langle 1b \rangle, X, \langle 2c \rangle, \S)\), \((\langle 4a \rangle, \langle 1b \rangle, \langle 2c \rangle, \langle d \rangle, \S \rightarrow (a, \langle 4b \rangle, \langle 1c \rangle, \langle 2d \rangle, \S)\), \((\langle 4a \rangle, \langle 1b \rangle, \langle 2c \rangle, \S) \rightarrow (a, \langle 1b \rangle, \langle 3c \rangle, \S)\), \((\langle 1a \rangle, X, \langle 3b \rangle, Y, \S) \rightarrow (\langle 1a \rangle, \# , \langle 3b \rangle, \# , \S)\) to P;VI. for every \(a, b \in T\), add \((\langle 1a \rangle, X, \langle 3b \rangle, \S) \rightarrow (a, \# , b, \# )\) to P.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0127-6</ee>
<url>db/journals/acta/acta39.html#Meduna03a</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FlajoletG94">
<author>Philippe Flajolet</author>
<author>Mordecai J. Golin</author>
<title>Mellin Transforms and Asymptotics: The Mergesort Recurrence.</title>
<pages>673-696</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta31.html#FlajoletG94</url>
<abstract>Mellin transforms and Dirichlet series are useful in quantifying periodicity phenomena present in recursive divide-and-conquer algorithms. This note illustrates the techniques by providing a precise analysis of the standard topdown recursive mergesort algorithm, in the average case, as well as in the worst and best cases. It also derives the variance and shows that the cost of mergesort has a Gaussian limiting distribution. The approach is applicable to a number of divide-and-conquer recurrences.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177551</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Gelenbe79">
<author>Erol Gelenbe</author>
<title>Probabilistic Models of Computer Systems.</title>
<pages>285-303</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Gelenbe79</url>
<abstract>In this paper we examine certain problems related to the use of diffusion approximations for the approximate modelling of computer systems. In particular we develop a model which allows us to handle waiting times and batch arrivals: these results are a new approach to the use of diffusion approximations. We also examine the effect of the distribution of holding times at boundaries: this question had remained open in earlier studies. We show that the stationary distributions associated with these diffusion models depend only on the average residence time of the process on the boundaries and not on the complete distribution function. This result justifies the use of exponential holding times as had been done in an earlier study.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00268317</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/FokkinkV03">
<author>Wan Fokkink</author>
<author>Thuy Duong Vu</author>
<title>Structural operational semantics and bounded nondeterminism.</title>
<pages>501-516</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract><ee>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0001-5903&amp;volume=39&amp;issue=6&amp;spage=501</ee>
<url>db/journals/acta/acta39.html#FokkinkV03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Rodriguez81">
<author>F. Rodriguez</author>
<title>Ind&eacute;pendance Forte de Certaines Op&eacute;rations.</title>
<pages>153-166</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Rodriguez81</url>
<abstract>Using properties of operations compelled by an operator introduced in [17, 19, 20] and technics developed in [12], we compare the operations of marked star, chevron, bracket, open bracket, homomorphic replication and substitution. Dependence or strong independence of these operations are then established.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288963</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/SavickyW97">
<author>Petr Savick&yacute;</author>
<author>Ingo Wegener</author>
<title>Efficient Algorithms for the Transformation Between Different Types of Binary Decision Diagrams.</title>
<pages>245-256</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta34.html#SavickyW97</url>
<abstract>The problem of transforming an FBDD (free binary decision diagram) \(P\) on \(n\) variables or a \(\pi'\)OBDD (ordered binary decision diagram with respect to the variable ordering \(\pi'\)) \(P\) for the Boolean function \(f\) into the reduced \(\pi\)OBDD \(Q\) for \(f\) is considered. The algorithms run in time \(O(\vert P \vert \vert Q \vert \log \vert Q \vert )\) (where, e.g., \(\vert P \vert \) is the size of \(P\)) and need space \(O(\vert P \vert +n \cdot \vert Q \vert )\), if \(P\) may be an FBDD, or \(O(\vert P \vert + \vert Q \vert )\), if \(P\) is known to be an OBDD. The problem is important for the improvement of given variable orderings, e.g., by simulated annealing or genetic algorithms, and in the situation where incompatible representations of functions have to be made compatible.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050083</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HarrisonK92">
<author>Peter G. Harrison</author>
<author>Hessam Khoshnevisan</author>
<title>On the Synthesis of Function Inverses.</title>
<pages>211-239</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta29.html#HarrisonK92</url>
<abstract>We present a method for synthesising recursive inverses for first-order functions. Since inverse functions are not, in general, single-valued, we introduce a powerdomain to define their semantics, in terms of which we express their transformation into recursive form. First, inverses that require unification at run-time are synthesised and these are then optimised by term-rewriting based on a set of axioms that facilitates a form of compile-time unification. The optimisations reduce the dependency on run-time unification, in many instances removing it entirely to give a recursive inverse. The efficiency of the use of relations in two modes is thereby improved, so enhencing extended functional languages endowed with logical variables and narrowing semantics. Our function-level, axiomatised system is more generally applicable than previous approaches to this type of optimis tion, and in general induces more mechanisable transformation systems.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01185679</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HuleMO78">
<author>H. Hule</author>
<author>Hermann A. Maurer</author>
<author>Thomas Ottmann</author>
<title>Good OL Forms.</title>
<pages>345-353</pages>
<year>1978</year>
<volume>9</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta9.html#HuleMO78</url>
<abstract>For the study of grammatical similarity of L systems the notion of an L form has been introduced recently. In particular, complete forms and their generalizations, good forms, have been studied. In this paper the ramification of these notions as applied to OL systems is investigated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289047</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AlfaC91">
<author>Attahiru Sule Alfa</author>
<author>Mingyuan Chen</author>
<title>Approximating Queue Lengths in <i>M</i>(t)/<i>G</i>/1 Queue Using the Maximum Entropy Principle.</title>
<pages>801-815</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>8</number>
<url>db/journals/acta/acta28.html#AlfaC91</url>
<abstract>Using the discrete time approach a model is developed for obtaining the expected queue length of theM(t)/G/1 queue. This type of queue occurs in different forms in transportation and traffic systems and in communications and manufacturing systems. In order to cut down the very high computational efforts required to evaluate the performance measures in such queues by exact methods, the Maximum Entropy Principle is used to approximate the expected queue length which is one of the most commonly used performance measures. A procedure is then developed for reducing the error encountered when this approximation is adopted. The results from this paper will encourage the practitioners to use the appropriate time-varying queueing models when the need arises instead of resorting to very poor approximations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01261657</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/PaulT78">
<author>Wolfgang J. Paul</author>
<author>Robert Endre Tarjan</author>
<title>Time-Space Trade-Offs in a Pebble Game.</title>
<pages>111-115</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#PaulT78</url>
<abstract>G n has n nodes and each node in G n has indegree at most 2.Each graph G n can be pebbled with c 1√n pebbles in n moves.Each graph G n can also be pebbled with c 2√n pebbles, c 2<c1, but every strategy which achieves this has at least 2 c 3√n moves.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289150</ee>
</article>
<article mdate="2008-05-21" key="journals/acta/DuanTZ08">
<author>Zhenhua Duan</author>
<author>Cong Tian</author>
<author>Li Zhang</author>
<title>A decision procedure for propositional projection temporal logic with infinite models.</title>
<pages>43-78</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>This paper investigates the satisfiability of Propositional Projection Temporal Logic (PPTL) with infinite models. A decision procedure for PPTL formulas is given. To this end, Normal Form (NF) and Labeled Normal Form Graph (LNFG) for PPTL formulas are defined, and algorithms for transforming a formula to its normal form and constructing the LNFG for the given formula are presented. Further, the finiteness of LNFGs is proved in details. Moreover, the decision procedure is extended to check the satisfiability of the formulas of Propositional Interval Temporal Logic. In addition, examples are also given to illustrate how the decision procedure works.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0062-z</ee>
<url>db/journals/acta/acta45.html#DuanTZ08</url>
</article>
<article mdate="2008-11-18" key="journals/acta/DamianiGGD08">
<author>Ferruccio Damiani</author>
<author>Elena Giachino</author>
<author>Paola Giannini</author>
<author>Sophia Drossopoulou</author>
<title>A type safe state abstraction for coordination in Java -like languages.</title>
<pages>479-536</pages>
<year>2008</year>
<volume>45</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>The state of a concurrent object, intended as some abstraction over the values of the fields of the object, usually determines its coordination behavior. Therefore, state is always in the programmer’s mind, even though implicitly. We suggest a feature for Java-like languages, which makes the state of a concurrent object explicit and supports the expression of the object’s behavior depending on the state it is currently in. Namely, an object will be in one of the states declared in its class. The state determines the presence of fields and methods. State transition statements explicitly change the state of an object, and thus change the availability of fields and methods. When a thread calls a method which is declared in the object’s class but absent from its current state, it waits, until the state of the object changes to a state which does contain that method. This directly expresses coordination. We claim that this feature makes it easier to understand and develop concurrent programs, and substantiate our claim through the discussion of some popular examples of concurrent programs written using this feature.We develop a type and effect system, which guarantees that, during execution of a method invoked on a concurrent object \({\tt o}\): (1) No attempt will be made to access fields not available in the current state of \({\tt o}\), and (2) No method invoked on a receiver (syntactically) different from \({\tt this}\) may cause the invocation of a method on \({\tt o}\). The latter guarantee helps to enforce the former and prevents a family of accidental violations of the intended coordination protocol.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-008-0079-y</ee>
<url>db/journals/acta/acta45.html#DamianiGGD08</url>
</article>
<article mdate="2011-05-16" key="journals/acta/SeidelV11">
<author>Daniel Seidel</author>
<author>Janis Voigtl&auml;nder</author>
<title>Refined typing to localize the impact of forced strictness on free theorems.</title>
<pages>191-211</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Free theorems establish interesting properties of parametrically polymorphic functions, solely from their types, and serve as a nice proof tool. For pure and lazy functional programming languages, they can be used with very few preconditions. Unfortunately, in the presence of selective strictness, as provided in languages like Haskell, their original strength is reduced. In this paper we present an approach for overcoming this weakness in specific situations. Employing a refined type system which tracks the use of enforced strict evaluation, we rule out unnecessary restrictions that otherwise emerge. Additionally, we provide (and implement) an algorithm determining all refined types for a given term.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0136-9</ee>
<url>db/journals/acta/acta48.html#SeidelV11</url>
</article>
<article mdate="2010-10-25" key="journals/acta/Cheng-ChiCheng-Chihng10">
<author>Cheng-Chi Huang</author>
<title>A note on pure codes.</title>
<pages>347-357</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>This study extends the understanding of two-element pure codes. Some characteristics of different length two-element pure codes are studied. It is shown that a language is a pure code which contains two distinct primitive words u and v with different lengths if and only if the regular expression u + v + of the two distinct words u and v is primitive.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0122-7</ee>
<url>db/journals/acta/acta47.html#Cheng-ChiCheng-Chihng10</url>
</article>
<article mdate="2014-02-14" key="journals/acta/LiYY14">
<author>Yangjia Li</author>
<author>Nengkun Yu</author>
<author>Mingsheng Ying</author>
<title>Termination of nondeterministic quantum programs.</title>
<pages>1-24</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>We define a language-independent model of nondeterministic quantum programs in which a quantum program consists of a finite set of quantum processes. These processes are represented by quantum Markov chains over the common state space, which formalize the quantum mechanical behaviors of the machine. An execution of a nondeterministic quantum program is modeled by a sequence of actions of individual processes, and at each step of an execution a process is chosen nondeterministically to perform the next action. This execution model formalize the users’ behavior of calling the processes in the classical world. Applying the model to a quantum walk as an instance of physically realizable systems, we describe an execution step by step. A characterization of reachable space and a characterization of diverging states of a nondeterministic quantum program are presented. We establish a zero-one law for termination probability of the states in the reachable space. A combination of these results leads to a necessary and sufficient condition for termination of nondeterministic quantum programs. Based on this condition, an algorithm is found for checking termination of nondeterministic quantum programs within a fixed finite-dimensional state space.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-013-0185-3</ee>
<url>db/journals/acta/acta51.html#LiYY14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/BarbutiFS97">
<author>Roberto Barbuti</author>
<author>Nicoletta De Francesco</author>
<author>Antonella Santone</author>
<title>Algebraic Computational Models of OR-Parallel Execution of Prolog.</title>
<pages>449-489</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>6</number>
<url>db/journals/acta/acta34.html#BarbutiFS97</url>
<abstract>A specification of the OR-parallel execution of Prolog programs, using CHOCS (calculus of higher order communicating systems) [24], is presented in the paper. A translation is defined from Prolog programs and goals to CHOCS processes: the execution of the CHOCS process corresponding to a goal mimics the OR-parallel execution of the original Prolog goal. In the translation, clauses and predicate definitions of a Prolog program correspond to processes. To model OR-parallelism, the processes \(P^1, \cdots , P^n\), corresponding to clauses \(C_1, \cdots , C_n\) (having the same head predicate \(p\)) start their execution concurrently, but, in order to respect the depth-first search rule, each \(P^i\) is guarded by the termination of the executions of processes \(P^j\)'s, \(j < i\). The computational model is proved correct with respect to the semantics of Prolog, as given in [4, 5]. Our model, because of its algebraic specification, can be easily used to prove properties of the parallel execution of Prolog programs. Moreover, the model exploits the maximum degree of parallelism, by giving the Prolog solutions in parallel, without any order among them. However, this model, being close to the Prolog semantics definition, contains sources of inefficiency which make it unpractical as a guide for the implementation. To overcome these problems, a new computational model is defined. This model is obtained by modifications of the basic one and thus its correctness can be easily proved. Finally, we show how to obtain models of different real implementations of OR-parallel Prolog by slight modification of the new model. The relations among all these models, in terms of parallelism degree, are studied by using the concepts of bisimulation and simulation, developed for concurrent calculi.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050094</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Back81">
<author>Ralph-Johan Back</author>
<title>Proving Total Correctness of Nondeterministic Programs in Infinitary Logic.</title>
<pages>233-249</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Back81</url>
<abstract>It is shown how the weakest precondition approach to proving total correctness of nondeterministic programs can be formalized in infinitary logic. The weakest precondition technique is extended to hierarchically structured programs by adding a new primitive statement for operational abstraction, the nondeterministic assignment statement, to the guarded commands of Dijkstra. The infinitary logic L ω1ω is shown to be strong enough to express the weakest preconditions for Dijkstra's guarded commands, but too weak for the extended guarded commands. Two possible solutions are considered: going to the essentially stronger infinitary logic L ω1ω1 and restricting the power of the nondeterministic assignment statement in a way which allows the weakest preconditions to be expressed in L ω1ω.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289263</ee>
</article>
<article mdate="2004-03-03" key="journals/acta/LeeWS04">
<author>Wen-Chiung Lee</author>
<author>Chin-Chia Wu</author>
<author>Hua-Jung Sung</author>
<title>A bi-criterion single-machine scheduling problem with learning considerations.</title>
<pages>303-315</pages>
<year>2004</year>
<volume>40</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<abstract>Conventionally, job processing times are assumed to be constant from the first job to be processed until the last job to be completed. However, recent empirical studies in several industries have verified that unit costs decline as firms produce more of a product and gain knowledge or experience. This phenomenon is known as the “learning effect.” This paper focuses on a bi-criterion single-machine scheduling problem with a learning effect. The objective is to find a sequence that minimizes a linear combination of the total completion time and the maximum tardiness. A branch-and-bound and a heuristic algorithm are proposed to search for optimal and near-optimal solutions, respectively. Computational results are also provided for the problem.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-003-0132-9</ee>
<url>db/journals/acta/acta40.html#LeeWS04</url>
</article>
<article mdate="2011-08-18" key="journals/acta/RabeS11">
<author>Markus N. Rabe</author>
<author>Sven Schewe</author>
<title>Finite optimal control for time-bounded reachability in CTMDPs and continuous-time Markov games.</title>
<pages>291-315</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>5-6</number>
<abstract>We establish the existence of optimal scheduling strategies for time-bounded reachability in continuous-time Markov decision processes, and of co-optimal strategies for continuous-time Markov games. Furthermore, we show that optimal control does not only exist, but has a surprisingly simple structure: the optimal schedulers from our proofs are deterministic and timed positional, and the bounded time can be divided into a finite number of intervals, in which the optimal strategies are positional. That is, we demonstrate the existence of finite optimal control. Finally, we show that these pleasant properties of Markov decision processes extend to the more general class of continuous-time Markov games, and that both early and late schedulers show this behaviour.</abstract>
<topic>Theory of Computation</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0140-0</ee>
<url>db/journals/acta/acta48.html#RabeS11</url>
</article>
<article mdate="2010-02-16" key="journals/acta/Do10">
<author>Tien Van Do</author>
<title>M/M/1 retrial queue with working vacations.</title>
<pages>67-75</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract>In this paper we introduce the new M/M/1 retrial queue with working vacations which is motivated by the performance analysis of a Media Access Control function in wireless systems. We give a condition for the stability of the model, which has an important impact on setting the retrial rate for such systems. We derive the closed form solution in equilibrium for the retrial M/M/1 queue with working vacations, and we also show that the conditional stochastic decomposition holds for this model as well.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0110-y</ee>
<url>db/journals/acta/acta47.html#Do10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/TomitaS95"> 
<author>Etsuji Tomita</author>
<author>Kazushi Seino</author>
<title>The Extendes Equivalence Problem for a Class of Non-Real-Time Deterministic Pushdowen Automata.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>4</number>
<year>1995</year> 
<pages>395-413</pages>
<url>db/journals/acta/acta32.html#TomitaS95</url>
<abstract>We propose a new class of non-real-time deterministic pushdown automata (dpda's), named dpda's having the weak segmental property (WSP), and show that the equivalence problem is solvable for two dpda's, one of which is in this class. The equivalence checking algorithm to prove this problem is a further extended direct branching algorithm of Tomita; and with the new skipping step combined with the type B′ replacement of Oyamaguchi, Inagaki and Honda. The algorithm is still relatively simple. The class of dpda's given above is one of the widest known subclasses of proper dpda's (introduced by Ukkonen); with the decidable extended equivalence problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178385</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/Sabelfeld78">
<author>Viktor K. Sabelfeld</author>
<title>&Auml;quivalente Transformationen f&uuml;r Flu&szlig;diagramme.</title>
<pages>127-155</pages>
<year>1978</year>
<volume>10</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta10.html#Sabelfeld78</url>
<abstract>the operational andthe logic-termal equivalence problems in the whole class of program schemes, andthe functional equivalence problem in the class of so called “through-schemes”.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289152</ee>
</article>
<article mdate="2010-12-28" key="journals/acta/FanH10">
<author>Chen-Ming Fan</author>
<author>Cheng-Chih Huang</author>
<title>A note on prefix primitive words.</title>
<pages>413-423</pages>
<year>2010</year>
<volume>47</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>This paper studies algebraic properties concerning the prefix primitive words. The p-primitive conjugates of related primitive words are considered. We characterize the d-primitive square-free words which have a non-p-primitive conjugate. We also study some algebraic properties of annihilators concerning p-primitive words.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-010-0126-3</ee>
<url>db/journals/acta/acta47.html#FanH10</url>
</article>
<article mdate="2011-01-11" key="journals/acta/FrougnySV82">
<author>Christiane Frougny</author>
<author>Jacques Sakarovitch</author>
<author>Erich Valkema</author>
<title>On the Hotz Group of a Context-Free Grammar.</title>
<pages>109-115</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#FrougnySV82</url>
<abstract>This note gives a new and algebraic construction of the Hotz group of a context-free grammar. The main result, that the Hotz group is defined by the generated language, as well as the relationships between this group and the syntactic monoid of the language are then easy consequences of this presentation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00625283</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BaierM94">
<author>Christel Baier</author>
<author>Mila E. Majster-Cederbaum</author>
<title>The Connection between an Event Structure Semantics and an Operational Semantics for TCSP.</title>
<pages>81-104</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta31.html#BaierM94</url>
<abstract>The relation between an operational interleaving semantics forTSCP based on a transition system and a compositional true concurrency semantics based on event structures is studied. In particular we extend the consistency result of Goltz and Loogan [15] forTCSP processes without recursion to the general case. Thus we obtain for everyTCSP processP that its operational meaningO(P) and the interleaving behaviourO( M∥3P∥3) which is derived from the event structureM∥3P∥3 associated withP are bisimilar.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178923</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Turski72"> 
<author>Wladyslaw M. Turski</author>
<title>A Model for Data Structures and its Applications. (Part II).</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>282-289</pages>
<url>db/journals/acta/acta1.html#Turski72</url>
<abstract>This paper is the second and final part of [6]. Some problems of irregular data structures (list structures) are analysed by means of the proposed model. Operations on data structures are introduced and discussed. The model is applied to a problem in information retrieval. Finally, some general remarks on data-structure problems are made, intended as a justification of the approach taken in this paper.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289508</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/HennesyK81">
<author>John L. Hennessy</author>
<author>Richard B. Kieburtz</author>
<title>The Formal Definition of a Real-Time Language.</title>
<pages>309-345</pages>
<year>1981</year>
<volume>16</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta16.html#HennesyK81</url>
<abstract>This paper presents the formal definition of TOMAL (Task-Oriented Microprocessor Applications Language), a programming language intended for real-time systems running on small processors. The formal definition addresses all aspects of the language. Because some modes of semantic definition seem particularly well-suited to certain aspects of a language, and not as suitable for others, the formal definition employs several complementary modes of definition.The primary definition is axiomatic and is employed to define most statements of the language. Simple, denotational (but not lattice-theoretic) semantics complement the axiomatic semantics to define type-related features, such as binding of names to types, data type coercions, and evaluation of expressions. Together, the axiomatic and denotational semantics define all features of the sequential language. An operational definition is used to define real-time execution, and to extend the axiomatic definition to account for all aspects of concurrent execution. Semantic constraints, sufficient to guarantee conformity of a program with the axiomatic definition, can be checked by analysis of a TOMAL program at compilation.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289309</ee>
</article>
<article mdate="2014-09-05" key="journals/acta/ChunhuaDY12">
<author>Chunhua Cao</author>
<author>Di Yang</author>
<author>Yin Liu</author>
<title>Disjunctive languages related to p-primitive words.</title>
<pages>437-444</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>7-8</number>
<abstract>It is known that the set of all primitive words and the set of all \(d\)-primitive words are disjunctive languages. In this paper we prove that the set of all \(p\)-primitive words is disjunctive. We also prove that the set of all primitive but not \(p\)-primitive words, the set of all balanced but not \(p\)-primitive words, and the set of all \(d\)-primitive but not \(p\)-primitive words are disjunctive languages.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0165-z</ee>
<url>db/journals/acta/acta49.html#ChunhuaDY12</url>
</article>
<article mdate="2003-11-25" key="journals/acta/FrederiksW02">
<author>Paul J. M. Frederiks</author>
<author>Theo P. van der Weide</author>
<title>Deriving and paraphrasing information grammars using object-oriented analysis models.</title>
<pages>437-488</pages>
<year>2002</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/2038007/20380437.htm</ee>
<url>db/journals/acta/acta38.html#FrederiksW02</url>
</article>
<article mdate="2011-01-11" key="journals/acta/SchnorrS72"> 
<author>Claus-Peter Schnorr</author>
<author>H. Stimm</author>
<title>Endliche Automaten und Zufallsfolgen.</title>
<journal>Acta Inf.</journal>
<volume>1</volume> 
<year>1972</year> 
<pages>345-359</pages>
<url>db/journals/acta/acta1.html#SchnorrS72</url>
<abstract>We consider the behaviour of finite automata on infinite binary sequences and study the class of random tests which can be carried out by finite automata. We give several equivalent characterizations of those infinite binary sequences which are random relative to finite automata. These characterizations are based on the concepts of selection rules, martingales and invariance properties defined by finite automata.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289514</ee>
</article>


<article mdate="2011-01-11" key="journals/acta/LucaV92">
<author>Aldo de Luca</author>
<author>Stefano Varricchio</author>
<title>On Finitely Recognizable Semigroups.</title>
<pages>483-498</pages>
<year>1992</year>
<volume>29</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta29.html#LucaV92</url>
<abstract>We analyze some algebraic properties of semigroups whose finite subsets are recognizable (finitely recognizable semigroups). We show that these semigroups are stable and their subgroups are of finite order. As a consequence of this we prove an interesting decomposition theorem for finitely recognizable semigroups which are finitely generated. Moreover we give more equivalent characterizations of these semigroups under the additional hypothesis that they have aJ-depth function; we show, in particular, that this class of semigroups coincides with the class of finiteJ-above semigroups. Finally we prove that finitely recognizable semigroups which are finitely presented in a finitely based variety have a solvable word problem.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01193579</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AutebertBBG84">
<author>Jean-Michel Autebert</author>
<author>Joffroy Beauquier</author>
<author>Luc Boasson</author>
<author>Fran&ccedil;oise Gire</author>
<title>Bicentres de langages alg&eacute;briques.</title>
<pages>209-227</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#AutebertBBG84</url>
<abstract>Les notions de bicentre et bicentre strict d'un langage, définies par A. De Luca, A. Restivo et S. Salemi généralisent la notion de centre d'un langage définie par M. Nivat. L'objet du présent papier est de répondre á la question suivante lorsque ℒ désigne la famille des langages algébriques ou l'une de ses sous-familles classiques:Si L appartient à ℒ, le bicentre de L (respectivement le bicentre strict de L) appartient-il à ℒ?Le principal résultat est une réponse positive à cette question lorsqu'il s'agit de la notion de bicentre et que ℒ est un full-AFL uniforme de langages algébriques.The notions of bicenter and strict bicenter of a language have been defined by A. De Luca, A. Restivo and S. Salemi and are a generalisation of the notion of center of a language, defined by M, Nivat. This paper deals with the following question, when ℒ is the family of context-free languages or one of its classical subfamilies:when L is in ℒ, is the bicenter (resp. the strict bicenter) of L also in ℒ?Concerning the notion of bicenter, the main result of the paper is a positive answer when ℒ is a uniform full-AFL of context-free languages.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289241</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Barstow80">
<author>David R. Barstow</author>
<title>Remarks on "A Synthesis of Several Sorting Algorithms" by John Darlington.</title>
<pages>225-227</pages>
<year>1980</year>
<volume>13</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta13.html#Barstow80</url>
<abstract>In his paper “A Synthesis of Several Sorting Algorithms,” John Darlington presents syntheses for six different sorting algorithms, together with a family tree of sorting algorithms, and mentions a symmetry between Quick Sort, Selection Sort, Merge Sort, and Insertion Sort. In our own attempts to codify programming knowledge, we have developed a slightly different family tree which shows similar symmetries, and which also shows that Bubble Sort and Sinking Sort can be viewed as in-place versions of Selection Sort and Insertion Sort, thus adding another symmetry to those noted by Darlington.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288643</ee>
</article>
<article mdate="2007-09-11" key="journals/acta/VincentLM07">
<author>Millist W. Vincent</author>
<author>Jixue Liu</author>
<author>Mukesh K. Mohania</author>
<title>On the equivalence between FDs in XML and FDs in relations.</title>
<pages>207-247</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract>With the growing use of the eXtensible Markup Language (XML) in database technology as a format for the permanent storage of data, the topic functional dependencies in XML (XFDs) has assumed increased importance because of its central role in database design. Recently, two different approaches have been proposed for defining an XFD. The first uses the concept of a ‘tree tuple’, whereas the second uses the concept of a ‘closest node’. In general, the two approaches are not comparable, but are comparable when a Document Type Definition is present and there is no missing information in the XML document. The first contribution of this article shows that when the two XFD definitions are comparable, the definitions are equivalent, and so there is essentially a common definition of an XFD in complete XML documents. The second contribution is to provide justification for the definition of a ‘closest node’ XFD. We show that if a complete flat relation is mapped to an XML document by an arbitrary sequence of nest operations, the XML document satisfies a ‘closest node’ XFD if and only if the relation satisfies the corresponding functional dependency. The class of XML documents generated in this fashion is a subset of the class of XML documents for which the two definitions of XFDs coincide. Hence ‘tree tuple’ and ‘closest node’ XFDs both capture the semantics of FDs when a complete relation is mapped to an XML document via arbitrary nesting.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0048-x</ee>
<url>db/journals/acta/acta44.html#VincentLM07</url>
</article>
<article mdate="2005-01-25" key="journals/acta/KimYL04">
<author>SungSuk Kim</author>
<author>Sun Ok Yang</author>
<author>SangKeun Lee</author>
<title>Maintaining mobile transactional consistency in hybrid broadcast environments.</title>
<pages>65-81</pages>
<year>2004</year>
<volume>41</volume>
<journal>Acta Inf.</journal>
<number>2-3</number>
<abstract>Recently there have been attempts in several research areas at efficiently utilizing the resources of mobile computers. Considering the properties in mobile computing environments, push-based data dissemination systems have lately attracted considerable attention. However, skewed access patterns among mobile clients makes response time worse, and they prefer to send data requests to the server explicitly through an uplink channel. A broadcast supporting an uplink channel is called a hybrid broadcast. In this paper, we devise new transaction processing algorithms for hybrid broadcasts. It is assumed that data objects that the server maintains are divided into Push_Data for periodic broadcasting and Pull_Data for on-demand service. That is, clients have to explicitly request data objects in Pull_Data. Maintaining transactional consistency in this environment without much additional cost is our main concern. Finally, we evaluate performance behavior through simulation study.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/s00236-003-0142-7</ee>
<url>db/journals/acta/acta41.html#KimYL04</url>
</article>
<article mdate="2011-01-11" key="journals/acta/GinsburgW78">
<author>Seymour Ginsburg</author>
<author>Derick Wood</author>
<title>Precedence Relations in Grammar Forms.</title>
<pages>79-88</pages>
<year>1978</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#GinsburgW78</url>
<abstract>A study is made of conflict freeness in grammar forms. The results are as follows. Characterizations on a form are presented in order for all its interpretations of particular kinds to be conflict free. Characterizations on a form are then given in order for it to have a strongly equivalent (of particular kinds) conflict-free form. Finally, it is shown that each grammar form has a (weakly) equivalent conflict-free form.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264602</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Berry85">
<author>Daniel M. Berry</author>
<title>A Denotational Semantics for Shared-Memory Parallelism and Nondeterminism.</title>
<pages>599-627</pages>
<year>1985</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#Berry85</url>
<abstract>It is first shown how to construct a continuation from a deterministic Vienna Definition Language control tree. This construction is then applied to nondeterministic control trees. The result is a denotational but not quite continuation semantics for arbitrary shared-memory nondeterminism and parallelism. The implications of this result are discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289713</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/BovetC91">
<author>Daniel P. Bovet</author>
<author>Pierluigi Crescenzi</author>
<title>Minimum-Delay Schedules in Layered Networks.</title>
<pages>453-461</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta28.html#BovetC91</url>
<abstract>In this paper, we consider the following problem: given a layered network including a set of messages, each of which must be transmitted from a source to a sink node, what is the sequence of moves from one node to another which minimizes the total completion time? We first show that the general problem is NP-complete for both fixed and variable path routing (thus the scheduling problem for more realistic networks with cycles must be considered computationally intractable). We then consider several restrictions which admit polynomia time algorithms.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178583</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/JonesM94">
<author>Cliff B. Jones</author>
<author>C. A. Middelburg</author>
<title>A Typed Logic of Partial Functions Reconstructed Classically.</title>
<pages>399-430</pages>
<year>1994</year>
<volume>31</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta31.html#JonesM94</url>
<abstract>This paper gives a comprehensive description of a typed version of the logic known as LPF. This logic is basic to formal specification and verified design in the software development method VDM. If appropriately extended to deal with recursively defined functions, the data types used in VDM, etc., it gives the VDM notation and its associated rules of reasoning. The paper provides an overview of the needed extensions and examines some of them in detail. It is shown how this nonclassical logic-and the extensions-can be reconstructed classically by embeddings into classical infinitary logic.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178666</ee>
</article>
<article mdate="2011-04-15" key="journals/acta/AravindH11">
<author>Alex A. Aravind</author>
<author>Wim H. Hesselink</author>
<title>Nonatomic dual bakery algorithm with bounded tokens.</title>
<pages>67-96</pages>
<year>2011</year>
<volume>48</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>A simple mutual exclusion algorithm is presented that only uses nonatomic shared variables of bounded size, and that satisfies bounded overtaking. When the shared variables behave atomically, it has the first-come-first-served property (FCFS). Nonatomic access makes information vulnerable. The effects of this can be mitigated by minimizing the information and by spreading it over more variables. The design approach adopted here begins with such mitigating efforts. These resulted in an algorithm with a proof of correctness, first for atomic variables. This proof is then used as a blueprint for the simultaneous development of the algorithm for nonatomic variables and its proof. Mutual exclusion is proved by means of invariants. Bounded overtaking and liveness under weak fairness are proved with invariants and variant functions. Liveness under weak fairness is formalized and proved in a set-theoretic version of temporal logic. All these assertions are verified with the proof assistant PVS. We heavily rely on the possibility offered by a proof assistant like PVS to reuse proofs developed for one context in a different context.</abstract>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-011-0132-0</ee>
<url>db/journals/acta/acta48.html#AravindH11</url>
</article>
<article mdate="2011-01-11" key="journals/acta/LeveneL97">
<author>Mark Levene</author>
<author>George Loizou</author>
<title>The Additivity Problem for Functional Dependencies in Incomplete Relations.</title>
<pages>135-149</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta34.html#LeveneL97</url>
<abstract>Incomplete relations are relations which contain null values, whose meaning is “value is at present unknown”. A functional dependency (FD) is weakly satisfied in an incomplete relation if there exists a possible world of this relation in which the FD is satisfied in the standard way. Additivity is the property of equivalence of weak satisfaction of a set of FDs, say F, in an incomplete relation with the individual weak satisfaction of each member of F in the said relation. It is well known that satisfaction of FDs is not additive. The problem that arises is: under what conditions is weak satisfaction of FDs additive. We solve this problem by introducing a syntactic subclass of FDs, called monodependent FDs, which informally means that for each attribute, say A, there is a unique FD that functionally determines A, and in addition only trivial cycles involving A arise between any two FDs one of which functionally determines A. We show that weak satisfaction of FDs is additive if and only if the set F of FDs is monodependent and that monodependence can be checked in time polynomial in the size of F.</abstract>
<ee>http://dx.doi.org/10.1007/s002360050076</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Alblas87">
<author>Henk Alblas</author>
<title>One-Pass Transformations of Attributed Program Trees.</title>
<pages>299-352</pages>
<year>1987</year>
<volume>24</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<url>db/journals/acta/acta24.html#Alblas87</url>
<abstract>The classical attribute grammar framework can be extended by allowing the specification of tree transformation rules. A tree transformation rule consists of an input template, an output template, enabling conditions which are predicates on attribute instances of the input template, and re-evaluation rules which define the values of attribute instances of the output template. A tree transformation may invalidate attribute instances which are needed for additional transformations.In this paper we investigate whether consecutive tree transformations and attribute re-evaluations are safely possible during a single pass over the derivation tree. This check is made at compiler generation time rather than at compilation time.A graph theoretic characterization of attribute dependencies is given, showing in which cases the recomputation of attribute instances can be done in parallel with tree transformations.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00265992</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Meduna96">
<author>Alexander Meduna</author>
<title>Syntactic Complexity of Context-Free Grammars Over Word Monoids.</title>
<pages>457-462</pages>
<year>1996</year>
<volume>33</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<url>db/journals/acta/acta33.html#Meduna96</url>
<abstract>The syntactic complexity of context-free grammars defined over word monoids is investigated. It is demonstrated that every recursively enumerable language can be defined by a ten-nonterminal context-free grammar over a word monoid generated by an alphabet and six words of length two. Open problems are formulated.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s002360050052</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Bruin81">
<author>Arie de Bruin</author>
<title>Goto Statements: Semantics and Deduction Systems.</title>
<pages>385-424</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#Bruin81</url>
<abstract>A simple language containing goto statements is presented, together with a denotational and operational semantic for it. Equivalence of these semantical descriptions is proven.Furthermore, soundness and completeness of a Hoare-like proof system for the language is shown. This is done in two steps. Firstly, a proof system is given and validity is defined using (a variant of) direct semantics. In this case soundness and completeness proofs are relatively easy. After that, a proof system is given which is more in the style of the one by Clint and Hoare [8], and validity in this system is defined using continuation semantics. This validity definition is then related to validity in the first system and, using this correspondence, soundness and completeness for the second system is proven.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264536</ee>
</article>
<article mdate="2015-06-08" key="journals/acta/GlabbeekGO15a">
<author>Rob J. van Glabbeek</author>
<author>Ursula Goltz</author>
<author>Ernst-R&uuml;diger Olderog</author>
<title>Special issue on "Combining Compositionality and Concurrency": part 2.</title>
<pages>303-304</pages>
<year>2015</year>
<volume>52</volume>
<journal>Acta Inf.</journal>
<number>4-5</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-015-0240-3</ee>
<url>db/journals/acta/acta52.html#GlabbeekGO15a</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Staphylopatis82">
<author>A. Staphylopatis</author>
<title>Performance Considerations in the Parallel Execution of Numerical Algorithms on two Processors.</title>
<pages>311-325</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Staphylopatis82</url>
<abstract>Loosely coupled multiprocessor systems seem to offer an interesting alternative to the solution of large numerical problems. It is in the context of such an investigation that we treat here a special parallel-processing case concerning the solution of a numerical problem on two independent processors including simultaneous input-output operations. We present a short discussion of the underlying numerical algorithm, a modelling approach to the parallel computing system and a comparison of the theoretically obtained results with simulation and experimental results. The experimental setting is the XANTHOS multi-microprocessor system implemented at the Laboratoire de Recherche en Informatique, Université de Paris-Sud.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264356</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ColombDJ01">
<author>Robert M. Colomb</author>
<author>Christopher N. G. Dampney</author>
<author>Michael Johnson</author>
<title>Category-theoretic fibration as an abstraction mechanism in information systems.</title>
<pages>1-44</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038001/10380001.htm</ee>
<url>db/journals/acta/acta38.html#ColombDJ01</url>
</article>
<article mdate="2013-11-28" key="journals/acta/PaulS74"> 
<author>Wolfgang J. Paul</author>
<author>Hans-J&ouml;rg Sto&szlig;</author>
<title>Zur Komplexit&auml;t von Sortierproblemen.</title>
<journal>Acta Inf.</journal>
<volume>3</volume> 
<year>1974</year> 
<pages>217-225</pages>
<url>db/journals/acta/acta3.html#PaulS74</url>
<abstract>We consider a problem of regrouping data collected in blocks of up to r elements by steps involving the data of not more than k blocks each.The problem consists in giving a lower estimate for the minimum number of steps involved. The estimates are derived from the entropies of certain probability distributions pertinent to the given collections of blocks.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00288635</ee>
</article>

<article mdate="2015-01-08" key="journals/acta/EhrenfeuchtR89a">
<author>Andrzej Ehrenfeucht</author>
<author>Grzegorz Rozenberg</author>
<title>Partial (Set) 2-Structures. Part II: State Spaces of Concurrent Systems.</title>
<pages>343-368</pages>
<year>1990</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta27.html#EhrenfeuchtR89a</url>
<abstract>We continue the investigation of labeled partial (set) 2-structures initiated in [5] and in particular we explore applications to the theory of net-based concurrent systems. The problem of characterizing state spaces of basic classes of Petri nets, and the problem of synthesizing state spaces of basic classes of Petri nets from their “abstract” descriptions in the form of directed edge-labeled graphs are investigated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264612</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/ItoMM01">
<author>Masami Ito</author>
<author>Carlos Mart&iacute;n-Vide</author>
<author>Victor Mitrana</author>
<title>Group weighted finite transducers.</title>
<pages>117-129</pages>
<year>2001</year>
<volume>38</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/1038002/10380117.htm</ee>
<url>db/journals/acta/acta38.html#ItoMM01</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RosenbergS77"> 
<author>Arnold L. Rosenberg</author>
<author>Larry J. Stockmeyer</author>
<title>Storage Schemes for Boundedly Extendible Arrays.</title>
<journal>Acta Inf.</journal>
<volume>7</volume> 
<year>1977</year> 
<pages>289-303</pages>
<url>db/journals/acta/acta7.html#RosenbergS77</url>
<abstract>The high costs of extendibility in array realizations can be reduced dramatically by placing a bound on how big the arrays of interest will grow. Whereas extendible array realizations require order of p · log p storage locations to store two-dimensional arrays having p or fewer positions, boundedly extendible array realizations (with a bound of p) can store these same arrays in precisely p locations. Moreover, boundedly extendible realizations can be designed to afford one additive traversal of both the rows and columns of the stored arrays, albeit at the cost of very inefficient storage utilization (order of p 3/2 locations are needed to store arrays having p or fewer positions); extendible array realizations cannot yield such bidirectional additive traversal, irrespective of the price one is willing to pay. Moreover, if one can specify that the smallest array of interest is of shape h × w, then the p 3/2 cost of storage utilization can be improved to roughly p · (p/hw)1/2 but no further.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00290338</ee>
</article>

<article mdate="2004-03-03" key="journals/acta/Srba03">
<author>Jir&iacute; Srba</author>
<title>Strong bisimilarity of simple process algebras: complexity lower bounds.</title>
<pages>469-499</pages>
<year>2003</year>
<volume>39</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract></abstract>
<ee>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0001-5903&amp;volume=39&amp;issue=6&amp;spage=469</ee>
<url>db/journals/acta/acta39.html#Srba03</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Rosen74"> 
<author>Barry K. Rosen</author>
<title>Deriving Graphs from Graphs by Applying a Production.</title>
<journal>Acta Inf.</journal>
<volume>4</volume> 
<year>1974</year> 
<pages>337-357</pages>
<url>db/journals/acta/acta4.html#Rosen74</url>
<abstract>Grammar-like systems for manipulating directed graphs (together with information associated with individual nodes and arcs) have many uses in computing but have not been studied as deeply, elegantly, and fruitfully as classical string grammars or even tree grammars. Satisfactory definitions of the most basic concepts have been elusive. When can the left side of a production be said to occur in a graph ? In replacing an occurrence of the left side of a production by the right side, how is the right side to be connected with the rest of the graph ?Ehrig, Pfender, and Schneider recently proposed general definitions adequate for a variety of applications and established some fundamental properties of graph grammars. This paper generalizes and sharpens their work so as to cover more applications. The exposition is mathematically rigorous but departs from that of Ehrig, Pfender, and Schneider's paper in ways that will perhaps render the material more accessible to readers who are not algebraists.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289616</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/WuWW86">
<author>Ying-Fung Wu</author>
<author>Peter Widmayer</author>
<author>C. K. Wong</author>
<title>A Faster Approximation Algorithm for the Steiner Problem in Graphs.</title>
<pages>223-229</pages>
<year>1986</year>
<volume>23</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<url>db/journals/acta/acta23.html#WuWW86</url>
<abstract>We present an algorithm for finding a Steiner tree for a connected, undirected distance graph with a specified subset S of the set of vertices V. The set V-S is traditionally denoted as Steiner vertices. The total distance on all edges of this Steiner tree is at most 2(1−1/l) times that of a Steiner minimal tree, where l is the minimum number of leaves in any Steiner minimal tree for the given graph. The algorithm runs in O(¦E¦log¦V¦) time in the worst case, where E is the set of all edges and V the set of all vertices in the graph. It improves dramatically on the best previously known bound of O(¦S¦¦V¦2), unless the graph is very dense and most vertices are Steiner vertices. The essence of our algorithm is to find a generalized minimum spanning tree of a graph in one coherent phase as opposed to the previous multiple steps approach.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289500</ee>
</article>
<article mdate="2012-03-08" key="journals/acta/StahlV12">
<author>Christian Stahl</author>
<author>Walter Vogler</author>
<title>A trace-based service semantics guaranteeing deadlock freedom.</title>
<pages>69-103</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>2</number>
<abstract>We revise the accordance preorder in the context of deadlock freedom for asynchronously communicating services. Accordance considers all controllers of a service—that is, all environments that can interact with the service without deadlocking. A service Impl accords with a service Spec if every controller of Spec is also a controller of Impl. We model finite-state and infinite-state services as Petri nets and formalize the semantics of such models with a traditional concurrency semantics, a trace-based semantics. As benefits, we get an easier characterization of the accordance preorder, prove that it is a fully abstract precongruence, and present an algorithm to decide refinement of two finite-state services. Previously, operating guidelines have been introduced to study the behavior of finite-state services; they characterize all controllers of a given service and can be used to decide accordance. An operating guideline is a finite automaton annotated with Boolean formulae that describes the semantics of a service from the perspective of its controllers rather than from the perspective of the service. We show that our trace-based semantics can be translated back and forth into operating guidelines, thereby providing a more conceptual understanding of operating guidelines.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0151-5</ee>
<url>db/journals/acta/acta49.html#StahlV12</url>
</article>
<article mdate="2011-01-11" key="journals/acta/RuzickaP89">
<author>Peter Ruzicka</author>
<author>Igor Pr&iacute;vara</author>
<title>An Almost Linear Robinson Unification Algorithm.</title>
<pages>61-71</pages>
<year>1989</year>
<volume>27</volume>
<journal>Acta Inf.</journal>
<number>1</number>
<url>db/journals/acta/acta27.html#RuzickaP89</url>
<abstract>Further asymptotical improvement of original Robinson's unification idea is presented. By postponing the so-called occur-check in Corbin and Bidoit's quadratic rehabilitation of the Robinson algorithm at the end of unification an almost linear unification algorithm is obtained. In the worst case, the resulting algorithm has the time complexity O(p · A(p)), where p is the size of input terms and A is the inverse to the Ackermann function. Moreover, the practical experiments are summarized comparing Corbin and Bidoit's quadratic algorithm with the resulting almost linear unification algorithm based on Robinson's principle.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263501</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/HulsmannS91">
<author>Klaus H&uuml;lsmann</author>
<author>Gunter Saake</author>
<title>Theoretical Foundations of Handling Large Substitution Sets in Temporal Integrity Monitoring.</title>
<pages>365-407</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>4</number>
<url>db/journals/acta/acta28.html#HulsmannS91</url>
<abstract>Temporal integrity constraints describe long-term data dependencies in databases to be satisfied by each correct database evolution. They can be formulated in a temporal logic. For a runtime monitoring of temporal integrity the problem arises to handle the historical information necessary to monitor the long-term dependencies. This paper extends the already known techniques for minimizing the stored information for a single substitution of the free constraint variables using transition graph construction. Our extension allows to decrease also the amount of handled substitutions for constraint monitoring. For this purpose, the notion of substitution descriptions is formally introduced allowing to monitor simultaneously whole substitution sets. The notions of formula validity and of stepwise monitoring potential validity of temporal constraints are redefined for descriptions. Based on these notions an algorithm for monitoring temporal integrity by handling descriptions is presented.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01893887</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Winklmann82">
<author>Karl Winklmann</author>
<title>On the Complexity of Some Problems Concerning the Use of Procedures I.</title>
<pages>299-318</pages>
<year>1982</year>
<volume>18</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta18.html#Winklmann82</url>
<abstract>We consider programming languages which allow procedures to be declared dynamically and to be passed as parameters. The influence of these two features on the decidability of “formal parameter correctness,” “formal recursivity,” and other properties relevant for debugging and optimization has been studied in [5–12]. In this paper we study the feasibility of such decision procedures in those cases where decidability has been proven. Thus this paper presents a complexity-theoretic refinement of some of the recursion-theoretic work from [5–12]. It is divided into two parts.Detecting the presence of “formally recursive” procedures in a program is an NP-complete problem (Theorem 1).Deciding whether or not a program has the “formal most-recentproperty” is a P-space-complete problem (Theorem 2).In part II [15] we will analyze the complexity of such problems in restricted classes of programs.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263196</ee>
</article>
<article mdate="2006-05-10" key="journals/acta/Levi06">
<author>Francesca Levi</author>
<title>A typed encoding of boxed into safe ambients.</title>
<pages>429-500</pages>
<year>2006</year>
<volume>42</volume>
<journal>Acta Inf.</journal>
<number>6-7</number>
<abstract>We present: (i) an encoding of Boxed Ambients into a variant of Safe Ambients; and (ii) a new type system for multi-level security of Safe Ambients in the style of Cardelli et al. (Information and Computation 177(2), 160–194 (2002)) and Dezani-Ciancaglini and Salvo (Security types for mobile safe ambients. In: Proceedings of ASIAN '00, LNCS 1961, pp. 215–236. Springer Verlag (2000)). Then, we show that the types, when applied to the encoded BA proceses, permits to accurately verify Mandatory Access Control policies of the source processes.</abstract>
<ee>http://dx.doi.org/10.1007/s00236-005-0002-8</ee>
<url>db/journals/acta/acta42.html#Levi06</url>
</article>
<article mdate="2009-09-28" key="journals/acta/CiobanuR09">
<author>Gabriel Ciobanu</author>
<author>Sergiu Rudeanu</author>
<title>Final and sequential behaviours of M-automata.</title>
<pages>361-374</pages>
<year>2009</year>
<volume>46</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>The present paper presents axiomatic characterizations for the final and sequential behaviours of Mealy and Moore automata. These abstract behaviours are described by isomorphic categories. Another model for them consists of the final and sequential behaviours of M-automata, a device which is introduced here as a new generalization of both Mealy and Moore automata. The category of M-automata decomposes into a category M ℓ isomorphic to the category of Mealy automata, and a category Mr whose objects can be viewed as being both Mealy and Moore automata. The category Mr is the pullback of the categories Mealy and Moore over the category S of semiautomata.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-009-0098-3</ee>
<url>db/journals/acta/acta46.html#CiobanuR09</url>
</article>
<article mdate="2003-11-25" key="journals/acta/BurnetasSA97">
<author>Apostolos Burnetas</author>
<author>Daniel Solow</author>
<author>Rishi Agarwal</author>
<title>An Analysis and Implementation of an Efficient In-Place Bucket Sort.</title>
<pages>687-700</pages>
<year>1997</year>
<volume>34</volume>
<journal>Acta Inf.</journal>
<number>9</number>
<url>db/journals/acta/acta34.html#BurnetasSA97</url>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/7034009/70340687.htm</ee>
</article>
<article mdate="2014-05-14" key="journals/acta/PeledS14">
<author>Doron Peled</author>
<author>Sven Schewe</author>
<title>Editorial: special issue on synthesis.</title>
<pages>127-128</pages>
<year>2014</year>
<volume>51</volume>
<journal>Acta Inf.</journal>
<number>3-4</number>
<abstract></abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/s00236-014-0198-6</ee>
<url>db/journals/acta/acta51.html#PeledS14</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Jones79">
<author>Cliff B. Jones</author>
<title>Constructing a Theory of a Data Structure as an Aid to Program Development.</title>
<pages>119-137</pages>
<year>1979</year>
<volume>11</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta11.html#Jones79</url>
<abstract>This paper illustrates an extension to the method of developing programs via abstract data types. In order to make the proofs shorter and more intuitive a collection of lemmas (theory) is constructed for the main data types (trees). The problem used as an example is the recording of equivalence relations, one of the programs given is based on the Fischer-Galler algorithm.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264020</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CantorK91">
<author>David G. Cantor</author>
<author>Erich Kaltofen</author>
<title>On Fast Multiplication of Polynomials over Arbitrary Algebras.</title>
<pages>693-701</pages>
<year>1991</year>
<volume>28</volume>
<journal>Acta Inf.</journal>
<number>7</number>
<url>db/journals/acta/acta28.html#CantorK91</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01178683</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/NeuholdW76">
<author>Erich J. Neuhold</author>
<author>T. Weller</author>
<title>Specification and Proving of Command Programs.</title>
<pages>15-40</pages>
<year>1976</year>
<volume>6</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta6.html#NeuholdW76</url>
<abstract>In this paper a method is described by which command languages can be specified in a precise and comprehensive way and which allows the correctness of command programs to be proven automatically. The described technique is based on an abstract command processor (ACP) which was developed both from principles of abstract interpreters and of axiomatic definitions.A formal description of a sample command language (SCL) is given by identifying in an axiomatic manner the set of ACP state transformations arising during the execution of the commands and by defining interpretatively which of these transformations are chosen in a given context. Using this definition the correctness of a command program can be proven in a nonheuristic manner. The technique is demonstrated on a SCL example.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00263741</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Eiter95"> 
<author>Thomas Eiter</author>
<title>Generating Boolean mu-Expressions.</title>
<journal>Acta Inf.</journal>
<volume>32</volume> 
<number>2</number>
<year>1995</year> 
<pages>171-187</pages>
<url>db/journals/acta/acta32.html#Eiter95</url>
<abstract>In this paper, we consider the class of Boolean μ-functions, which are the Boolean functions definable by μ-expressions (Boolean expressions in which no variable occurs more than once). We present an algorithm which transforms a Boolean formulaE into an equivalent μ-expression-if possible-in time linear in ‖E‖ times\(2^{n_m } \), where ‖E‖ is the size ofE andn m is the number of variables that occur more than once inE. As an application, we obtain a polynomial time algorithm for Mundici's problem of recognizing μ-functions fromk-formulas [17]. Furthermore, we show that recognizing Boolean μ-functions is co-NP-complete for functions essentially dependent on all variables and we give a bound close to co-NP for the general case.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF01177746</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/MooreR81">
<author>Daniel J. Moore</author>
<author>Bruce Russell</author>
<title>Axiomatic Data Type Specifications: A First Order Theory of Linear Lists.</title>
<pages>193-207</pages>
<year>1981</year>
<volume>15</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta15.html#MooreR81</url>
<abstract>A formal first order theory is given as a specification of the data type of linear lists. Various aspects and properties of the theory are explored, such as consistency, completeness and independence. In addition, implementation issues and their relation to the formal theory are also discussed.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00289260</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/BidoitH98">
<author>Michel Bidoit</author>
<author>Rolf Hennicker</author>
<title>Modular Correctness Proofs of Behavioural Implementations.</title>
<pages>951-1005</pages>
<year>1998</year>
<volume>35</volume>
<journal>Acta Inf.</journal>
<number>11</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/8035011/80350951.htm</ee>
<url>db/journals/acta/acta35.html#BidoitH98</url>
</article>
<article mdate="2003-11-25" key="journals/acta/HanI99">
<author>Yijie Han</author>
<author>Yoshihide Igarashi</author>
<title>Parallel PROFIT/COST Algorithms Through Fast Derandomization.</title>
<pages>215-232</pages>
<year>1999</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/9036003/90360215.htm</ee>
<url>db/journals/acta/acta36.html#HanI99</url>
</article>
<article mdate="2011-01-11" key="journals/acta/DeganoNM88">
<author>Pierpaolo Degano</author>
<author>Rocco De Nicola</author>
<author>Ugo Montanari</author>
<title>A Distributed Operational Semantics for CCS Based on Condition/Event Systems.</title>
<pages>59-91</pages>
<year>1988</year>
<volume>26</volume>
<journal>Acta Inf.</journal>
<number>1/2</number>
<url>db/journals/acta/acta26.html#DeganoNM88</url>
<abstract>A new set of inference rules for the guarded version of Milner’s Calculus of Communicating Systems is proposed. They not only describe the actions agents may perform when in a given state, but also say which parts of the agents move when the global state changes. From the transition relation a particular Petri Net, namely a Condition/Event system called ΣCCS, is immediately derived. Our construction gives a semantics which is consistent with the interleaving semantics of CCS and exhibits full parallelism. The proof consists of relating the case graph of ΣCCS with the original and with the multiset (step) transition systems of the calculus.</abstract>
<topic>Logics and Meanings of Programs</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<ee>http://dx.doi.org/10.1007/BF02915446</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/CoffmanL84">
<author>Edward G. Coffman Jr.</author>
<author>Michael A. Langston</author>
<title>A Performance Guarantee for the Greedy Set-Partitioning Algorithm.</title>
<pages>409-415</pages>
<year>1984</year>
<volume>21</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta21.html#CoffmanL84</url>
<abstract></abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264618</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/AsveldE77"> 
<author>Peter R. J. Asveld</author>
<author>Joost Engelfriet</author>
<title>Iterated Deterministic Substitution.</title>
<journal>Acta Inf.</journal>
<volume>8</volume> 
<year>1977</year> 
<pages>285-302</pages>
<url>db/journals/acta/acta8.html#AsveldE77</url>
<abstract>Deterministic substitution of languages means substituting the same word (from a given language) for all occurrences of a symbol. For an arbitrary family K of languages the notion of deterministic K-iteration grammar is introduced, which is essentially the iteration of a finite number of deterministic substitutions of languages from K. The families of languages generated by these grammars are investigated.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264471</ee>
</article>

<article mdate="2011-01-11" key="journals/acta/HoribeN79">
<author>Yasuichi Horibe</author>
<author>Tibor O. H. Nemetz</author>
<title>On the Max-Entropy Rule for a Binary Search Tree.</title>
<pages>63-72</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#HoribeN79</url>
<abstract>A modified max-entropy rule is proposed for constructing nearly optimum binary search tree in the case of ordered keys with given probabilities. The average cost of the trees obtained by this rule is shown to be bounded by the entropy of the probability distribution plus a constant not larger than one. An algorithm for implementing this rule is then suggested and its complexity is investigated in a probabilistic setting.</abstract>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/BF00264017</ee>
</article>
<article mdate="2011-01-11" key="journals/acta/Wilhelm79">
<author>Reinhard Wilhelm</author>
<title>Computation and Use of Data Flow Information in Optimizing Compilers.</title>
<pages>209-225</pages>
<year>1979</year>
<volume>12</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta12.html#Wilhelm79</url>
<abstract>Global data flow analysis is embedded into an optimizing compiler environment. It is shown for a small language, how global data flow information can be collected, used in determining the applicability of optimizing program transformations, and updated after transformations have made the flow information invalid. The algorithms presented, global data flow analysis, constant propagation, and invariant code motion, are described as guided by the abstract syntax tree of a program. The description is such as to allow the automatic generation of an optimizing compiler.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00264579</ee>
</article>
<article mdate="2003-11-25" key="journals/acta/MahmoudFJR00">
<author>Hosam M. Mahmoud</author>
<author>Philippe Flajolet</author>
<author>Philippe Jacquet</author>
<author>Mireille R&eacute;gnier</author>
<title>Analytic Variations on Bucket Selection and Sorting.</title>
<pages>735-760</pages>
<year>2000</year>
<volume>36</volume>
<journal>Acta Inf.</journal>
<number>9/10</number>
<abstract><ee>http://link.springer.de/link/service/journals/00236/bibs/0036009/00360735.htm</ee>
<url>db/journals/acta/acta36.html#MahmoudFJR00</url>
</article>
<article mdate="2011-01-11" key="journals/acta/Huynh82">
<author>Thiet-Dung Huynh</author>
<title>Remarks on the Complexity of an Invariant of Context-Free Grammars.</title>
<pages>89-99</pages>
<year>1982</year>
<volume>17</volume>
<journal>Acta Inf.</journal>
<url>db/journals/acta/acta17.html#Huynh82</url>
<abstract>In this paper the complexity of some decision problems for finitely presented abelian groups defined by context-free grammars is investigated. We shall prove that the membership problem and the isomorphism problem are recognizable in deterministic polynomial-time.</abstract>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Theory of Computation</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Computational Mathematics and Numerical Analysis</topic>
<ee>http://dx.doi.org/10.1007/BF00262978</ee>
</article>
<article mdate="2007-09-11" key="journals/acta/BerniniGPP07">
<author>Antonio Bernini</author>
<author>Elisabetta Grazzini</author>
<author>Elisa Pergola</author>
<author>Renzo Pinzani</author>
<title>A general exhaustive generation algorithm for Gray structures.</title>
<pages>361-376</pages>
<year>2007</year>
<volume>44</volume>
<journal>Acta Inf.</journal>
<number>5</number>
<abstract>Starting from a succession rule for Catalan numbers, we define a procedure for encoding and listing the objects enumerated by these numbers such that two consecutive codes of the list differ only by one digit. The Gray code we obtain can be generalized to all the succession rules with the stability property: each label (k) has in its productions two labels c 1 and c 2, always in the same position, regardless of k. Because of this link, we define Gray structures as the sets of those combinatorial objects whose construction can be encoded by a succession rule with the stability property. This property is a characteristic that can be found among various succession rules, such as the finite, factorial or transcendental ones. We also indicate an algorithm which is a very slight modification of Walsh’s one, working in O(1) worst-case time per word for generating Gray codes.</abstract>
<topic>Computational Mathematics and Numerical Analysis</topic>
<topic>Information Systems and Communication Service</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<topic>Logics and Meanings of Programs</topic>
<ee>http://dx.doi.org/10.1007/s00236-007-0053-0</ee>
<url>db/journals/acta/acta44.html#BerniniGPP07</url>
</article>
<article mdate="2012-04-26" key="journals/acta/WangYPL12">
<author>Junhu Wang</author>
<author>Jeffrey Xu Yu</author>
<author>Chaoyi Pang</author>
<author>Chengfei Liu</author>
<title>Least common container of tree pattern queries and its applications.</title>
<pages>173-202</pages>
<year>2012</year>
<volume>49</volume>
<journal>Acta Inf.</journal>
<number>3</number>
<abstract>Tree patterns represent important fragments of XPath. In this paper, we show that some classes \({\mathcal{C}}\) of tree patterns exhibit such a property that, given a finite number of compatible tree patterns \({P_1, \ldots, P_n\in \mathcal{C}}\), there exists another pattern P such that P 1, . . . , P n are all contained in P, and for any tree pattern \({Q\in \mathcal{C}}\), P 1, . . . , P n are all contained in Q if and only if P is contained in Q. We experimentally demonstrate that the pattern P is usually much smaller than P 1, . . . , P n combined together. Using the existence of P above, we show that testing whether a tree pattern, P, is contained in another, \({Q\in \mathcal{C}}\), under an acyclic schema graph G, can be reduced to testing whether P G , a transformed version of P, is contained in Q without any schema graph, provided that the distinguished node of P is not labeled *. We then show that, under G, the maximal contained rewriting (MCR) of a tree pattern Q using a view V can be found by finding the MCR of Q using V G without G, when there are no *-nodes on the distinguished path of V and no *-nodes in Q.</abstract>
<topic>Information Systems and Communication Service</topic>
<topic>Software Engineering/Programming and Operating Systems</topic>
<topic>Logics and Meanings of Programs</topic>
<topic>Theory of Computation</topic>
<topic>Data Structures, Cryptology and Information Theory</topic>
<topic>Computer Systems Organization and Communication Networks</topic>
<ee>http://dx.doi.org/10.1007/s00236-012-0155-1</ee>
<url>db/journals/acta/acta49.html#WangYPL12</url>
</article>
